{"version":3,"file":"Timeline.js","sources":["../../src/extensions/Timeline.ts"],"sourcesContent":["// Timeline.ts @evallsg, @japopra\r\n\r\nimport { LX } from '../core/Namespace';\r\n\r\nif ( !LX )\r\n{\r\n    throw ( 'Missing LX namespace!' );\r\n}\r\n\r\nLX.extensions.push( 'Timeline' );\r\n\r\nLX.registerIcon( 'TimelineLock',\r\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path fill=\"none\" d=\"M7 11V7a4 4 0 0 1 9 0v4 M5,11h13 a2 2 0 0 1 2 2 v7 a2 2 0 0 1 -2 2 h-13 a2 2 0 0 1 -2 -2 v-7 a2 2 0 0 1 2 -2 M12 16 v2\"/></svg>' );\r\nLX.registerIcon( 'TimelineLockOpen',\r\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path fill=\"none\" d=\"M14 11V7a4 4 0 0 1 9 0v2 M3,11h13 a2 2 0 0 1 2 2 v7 a2 2 0 0 1 -2 2 h-13 a2 2 0 0 1 -2 -2 v-7 a2 2 0 0 1 2 -2 M8 17 h3\"/></svg>' );\r\n\r\nconst Area = LX.Area;\r\nconst Panel = LX.Panel;\r\nconst Dialog = LX.Dialog;\r\n\r\ntype Nullable<T> = T | null | undefined;\r\n\r\n/**\r\n * @class Timeline\r\n * @description Agnostic timeline, do not impose any timeline content. Renders to a canvas\r\n */\r\n\r\nexport abstract class Timeline\r\n{\r\n    static BACKGROUND_COLOR: string;\r\n    static TRACK_COLOR_PRIMARY: string;\r\n    static TRACK_COLOR_SECONDARY: string;\r\n    static TRACK_COLOR_TERTIARY: string;\r\n    static TRACK_SELECTED: string;\r\n    static FONT: string;\r\n    static FONT_COLOR_PRIMARY: string;\r\n    static FONT_COLOR_TERTIARY: string;\r\n    static FONT_COLOR_QUATERNARY: string;\r\n    static KEYFRAME_COLOR: string;\r\n    static KEYFRAME_COLOR_HOVERED: string;\r\n    static KEYFRAME_COLOR_SELECTED: string;\r\n    static KEYFRAME_COLOR_LOCK: string;\r\n    static KEYFRAME_COLOR_EDITED: string;\r\n    static KEYFRAME_COLOR_INACTIVE: string;\r\n    static TIME_MARKER_COLOR: string;\r\n    static TIME_MARKER_COLOR_TEXT: string;\r\n    static BOX_SELECTION_COLOR: string;\r\n\r\n    uniqueID: string;\r\n    timelineTitle: string;\r\n\r\n    animationClip: any;\r\n\r\n    duration: number = 1;\r\n    currentTime: number = 0; // seconds\r\n    visualTimeRange: [ number, number ] = [ 0, 0 ]; // [ start time, end time ] - visible range of time. 0 <= time <= duration\r\n    visualOriginTime: number = 0; // time visible at pixel 0. -infinity < time < infinity\r\n    pixelsPerSecond: number = 300;\r\n    secondsPerPixel: number;\r\n\r\n    clickTime: number = 0; // real world time when mouse was pressed down. Used for discard\r\n    clickDiscardTimeout: number = 200; // ms\r\n    lastMouse: [ number, number ] = [ 0, 0 ];\r\n    boxSelection: boolean = false;\r\n    boxSelectionStart: [ number, number ] = [ 0, 0 ];\r\n    boxSelectionEnd: [ number, number ] = [ 0, 0 ];\r\n\r\n    historyUndo: Array<any> = [];\r\n    historyRedo: Array<any> = [];\r\n    historySaveEnabler: boolean = true; // used in saveState\r\n    historyMaxSteps: number = 100; // used in saveState\r\n    clipboard: any = null;\r\n\r\n    grabbing: boolean = false;\r\n    grabTime: number = 0;\r\n    grabbingTimeBar: boolean = false;\r\n    grabbingScroll: boolean = false;\r\n    movingKeys: boolean = false;\r\n    timeBeforeMove: number = 0;\r\n\r\n    currentScroll: number = 0; // in percentage\r\n    currentScrollInPixels: number = 0; // in pixels\r\n    trackHeight: number = 32;\r\n    timeSeparators: number[] = [ 0.01, 0.1, 0.5, 1, 5 ];\r\n\r\n    playing: boolean = false;\r\n    loop: boolean = true;\r\n    active: boolean = true;\r\n    skipVisibility: boolean;\r\n    skipLock: boolean;\r\n    disableNewTracks: boolean;\r\n\r\n    optimizeThreshold: number = 0.01;\r\n\r\n    selectedTracks: any[] = []; // [ track, track] contains selected (highlighted ) tracks. That is, tracks with .isSelected == true. Elements in array are not ordered. Only visible tracks should be selected\r\n    selectedItems: any[] = []; // [ trackInfo, \"groupId\"], contains the visible items ( tracks or groups ) of the timeline\r\n    leftPanel: typeof Panel; // where tree will be placed\r\n    trackTreesPanel: any = null;\r\n    trackTreesComponent: any = null;\r\n    trackTreesEvents: any = {}; // holds callbacks\r\n    lastTrackTreesComponentOffset: any = 0; // this.trackTreesComponent.innerTree.domEl.offsetTop - canvas.offsetTop. Check draw()\r\n\r\n    mainArea: typeof Area;\r\n    root: HTMLBodyElement;\r\n    header: typeof Panel;\r\n    canvasArea: typeof Area; // parent of canvas\r\n    canvas: HTMLCanvasElement;\r\n    size: [ number, number ] = [ 0.000001, 0.000001 ];\r\n    topMargin: number = 40;\r\n    header_offset: number = 48;\r\n\r\n    updateTheme: () => void;\r\n\r\n    onCreateBeforeTopBar: Nullable<( headerPanel: typeof Panel ) => void> = null;\r\n    onCreateAfterTopBar: Nullable<( headerPanel: typeof Panel ) => void> = null;\r\n    onCreateControlsButtons: Nullable<( headerPanel: typeof Panel ) => void> = null;\r\n    onCreateSettingsButtons: Nullable<( headerPanel: typeof Panel ) => void> = null;\r\n    onShowOptimizeMenu: Nullable<( event: any ) => void> = null;\r\n    onShowConfiguration: Nullable<( panel: typeof Panel ) => void> = null;\r\n    onMouse: Nullable<( event: any, t: number ) => void> = null;\r\n    onDblClick: Nullable<( event: any ) => void> = null;\r\n    onShowContextMenu: Nullable<( event: any ) => void> = null;\r\n    onAddNewTrackButton: Nullable<() => void> = null; // overrides button \"add track\" behaviour\r\n    onAddNewTrack: Nullable<( track: any, options: any ) => void> = null;\r\n    onBeforeDrawContent: Nullable<( ctx: CanvasRenderingContext2D ) => void> = null;\r\n    onStateStop: Nullable<() => void> = null;\r\n    onStateChange: Nullable<( s: boolean ) => void> = null;\r\n    onChangeLoopMode: Nullable<( l: boolean ) => void> = null;\r\n    onSetDuration: Nullable<( d: number ) => void> = null;\r\n    onSetTime: Nullable<( t: number ) => void> = null;\r\n    onItemSelected: Nullable<( selected: any[], itemsToAdd: Nullable<any[]>, itemsToRemove: Nullable<any[]> ) => void> = null;\r\n    onSetTrackSelection: Nullable<( track: object, oldValue: boolean ) => void> = null;\r\n    onSetTrackState: Nullable<( track: object, oldValue: boolean ) => void> = null;\r\n    onSetTrackLock: Nullable<( track: object, oldValue: boolean ) => void> = null;\r\n    onUpdateTrack: Nullable<( tracks: number[] | string[] ) => void> = null;\r\n\r\n    configurationDialog: Nullable<typeof Dialog> = null;\r\n\r\n    abstract onMouseUp( event: any, t: number ): void;\r\n    abstract onMouseDown( event: any, t: number ): void;\r\n    abstract onMouseMove( event: any, t: number ): void;\r\n\r\n    abstract drawContent( ctx: CanvasRenderingContext2D ): void;\r\n    abstract deleteSelectedContent( skipCallback: boolean ): void;\r\n    abstract copySelectedContent(): void;\r\n    abstract pasteContent( time: number ): void;\r\n    abstract historyGenerateTrackStep( trackIdx: number ): any;\r\n    abstract historyApplyTrackStep( state: any, isUndo: boolean ): any;\r\n\r\n    /**\r\n     * @param {String} id = string unique id\r\n     * @param {Object} options = {skipLock, skipVisibility}\r\n     */\r\n    constructor( id: string, options: any = {} )\r\n    {\r\n        this.uniqueID = id ?? ( 'timeline' + Math.floor( Math.random() * 0xffffffff ) );\r\n        this.timelineTitle = options.title ?? null;\r\n\r\n        // required before updateHeader\r\n        this.onCreateBeforeTopBar = options.onCreateBeforeTopBar;\r\n        this.onCreateAfterTopBar = options.onCreateAfterTopBar;\r\n        this.onCreateControlsButtons = options.onCreateControlsButtons;\r\n        this.onCreateSettingsButtons = options.onCreateSettingsButtons;\r\n        this.onShowOptimizeMenu = options.onShowOptimizeMenu;\r\n        this.onShowConfiguration = options.onShowConfiguration;\r\n\r\n        this.canvas = document.createElement( 'canvas' );\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n\r\n        this.secondsPerPixel = 1 / this.pixelsPerSecond;\r\n        this.animationClip = this.instantiateAnimationClip();\r\n\r\n        this.loop = options.loop ?? true;\r\n        this.skipVisibility = options.skipVisibility ?? false;\r\n        this.skipLock = options.skipLock ?? false;\r\n        this.disableNewTracks = options.disableNewTracks ?? false;\r\n\r\n        // main area -- root\r\n        this.mainArea = new Area( { className: 'lextimeline' } );\r\n        this.root = this.mainArea.root;\r\n        this.mainArea.split( { type: 'vertical', sizes: [ this.header_offset, 'auto' ], resize: false } );\r\n\r\n        // header\r\n        this.header = new Panel( { id: 'lextimelineheader' } );\r\n        this.mainArea.sections[0].attach( this.header );\r\n        this.updateHeader();\r\n\r\n        // content area\r\n        const contentArea = this.mainArea.sections[1];\r\n        contentArea.root.id = 'bottom-timeline-area';\r\n        contentArea.split( { type: 'horizontal', sizes: [ '15%', '85%' ] } );\r\n        let [ left, right ] = contentArea.sections;\r\n\r\n        right.attach( this.canvas );\r\n        this.canvasArea = right;\r\n        this.canvasArea.root.classList.add( 'lextimelinearea' );\r\n\r\n        this.leftPanel = left.addPanel( { className: 'lextimelinepanel', width: '100%', height: '100%' } );\r\n        this.updateLeftPanel();\r\n\r\n        if ( this.uniqueID.length )\r\n        {\r\n            this.root.id = this.uniqueID;\r\n            this.canvas.id = this.uniqueID + '-canvas';\r\n        }\r\n\r\n        // Process mouse events\r\n        this.canvas.addEventListener( 'mousedown', this.processMouse.bind( this ) );\r\n        this.canvas.addEventListener( 'mouseup', this.processMouse.bind( this ) );\r\n        this.canvas.addEventListener( 'mousemove', this.processMouse.bind( this ) );\r\n        this.canvas.addEventListener( 'wheel', this.processMouse.bind( this ) );\r\n        this.canvas.addEventListener( 'dblclick', this.processMouse.bind( this ) );\r\n        this.canvas.addEventListener( 'contextmenu', this.processMouse.bind( this ) );\r\n\r\n        this.canvas.tabIndex = 1;\r\n        // Process keys events\r\n        this.canvasArea.root.addEventListener( 'keydown', ( e: KeyboardEvent ) => {\r\n            this.processKeys( e );\r\n        } ); // so this.processKeys can be overwritten by the user\r\n\r\n        this.canvasArea.onresize = ( bounding: { width: number; height: number; } ) => {\r\n            if ( !( bounding.width && bounding.height ) )\r\n            {\r\n                return;\r\n            }\r\n\r\n            this.resizeCanvas();\r\n        };\r\n        this.resize( this.size );\r\n\r\n        /**\r\n         * updates theme ( light - dark ) based on LX's current theme\r\n         */\r\n        function updateTheme()\r\n        {\r\n            Timeline.BACKGROUND_COLOR = LX.getCSSVariable( 'background-blur' );\r\n            Timeline.TRACK_COLOR_PRIMARY = LX.getCSSVariable( 'card' );\r\n            Timeline.TRACK_COLOR_SECONDARY = LX.getCSSVariable( 'secondary' );\r\n            Timeline.TRACK_COLOR_TERTIARY = LX.getCSSVariable( 'accent' );\r\n            Timeline.TRACK_SELECTED = LX.getCSSVariable( 'primary' );\r\n            Timeline.FONT = LX.getCSSVariable( 'global-font' );\r\n            Timeline.FONT_COLOR_PRIMARY = LX.getCSSVariable( 'foreground' );\r\n            Timeline.FONT_COLOR_TERTIARY = LX.getCSSVariable( 'primary' );\r\n            Timeline.FONT_COLOR_QUATERNARY = LX.getCSSVariable( 'muted-foreground' );\r\n            Timeline.KEYFRAME_COLOR = LX.getCSSVariable( 'lxTimeline-keyframe' );\r\n            Timeline.KEYFRAME_COLOR_SELECTED = Timeline.KEYFRAME_COLOR_HOVERED = LX.getCSSVariable(\r\n                'lxTimeline-keyframe-selected'\r\n            );\r\n            Timeline.KEYFRAME_COLOR_LOCK = LX.getCSSVariable( 'lxTimeline-keyframe-locked' );\r\n            Timeline.KEYFRAME_COLOR_EDITED = LX.getCSSVariable( 'lxTimeline-keyframe-edited' );\r\n            Timeline.KEYFRAME_COLOR_INACTIVE = LX.getCSSVariable( 'lxTimeline-keyframe-inactive' );\r\n            Timeline.TIME_MARKER_COLOR = LX.getCSSVariable( 'primary' );\r\n            Timeline.TIME_MARKER_COLOR_TEXT = LX.getCSSVariable( 'primary-foreground' );\r\n        }\r\n\r\n        this.updateTheme = updateTheme.bind( this );\r\n        LX.addSignal( '@on_new_color_scheme', this.updateTheme );\r\n        this.updateTheme();\r\n    }\r\n\r\n    // makes it ready to be deleted\r\n    clear()\r\n    {\r\n        if ( this.header )\r\n        {\r\n            this.header.clear();\r\n        }\r\n\r\n        if ( this.leftPanel )\r\n        {\r\n            this.leftPanel.clear();\r\n        }\r\n\r\n        if ( this.updateTheme )\r\n        {\r\n            let signals = LX.signals['@on_new_color_scheme'] ?? [];\r\n            for ( let i = 0; i < signals.length; ++i )\r\n            {\r\n                if ( signals[i] == this.updateTheme )\r\n                {\r\n                    signals.splice( i, 1 );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method updateHeader\r\n     */\r\n    updateHeader()\r\n    {\r\n        this.header.clear();\r\n\r\n        const header = this.header;\r\n        header.sameLine();\r\n\r\n        if ( this.timelineTitle )\r\n        {\r\n            header.addTitle( this.timelineTitle, {\r\n                style: { background: 'none', fontSize: '18px', fontStyle: 'bold', alignItems: 'center' }\r\n            } );\r\n        }\r\n\r\n        const buttonContainer = LX.makeContainer( [ 'auto', '100%' ], 'flex flex-row gap-1' );\r\n\r\n        header.queue( buttonContainer );\r\n\r\n        const playbtn = header.addButton( 'playBtn', '', ( value: any, event: Event ) => {\r\n            this.changeState();\r\n        }, { buttonClass: 'accept', title: 'Play', hideName: true, icon: 'Play@solid', swap: 'Pause@solid' } );\r\n        playbtn.setState( this.playing, true );\r\n\r\n        header.addButton( 'stopBtn', '', ( value: any, event: Event ) => {\r\n            this.setState( false, true ); // skip callback of set state\r\n            if ( this.onStateStop )\r\n            {\r\n                this.onStateStop();\r\n            }\r\n        }, { buttonClass: 'accept', title: 'Stop', hideName: true, icon: 'Stop@solid' } );\r\n\r\n        header.addButton( 'loopBtn', '', ( value: any, event: Event ) => {\r\n            this.setLoopMode( !this.loop );\r\n        }, { selectable: true, selected: this.loop, title: 'Loop', hideName: true, icon: 'RefreshCw', buttonClass: 'h-8' } );\r\n\r\n        if ( this.onCreateControlsButtons )\r\n        {\r\n            this.onCreateControlsButtons( header );\r\n        }\r\n\r\n        header.clearQueue( buttonContainer );\r\n        header.addContent( 'header-buttons', buttonContainer );\r\n\r\n        // time number inputs - duration, current time, etc\r\n\r\n        if ( this.onCreateBeforeTopBar )\r\n        {\r\n            this.onCreateBeforeTopBar( header );\r\n        }\r\n\r\n        header.addNumber( 'Current Time', this.currentTime, ( value: number, event: Event ) => {\r\n            this.setTime( value );\r\n        }, {\r\n            units: 's',\r\n            step: 0.01,\r\n            min: 0,\r\n            precision: 3,\r\n            skipSlider: true,\r\n            skipReset: true,\r\n            nameWidth: 'auto'\r\n        } );\r\n\r\n        header.addNumber( 'Duration', +this.duration.toFixed( 3 ), ( value: number, event: Event ) => {\r\n            this.setDuration( value, false, false );\r\n        }, {\r\n            units: 's',\r\n            step: 0.01,\r\n            min: 0,\r\n            skipReset: true,\r\n            nameWidth: 'auto'\r\n        } );\r\n\r\n        if ( this.onCreateAfterTopBar )\r\n        {\r\n            this.onCreateAfterTopBar( header );\r\n        }\r\n\r\n        // settings buttons - optimize, settings, etc\r\n\r\n        const buttonContainerEnd = LX.makeContainer( [ 'auto', '100%' ], 'flex flex-row gap-1' );\r\n        header.queue( buttonContainerEnd );\r\n\r\n        if ( this.onCreateSettingsButtons )\r\n        {\r\n            this.onCreateSettingsButtons( header );\r\n        }\r\n\r\n        if ( this.onShowOptimizeMenu )\r\n        {\r\n            header.addButton( null, '', ( value: any, event: Event ) => {\r\n                if ( this.onShowOptimizeMenu )\r\n                {\r\n                    this.onShowOptimizeMenu( event );\r\n                }\r\n            }, { tooltip: true, title: 'Optimize', icon: 'Filter' } );\r\n        }\r\n\r\n        if ( this.onShowConfiguration )\r\n        {\r\n            header.addButton( null, '', ( value: any, event: Event ) => {\r\n                if ( this.configurationDialog )\r\n                {\r\n                    this.configurationDialog.close();\r\n                    this.configurationDialog = null;\r\n                    return;\r\n                }\r\n                this.configurationDialog = new Dialog( 'Configuration', ( p: typeof Panel ) => {\r\n                    if ( this.onShowConfiguration )\r\n                    {\r\n                        this.onShowConfiguration( p );\r\n                    }\r\n                }, {\r\n                    onBeforeClose: () => {\r\n                        this.configurationDialog.panel.clear(); // clear signals\r\n                        this.configurationDialog = null;\r\n                    }\r\n                } );\r\n            }, { title: 'Settings', icon: 'Settings', tooltip: true } );\r\n        }\r\n\r\n        header.clearQueue( buttonContainerEnd );\r\n        header.addContent( 'header-buttons-end', buttonContainerEnd );\r\n\r\n        header.endLine( 'justify-between' );\r\n    }\r\n\r\n    setTrackTreeEventListener( type: string, callback: ( event: any ) => any )\r\n    {\r\n        this.trackTreesEvents[type] = callback;\r\n        if ( type != 'select' && type != 'visibleChanged' )\r\n        {\r\n            this.trackTreesComponent.on( type, this.trackTreesEvents[type] );\r\n        }\r\n    }\r\n    /**\r\n     * @method updateLeftPanel\r\n     */\r\n    updateLeftPanel()\r\n    {\r\n        this.leftPanel.clear();\r\n\r\n        const panel = this.leftPanel;\r\n\r\n        panel.sameLine();\r\n        let titleComponent = panel.addTitle( 'Tracks', { style: { background: 'none' }, className: 'text-lg px-4' } );\r\n        let title = titleComponent.root;\r\n\r\n        if ( !this.disableNewTracks )\r\n        {\r\n            panel.addButton( 'addTrackBtn', '', ( value: any, event: Event ) => {\r\n                if ( this.onAddNewTrackButton )\r\n                {\r\n                    this.onAddNewTrackButton();\r\n                }\r\n                else\r\n                {\r\n                    this.addNewTrack();\r\n                }\r\n            }, { hideName: true, title: 'Add Track', icon: 'Plus' } );\r\n        }\r\n        panel.endLine();\r\n\r\n        const styles = window.getComputedStyle( title );\r\n        const titleHeight = title.clientHeight + parseFloat( styles['marginTop'] )\r\n            + parseFloat( styles['marginBottom'] );\r\n\r\n        let p = new LX.Panel( { height: 'calc(100% - ' + titleHeight + 'px )' } );\r\n\r\n        let treeTracks: any[] = [];\r\n        if ( this.animationClip && this.selectedItems.length )\r\n        {\r\n            treeTracks = this.generateSelectedItemsTreeData();\r\n        }\r\n\r\n        this.trackTreesComponent = p.addTree( null, treeTracks, { filter: false, rename: false, draggable: false } );\r\n\r\n        this.trackTreesComponent.on( 'select', ( event: any, resolve: any ) => {\r\n            const node = event.items[0];\r\n            if ( !event.domEvent.shiftKey )\r\n            {\r\n                this.deselectAllTracks( false ); // no need to update left panel\r\n            }\r\n            if ( node.trackData )\r\n            {\r\n                const flag = event.domEvent.shiftKey ? !node.trackData.isSelected : true;\r\n                this.setTrackSelection( node.trackData.trackIdx, flag, false, false ); // do callback, do not update left panel\r\n            }\r\n\r\n            if ( this.trackTreesEvents['select'] )\r\n            {\r\n                this.trackTreesEvents['select']( event );\r\n            }\r\n        } );\r\n\r\n        this.trackTreesComponent.on( 'visibleChanged', ( event: any, resolve: any ) => {\r\n            const node = event.items[0];\r\n            if ( node.trackData )\r\n            {\r\n                this.setTrackState( node.trackData.trackIdx, node.visible, false, false ); // do not update left panel\r\n            }\r\n\r\n            if ( this.trackTreesEvents['visibleChanged'] )\r\n            {\r\n                this.trackTreesEvents['visibleChanged']( event );\r\n            }\r\n        } );\r\n\r\n        // reset all tree events to the new tree\r\n        for ( let name in this.trackTreesEvents )\r\n        {\r\n            this.setTrackTreeEventListener( name, this.trackTreesEvents[name] );\r\n        }\r\n\r\n        const that = this;\r\n        this.trackTreesComponent.innerTree._refresh = this.trackTreesComponent.innerTree.refresh;\r\n        this.trackTreesComponent.innerTree.refresh = function( newData: any, selectedId: Nullable<string> )\r\n        {\r\n            this._refresh( newData, selectedId );\r\n            that.setTrackHeight( that.trackHeight );\r\n        };\r\n\r\n        if ( this.selectedTracks.length )\r\n        {\r\n            this._updateTrackTreeSelection(); // select visible tracks\r\n        }\r\n\r\n        // setting a name in the addTree function adds an undesired node\r\n        this.trackTreesComponent.name = 'tracksTrees';\r\n        p.components[this.trackTreesComponent.name] = this.trackTreesComponent;\r\n\r\n        this.trackTreesPanel = p;\r\n        panel.attach( p.root );\r\n        p.root.addEventListener( 'scroll', ( e: any ) => {\r\n            if ( e.currentTarget.scrollHeight > e.currentTarget.clientHeight )\r\n            {\r\n                this.currentScroll = e.currentTarget.scrollTop\r\n                    / ( e.currentTarget.scrollHeight - e.currentTarget.clientHeight );\r\n                this.currentScrollInPixels = e.currentTarget.scrollTop;\r\n            }\r\n            else\r\n            {\r\n                this.currentScroll = 0;\r\n                this.currentScrollInPixels = 0;\r\n            }\r\n        } );\r\n\r\n        this.trackTreesPanel.root.scrollTop = this.currentScrollInPixels;\r\n        this.setTrackHeight( this.trackHeight );\r\n\r\n        if ( this.leftPanel.parent.root.classList.contains( 'hidden' ) || !this.root.parentElement )\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.resizeCanvas();\r\n\r\n        this.setScroll( this.currentScroll ); // avoid scroll bugs\r\n    }\r\n\r\n    setTrackHeight( trackHeight: number )\r\n    {\r\n        // ul list has a \"gap\" of 0.25rem. Compute pixel count of 0.25 rem\r\n        const gapSize = parseFloat( getComputedStyle( document.documentElement ).fontSize ) * 0.25;\r\n\r\n        this.trackHeight = trackHeight = Math.max( gapSize, trackHeight );\r\n\r\n        if ( !this.trackTreesComponent )\r\n        {\r\n            return;\r\n        }\r\n\r\n        trackHeight -= gapSize;\r\n        const tracks = this.trackTreesComponent.root.querySelector( 'ul' ).children;\r\n        for ( let i = 0; i < tracks.length; ++i )\r\n        {\r\n            tracks[i].style.height = trackHeight + 'px';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Object} options options for the new track\r\n     *  { id: string, active: bool, locked: bool, }\r\n     * @returns\r\n     */\r\n    addNewTrack( options: any = {}, skipCallback: boolean = false )\r\n    {\r\n        const trackInfo = this.instantiateTrack( options );\r\n        trackInfo.trackIdx = this.animationClip.tracks.length;\r\n        this.animationClip.tracks.push( trackInfo );\r\n\r\n        if ( this.onAddNewTrack && !skipCallback )\r\n        {\r\n            this.onAddNewTrack( trackInfo, options );\r\n        }\r\n\r\n        return trackInfo.trackIdx;\r\n    }\r\n\r\n    /**\r\n     * Finds tracks ( wholy and partially ) inside the range minY maxY.\r\n     * ( Full ) Canvas local coordinates.\r\n     * @param {Number} minY pixels\r\n     * @param {Number} maxY pixels\r\n     * @returns array of trackDatas\r\n     */\r\n    getTracksInRange( minY: number, maxY: number )\r\n    {\r\n        let tracks: any = [];\r\n\r\n        // Manage negative selection\r\n        if ( minY > maxY )\r\n        {\r\n            let aux = minY;\r\n            minY = maxY;\r\n            maxY = aux;\r\n        }\r\n\r\n        const elements = this.getVisibleItems();\r\n        if ( elements.length < 1 )\r\n        {\r\n            return [];\r\n        }\r\n\r\n        const startY = minY - this.lastTrackTreesComponentOffset + this.currentScrollInPixels;\r\n        const endY = maxY - this.lastTrackTreesComponentOffset + this.currentScrollInPixels;\r\n\r\n        const startIdx = Math.max( 0, Math.floor( startY / this.trackHeight ) );\r\n        const endIdx = Math.min( elements.length - 1, Math.floor( endY / this.trackHeight ) ) + 1;\r\n\r\n        for ( let i = startIdx; i < endIdx; ++i )\r\n        {\r\n            const e = elements[i];\r\n            if ( e.treeData && e.treeData.trackData )\r\n            {\r\n                tracks.push( e.treeData.trackData );\r\n            }\r\n        }\r\n\r\n        return tracks;\r\n    }\r\n\r\n    /**\r\n     * @method setAnimationClip\r\n     * @param {*} animation\r\n     * @param {Boolean} needsToProcess\r\n     * @param {Object} processOptions\r\n     * [ KeyFrameTimeline ] - each track should contain an attribute \"dim\" to indicate the value dimension ( e.g. vector3 -> dim=3). Otherwise dimensions will be infered from track's values and times. Default is 1\r\n     */\r\n    setAnimationClip( animation: any, needsToProcess: boolean = true )\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left panel yet\r\n\r\n        this.selectedItems = [];\r\n\r\n        this.clearState();\r\n\r\n        if ( !animation || !animation.tracks || needsToProcess )\r\n        {\r\n            this.animationClip = this.instantiateAnimationClip( animation ); // generate default animationclip or process the user's one\r\n        }\r\n        else\r\n        {\r\n            this.animationClip = animation;\r\n        }\r\n\r\n        this.setDuration( this.animationClip.duration, true, true );\r\n\r\n        this.updateLeftPanel();\r\n\r\n        this.resize();\r\n\r\n        return this.animationClip;\r\n    }\r\n\r\n    drawTimeInfo( w: number, h: number = this.topMargin )\r\n    {\r\n        let ctx: any = this.canvas.getContext( '2d' );\r\n        ctx.font = '11px ' + Timeline.FONT; // \"11px Calibri\";\r\n        ctx.textAlign = 'center';\r\n\r\n        // Draw time markers\r\n        ctx.save();\r\n\r\n        // background of timeinfo\r\n        ctx.fillStyle = Timeline.BACKGROUND_COLOR;\r\n        ctx.fillRect( 0, 0, this.canvas.width, h );\r\n        ctx.strokeStyle = Timeline.FONT_COLOR_PRIMARY;\r\n\r\n        // set tick and sub tick times\r\n        let tickTime = 4;\r\n        if ( this.pixelsPerSecond > 900 ) tickTime = 1;\r\n        else if ( this.pixelsPerSecond > 100 ) tickTime = 2;\r\n        else if ( this.pixelsPerSecond > 50 ) tickTime = 3;\r\n\r\n        let subtickTime = this.timeSeparators[tickTime - 1];\r\n        tickTime = this.timeSeparators[tickTime];\r\n\r\n        const startTime = this.visualTimeRange[0];\r\n        const endTime = this.visualTimeRange[1];\r\n        // Transform times into pixel coords\r\n        let tickX = this.timeToX( startTime + tickTime ) - this.timeToX( startTime );\r\n        let subtickX = subtickTime * tickX / tickTime;\r\n\r\n        let startx = this.timeToX( Math.floor( startTime / tickTime ) * tickTime ); // floor because might need to draw previous subticks\r\n        startx += 0.0000001; // slight offset to avoid \"-0.0\"\r\n        let endx = this.timeToX( endTime ); // draw up to endTime\r\n\r\n        // Begin drawing\r\n        ctx.beginPath();\r\n        ctx.fillStyle = Timeline.FONT_COLOR_PRIMARY;\r\n        ctx.globalAlpha = 1;\r\n\r\n        for ( let x = startx; x <= endx; x += tickX )\r\n        {\r\n            // Draw main line\r\n            ctx.moveTo( Math.round( x ) + 0.5, h * 0.4 + h * 0.3 );\r\n            ctx.lineTo( Math.round( x ) + 0.5, h * 0.95 );\r\n\r\n            // Draw following sub lines\r\n            let endsub = x + tickX - subtickX * 0.5;\r\n            for ( let subX = x; subX < endsub && subX < endx; subX += subtickX )\r\n            {\r\n                ctx.moveTo( Math.round( subX ) + 0.5, h * 0.4 + h * 0.45 );\r\n                ctx.lineTo( Math.round( subX ) + 0.5, h * 0.95 );\r\n            }\r\n\r\n            // Draw time number\r\n            let t = this.xToTime( x );\r\n            ctx.fillText( t.toFixed( tickTime < 1 ? 1 : 0 ), x, h * 0.6 );\r\n        }\r\n\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n\r\n    drawTracksBackground( w: number, h: number )\r\n    {\r\n        let canvas = this.canvas;\r\n        let ctx: any = canvas.getContext( '2d' );\r\n        let duration = this.duration;\r\n        ctx.globalAlpha = 1;\r\n\r\n        // Content\r\n        const topMargin = this.topMargin;\r\n        const treeOffset = this.lastTrackTreesComponentOffset;\r\n        const line_height = this.trackHeight;\r\n\r\n        // fill track lines\r\n        w = w || canvas.width;\r\n        let max_tracks = Math.ceil( ( h - topMargin ) / line_height ) + 1;\r\n\r\n        ctx.save();\r\n        ctx.fillStyle = Timeline.TRACK_COLOR_SECONDARY;\r\n\r\n        const rectsOffset = this.currentScrollInPixels % line_height;\r\n        const blackOrWhite = Math.floor( this.currentScrollInPixels / line_height ) % 2;\r\n        for ( let i = blackOrWhite; i <= max_tracks; i += 2 )\r\n        {\r\n            ctx.fillRect( 0, treeOffset - rectsOffset + i * line_height, w, line_height );\r\n        }\r\n\r\n        // bg lines\r\n        ctx.strokeStyle = Timeline.TRACK_COLOR_TERTIARY;\r\n        ctx.beginPath();\r\n\r\n        let pos = this.timeToX( 0 );\r\n        if ( pos < 0 ) pos = 0;\r\n        ctx.lineWidth = 1;\r\n        ctx.moveTo( pos + 0.5, topMargin );\r\n        ctx.lineTo( pos + 0.5, canvas.height );\r\n        ctx.moveTo( Math.round( this.timeToX( duration ) ) + 0.5, topMargin );\r\n        ctx.lineTo( Math.round( this.timeToX( duration ) ) + 0.5, canvas.height );\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * @method draw\r\n     */\r\n\r\n    draw()\r\n    {\r\n        let ctx: any = this.canvas.getContext( '2d' );\r\n        ctx.textBaseline = 'bottom';\r\n        ctx.font = '11px ' + Timeline.FONT; // \"11px Calibri\";\r\n        ctx.globalAlpha = 1;\r\n\r\n        const w = ctx.canvas.width;\r\n        const h = ctx.canvas.height;\r\n\r\n        const scrollableHeight = this.trackTreesComponent.root.scrollHeight;\r\n        // hack: get 'ul' start pos to know when tracks start\r\n        // tree has gaps of 0.25rem (4px ) inbetween entries but not in the beginning nor ending. Move half gap upwards.\r\n        const treeOffset = this.lastTrackTreesComponentOffset = this.trackTreesComponent.innerTree.domEl.children[0].offsetTop\r\n            - this.canvas.offsetTop - 2;\r\n\r\n        // zoom\r\n        let startTime = this.visualOriginTime; // seconds\r\n        startTime = Math.min( this.duration, Math.max( 0, startTime ) );\r\n        let endTime = this.visualOriginTime + w * this.secondsPerPixel; // seconds\r\n        endTime = Math.max( startTime, Math.min( this.duration, endTime ) );\r\n        this.visualTimeRange[0] = startTime;\r\n        this.visualTimeRange[1] = endTime;\r\n\r\n        // Background\r\n        ctx.globalAlpha = 1;\r\n        ctx.fillStyle = Timeline.TRACK_COLOR_SECONDARY;\r\n        ctx.clearRect( 0, 0, this.canvas.width, this.canvas.height );\r\n\r\n        this.drawTracksBackground( w, h );\r\n\r\n        if ( this.onBeforeDrawContent )\r\n        {\r\n            this.onBeforeDrawContent( ctx );\r\n        }\r\n\r\n        if ( this.animationClip )\r\n        {\r\n            ctx.translate( 0, treeOffset );\r\n            this.drawContent( ctx );\r\n            ctx.translate( 0, -treeOffset );\r\n        }\r\n\r\n        // scrollbar\r\n        if ( ( h - this.topMargin ) < scrollableHeight )\r\n        {\r\n            ctx.fillStyle = '#222';\r\n            ctx.fillRect( w - 10, 0, 10, h );\r\n\r\n            ctx.fillStyle = this.grabbingScroll ? Timeline.FONT_COLOR_TERTIARY : Timeline.FONT_COLOR_QUATERNARY;\r\n\r\n            let scrollBarHeight = Math.max( 10, ( h - this.topMargin ) * ( h - this.topMargin ) / this.trackTreesPanel.root.scrollHeight );\r\n            let scrollLoc = this.currentScroll * ( h - this.topMargin - scrollBarHeight ) + this.topMargin;\r\n            drawRoundRect( ctx, w - 10, scrollLoc, 10, scrollBarHeight, 5, true );\r\n        }\r\n\r\n        this.drawTimeInfo( w );\r\n\r\n        // Current time marker vertical line\r\n        let posx = Math.round( this.timeToX( this.currentTime ) );\r\n        let posy = this.topMargin * 0.4;\r\n\r\n        if ( posx >= 0 )\r\n        {\r\n            ctx.strokeStyle = ctx.fillStyle = Timeline.TIME_MARKER_COLOR;\r\n            ctx.globalAlpha = 1;\r\n            ctx.beginPath();\r\n            ctx.moveTo( posx, posy * 0.6 );\r\n            ctx.lineTo( posx, this.canvas.height ); // line\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n            ctx.shadowBlur = 8;\r\n            ctx.shadowColor = Timeline.TIME_MARKER_COLOR;\r\n            ctx.shadowOffsetX = 1;\r\n            ctx.shadowOffsetY = 1;\r\n\r\n            drawRoundRect( ctx, posx - 10, posy * 0.6, 20, posy, 5, true );\r\n            ctx.fill();\r\n            ctx.shadowBlur = 0;\r\n            ctx.shadowOffsetX = 0;\r\n            ctx.shadowOffsetY = 0;\r\n        }\r\n\r\n        // Current time seconds in text\r\n        ctx.font = '11px ' + Timeline.FONT; // \"11px Calibri\";\r\n        ctx.textAlign = 'center';\r\n        // ctx.textBaseline = \"middle\";\r\n        ctx.fillStyle = Timeline.TIME_MARKER_COLOR_TEXT;\r\n        ctx.fillText( ( Math.floor( this.currentTime * 10 ) * 0.1 ).toFixed( 1 ), posx, this.topMargin * 0.6 );\r\n\r\n        // Selections\r\n        ctx.strokeStyle = ctx.fillStyle = Timeline.FONT_COLOR_PRIMARY;\r\n        if ( this.boxSelection )\r\n        {\r\n            ctx.globalAlpha = 0.15;\r\n            ctx.fillStyle = Timeline.BOX_SELECTION_COLOR;\r\n            ctx.strokeRect( this.boxSelectionStart[0], this.boxSelectionStart[1], this.boxSelectionEnd[0] - this.boxSelectionStart[0],\r\n                this.boxSelectionEnd[1] - this.boxSelectionStart[1] );\r\n            ctx.fillRect( this.boxSelectionStart[0], this.boxSelectionStart[1], this.boxSelectionEnd[0] - this.boxSelectionStart[0],\r\n                this.boxSelectionEnd[1] - this.boxSelectionStart[1] );\r\n            ctx.stroke();\r\n            ctx.globalAlpha = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method clearState\r\n     */\r\n\r\n    clearState()\r\n    {\r\n        this.historyUndo = [];\r\n        this.historyRedo = [];\r\n    }\r\n\r\n    /**\r\n     * @method setDuration\r\n     * @param {Number} t\r\n     * @param {Boolean} skipCallback\r\n     * @param {Boolean} updateHeader\r\n     */\r\n    setDuration( t: number, skipCallback: boolean = false, updateHeader: boolean = true )\r\n    {\r\n        let v = Math.max( 0, t );\r\n        this.duration = this.animationClip.duration = v;\r\n\r\n        if ( updateHeader )\r\n        {\r\n            this.header.components['Duration'].set( +this.duration.toFixed( 2 ), true ); // skipcallback = true\r\n        }\r\n\r\n        if ( this.onSetDuration && !skipCallback )\r\n        {\r\n            this.onSetDuration( this.duration );\r\n        }\r\n    }\r\n\r\n    setTime( time: number, skipCallback: boolean = false )\r\n    {\r\n        this.currentTime = Math.max( 0, Math.min( time, this.duration ) );\r\n        this.header.components['Current Time'].set( +this.currentTime.toFixed( 2 ), true ); // skipcallback = true\r\n\r\n        if ( this.onSetTime && !skipCallback )\r\n        {\r\n            this.onSetTime( this.currentTime );\r\n        }\r\n    }\r\n\r\n    // Converts distance in pixels to time\r\n    xToTime( x: number )\r\n    {\r\n        return x * this.secondsPerPixel + this.visualOriginTime;\r\n    }\r\n\r\n    // Converts time to disance in pixels\r\n    timeToX( t: number )\r\n    {\r\n        return ( t - this.visualOriginTime ) * this.pixelsPerSecond;\r\n    }\r\n\r\n    /**\r\n     * @method setScale\r\n     * @param {*} pixelsPerSecond >0.  totalVisiblePixels / totalVisibleSeconds.\r\n     */\r\n\r\n    setScale( pixelsPerSecond: number )\r\n    {\r\n        const xCurrentTime = this.timeToX( this.currentTime );\r\n        this.pixelsPerSecond = pixelsPerSecond;\r\n        this.pixelsPerSecond = Math.max( 0.00001, this.pixelsPerSecond );\r\n\r\n        this.secondsPerPixel = 1 / this.pixelsPerSecond;\r\n        this.visualOriginTime += this.currentTime - this.xToTime( xCurrentTime );\r\n    }\r\n\r\n    /**\r\n     * @method setScroll\r\n     * not delta from last state, but full scroll amount.\r\n     * @param {Number} scrollY either pixels or [0,1 ]\r\n     * @param {Boolean} normalized if true, scrollY is in range[0,1 ] being 1 fully scrolled. Otherwised scrollY represents pixels\r\n     * @returns\r\n     */\r\n\r\n    setScroll( scrollY: number, normalized: boolean = true )\r\n    {\r\n        if ( !this.trackTreesPanel )\r\n        {\r\n            this.currentScroll = 0;\r\n            this.currentScrollInPixels = 0;\r\n            return;\r\n        }\r\n\r\n        const r = this.trackTreesPanel.root;\r\n        if ( r.scrollHeight > r.clientHeight )\r\n        {\r\n            if ( normalized )\r\n            {\r\n                this.currentScroll = scrollY;\r\n                this.currentScrollInPixels = scrollY * ( r.scrollHeight - r.clientHeight );\r\n            }\r\n            else\r\n            {\r\n                this.currentScroll = scrollY / ( r.scrollHeight - r.clientHeight );\r\n                this.currentScrollInPixels = scrollY;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.currentScroll = 0;\r\n            this.currentScrollInPixels = 0;\r\n        }\r\n\r\n        // automatically calls event.\r\n        this.trackTreesPanel.root.scrollTop = this.currentScrollInPixels;\r\n    }\r\n\r\n    /**\r\n     * @method processMouse\r\n     * @param {*} e\r\n     */\r\n\r\n    processMouse( e: any /*MouseEvent*/ )\r\n    {\r\n        if ( !this.canvas )\r\n        {\r\n            return;\r\n        }\r\n\r\n        let h = this.canvas.height;\r\n        let w = this.canvas.width;\r\n\r\n        // Process mouse\r\n        let x = e.offsetX;\r\n        let y = e.offsetY;\r\n        e.deltax = x - this.lastMouse[0];\r\n        e.deltay = y - this.lastMouse[1];\r\n        let localX = e.offsetX;\r\n        let localY = e.offsetY;\r\n\r\n        let timeX = this.timeToX( this.currentTime );\r\n        let isHoveringTimeBar = localY < this.topMargin\r\n            && localX > ( timeX - 6 ) && localX < ( timeX + 6 );\r\n\r\n        const time = this.xToTime( x );\r\n\r\n        if ( isHoveringTimeBar )\r\n        {\r\n            this.canvas.style.cursor = 'col-resize';\r\n        }\r\n        else if ( this.movingKeys )\r\n        {\r\n            this.canvas.style.cursor = 'grabbing';\r\n        }\r\n        else if ( e.shiftKey )\r\n        {\r\n            this.canvas.style.cursor = 'crosshair';\r\n        }\r\n        else\r\n        {\r\n            this.canvas.style.cursor = 'default';\r\n        }\r\n\r\n        if ( e.type == 'wheel' )\r\n        {\r\n            if ( e.shiftKey )\r\n            {\r\n                if ( e.wheelDelta )\r\n                {\r\n                    let mouseTime = this.xToTime( localX );\r\n                    this.setScale( this.pixelsPerSecond * ( e.wheelDelta < 0 ? 0.95 : 1.05 ) );\r\n                    this.visualOriginTime = mouseTime - localX * this.secondsPerPixel;\r\n                }\r\n            }\r\n            else if ( ( h - this.topMargin ) < this.trackTreesComponent.root.scrollHeight )\r\n            {\r\n                this.trackTreesPanel.root.scrollTop += e.deltaY; // wheel deltaY\r\n            }\r\n\r\n            if ( this.onMouse )\r\n            {\r\n                this.onMouse( e, time );\r\n            }\r\n            return;\r\n        }\r\n\r\n        const is_inside = x >= 0 && x <= this.size[0]\r\n            && y >= 0 && y <= this.size[1];\r\n\r\n        let track = this.getTracksInRange( localY, localY );\r\n        track = track.length ? track[0] : null;\r\n\r\n        e.track = track;\r\n        e.localX = localX;\r\n        e.localY = localY;\r\n\r\n        if ( e.type == 'mouseup' )\r\n        {\r\n            if ( !this.active )\r\n            {\r\n                this.grabbing = false;\r\n                this.grabbingTimeBar = false;\r\n                this.grabbingScroll = false;\r\n                this.movingKeys = false;\r\n                this.timeBeforeMove = 0;\r\n                this.boxSelection = false;\r\n                return;\r\n            }\r\n\r\n            // this.canvas.style.cursor = \"default\";\r\n            const discard = this.movingKeys || ( LX.getTime() - this.clickTime ) > this.clickDiscardTimeout; // ms\r\n\r\n            e.discard = discard;\r\n\r\n            if ( !this.grabbingScroll && !this.grabbingTimeBar && e.button == 0 && this.onMouseUp )\r\n            {\r\n                this.onMouseUp( e, time );\r\n            }\r\n\r\n            this.grabbing = false;\r\n            this.grabbingTimeBar = false;\r\n            this.grabbingScroll = false;\r\n            this.movingKeys = false;\r\n            this.timeBeforeMove = 0;\r\n            this.boxSelection = false; // after mouseup\r\n        }\r\n\r\n        if ( e.type == 'mousedown' )\r\n        {\r\n            window.getSelection()?.empty(); // if canvas DOM is selected, dragging does not work properly. Deselect it\r\n\r\n            // e.preventDefault();\r\n\r\n            this.clickTime = LX.getTime();\r\n\r\n            if ( e.shiftKey && this.active )\r\n            {\r\n                this.boxSelection = true;\r\n                this.boxSelectionEnd[0] = this.boxSelectionStart[0] = localX;\r\n                this.boxSelectionEnd[1] = this.boxSelectionStart[1] = localY;\r\n                return; // Handled\r\n            }\r\n            else if ( e.localY < this.topMargin )\r\n            {\r\n                this.grabbing = true;\r\n                this.grabbingTimeBar = true;\r\n                this.setTime( time );\r\n            }\r\n            else if ( ( h - this.topMargin ) < this.trackTreesComponent.root.scrollHeight && x > w - 10 )\r\n            { // grabbing scroll bar\r\n                this.grabbing = true;\r\n                this.grabbingScroll = true;\r\n            }\r\n            // grabbing canvas\r\n            else\r\n            {\r\n                this.grabbing = true;\r\n                this.grabTime = time;\r\n                this.grabbingTimeBar = isHoveringTimeBar;\r\n                if ( this.onMouseDown && this.active )\r\n                {\r\n                    this.onMouseDown( e, time );\r\n                }\r\n            }\r\n        }\r\n        else if ( e.type == 'mousemove' )\r\n        {\r\n            if ( e.shiftKey && this.active && this.boxSelection )\r\n            {\r\n                this.boxSelectionEnd[0] = localX;\r\n                this.boxSelectionEnd[1] = localY;\r\n                return; // Handled\r\n            }\r\n            else if ( this.grabbing && e.button != 2 && !this.movingKeys )\r\n            { // e.buttons != 2 on mousemove needs to be plural\r\n                this.canvas.style.cursor = 'grabbing';\r\n                if ( this.grabbingTimeBar && this.active )\r\n                {\r\n                    this.setTime( time );\r\n                }\r\n                else if ( this.grabbingScroll )\r\n                {\r\n                    // will automatically call scroll event\r\n                    if ( y < this.topMargin )\r\n                    {\r\n                        this.trackTreesPanel.root.scrollTop = 0;\r\n                    }\r\n                    else\r\n                    {\r\n                        this.trackTreesPanel.root.scrollTop += this.trackTreesPanel.root.scrollHeight * e.deltay\r\n                            / ( h - this.topMargin );\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    // Move timeline in X ( independent of current time )\r\n                    var old = this.xToTime( this.lastMouse[0] );\r\n                    var now = this.xToTime( e.offsetX );\r\n                    this.visualOriginTime += old - now;\r\n                    this.trackTreesPanel.root.scrollTop -= e.deltay; // will automatically call scroll event\r\n                }\r\n            }\r\n\r\n            if ( this.onMouseMove )\r\n            {\r\n                this.onMouseMove( e, time );\r\n            }\r\n        }\r\n        else if ( e.type == 'dblclick' && this.onDblClick )\r\n        {\r\n            this.onDblClick( e );\r\n        }\r\n        else if ( e.type == 'contextmenu' && this.onShowContextMenu && this.active )\r\n        {\r\n            this.onShowContextMenu( e );\r\n        }\r\n\r\n        this.lastMouse[0] = x;\r\n        this.lastMouse[1] = y;\r\n\r\n        if ( !is_inside && !this.grabbing && !( e.metaKey || e.altKey ) )\r\n        {\r\n            return true;\r\n        }\r\n\r\n        if ( this.onMouse )\r\n        {\r\n            this.onMouse( e, time );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * keydown\r\n     * @method processKeys\r\n     * @param {*} e\r\n     */\r\n    processKeys( e: KeyboardEvent )\r\n    {\r\n        switch ( e.key )\r\n        {\r\n            case 'Delete':\r\n            case 'Backspace':\r\n                this.deleteSelectedContent( false );\r\n                break;\r\n            case 'c':\r\n            case 'C':\r\n                if ( e.ctrlKey ) this.copySelectedContent();\r\n                break;\r\n            case 'v':\r\n            case 'V':\r\n                if ( e.ctrlKey ) this.pasteContent( this.currentTime );\r\n                break;\r\n            case ' ':\r\n                e.preventDefault();\r\n                e.stopImmediatePropagation();\r\n                this.changeState();\r\n                break;\r\n\r\n            case 'Shift':\r\n                this.canvas.style.cursor = 'crosshair';\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method changeState\r\n     * @param {Boolean} skipCallback defaults false\r\n     * @description change play/pause state\r\n     */\r\n    changeState( skipCallback = false )\r\n    {\r\n        this.setState( !this.playing, skipCallback );\r\n    }\r\n    /**\r\n     * @method setState\r\n     * @param {Boolean} state\r\n     * @param {Boolean} skipCallback defaults false\r\n     * @description change play/pause state\r\n     */\r\n    setState( state: boolean, skipCallback: boolean = false )\r\n    {\r\n        this.playing = state;\r\n\r\n        this.header.components.playBtn.setState( this.playing, true );\r\n\r\n        if ( this.onStateChange && !skipCallback )\r\n        {\r\n            this.onStateChange( this.playing );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method setLoopMode\r\n     * @param {Boolean} loopState\r\n     * @param {Boolean} skipCallback defaults false\r\n     * @description change loop mode of the timeline\r\n     */\r\n    setLoopMode( loopState: boolean, skipCallback: boolean = false )\r\n    {\r\n        this.loop = loopState;\r\n\r\n        if ( this.loop )\r\n        {\r\n            this.header.components.loopBtn.root.children[0].classList.add( 'selected' );\r\n        }\r\n        else\r\n        {\r\n            this.header.components.loopBtn.root.children[0].classList.remove( 'selected' );\r\n        }\r\n\r\n        if ( this.onChangeLoopMode && !skipCallback )\r\n        {\r\n            this.onChangeLoopMode( this.loop );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the tree elements ( tracks and grouops ) shown in the timeline.\r\n     *  Each item has { treeData: { trackData: track } }, where track is the actual track information of the animationClip.\r\n     *  If not a track, trackData will be undefined\r\n     */\r\n    getVisibleItems()\r\n    {\r\n        return this.trackTreesComponent.innerTree.domEl.children[0].children; // children of 'ul'\r\n    }\r\n\r\n    /**\r\n     * [ trackIdx ]\r\n     * @param {Array} itemsName array of numbers identifying tracks\r\n     */\r\n    setSelectedItems( items: any[], skipCallback: boolean = false )\r\n    {\r\n        this.selectedItems = [];\r\n        this.changeSelectedItems( items, null, skipCallback );\r\n    }\r\n\r\n    /**\r\n     * @param {Array} itemsToAdd [ trackIdx ], array of numbers identifying tracks by their index\r\n     * @param {Array} itemsToRemove [ trackIdx ], array of numbers identifying tracks by their index\r\n     */\r\n    changeSelectedItems( itemsToAdd: Nullable<any[]> = null, itemsToRemove: Nullable<any[]> = null, skipCallback: boolean = false )\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left panel. It is going to be rebuilt anyways\r\n\r\n        const tracks = this.animationClip.tracks;\r\n\r\n        if ( itemsToRemove )\r\n        {\r\n            for ( let i = 0; i < itemsToRemove.length; ++i )\r\n            {\r\n                const compareObj = itemsToRemove[i];\r\n                for ( let s = 0; s < this.selectedItems.length; ++s )\r\n                {\r\n                    if ( this.selectedItems[s] === compareObj )\r\n                    {\r\n                        this.selectedItems.splice( s, 1 );\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if ( itemsToAdd )\r\n        {\r\n            for ( let i = 0; i < itemsToAdd.length; ++i )\r\n            {\r\n                const v = itemsToAdd[i];\r\n                if ( tracks[v] )\r\n                {\r\n                    this.selectedItems.push( tracks[v] );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateLeftPanel();\r\n\r\n        if ( this.onItemSelected && !skipCallback )\r\n        {\r\n            this.onItemSelected( this.selectedItems, itemsToAdd, itemsToRemove );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * It will find the first occurrence of trackId in animationClip.tracks\r\n     * @param {String} trackId\r\n     * @returns\r\n     */\r\n    getTrack( trackId: string )\r\n    {\r\n        const tracks = this.animationClip.tracks;\r\n\r\n        for ( let i = 0; i < tracks.length; ++i )\r\n        {\r\n            if ( tracks[i].id == trackId )\r\n            {\r\n                return tracks[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @param {Boolean} updateTrackTree whether the track tree needs a refresh\r\n     * @returns\r\n     */\r\n    deselectAllTracks( updateTrackTree: boolean = true )\r\n    {\r\n        if ( !this.animationClip )\r\n        {\r\n            return;\r\n        }\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        for ( let i = 0; i < tracks.length; i++ )\r\n        {\r\n            tracks[i].isSelected = false;\r\n        }\r\n\r\n        this.selectedTracks.length = 0;\r\n\r\n        if ( updateTrackTree )\r\n        {\r\n            this._updateTrackTreeSelection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Int} trackIdx\r\n     * @param {Boolean} isSelected new \"selected\" state of the track\r\n     * @param {Boolean} skipCallback whether to call onSetTrackSelection\r\n     * @param {Boolean} updateTrackTree whether track tree panel needs a refresh\r\n     * @returns\r\n     */\r\n    setTrackSelection( trackIdx: number, isSelected: boolean, skipCallback: boolean = false, updateTrackTree: boolean = true )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n        const oldValue = track.isSelected;\r\n        track.isSelected = isSelected;\r\n\r\n        const idx = this.selectedTracks.indexOf( track );\r\n        if ( ( idx == -1 && !isSelected ) || ( idx > -1 && isSelected ) )\r\n        {\r\n            return;\r\n        }\r\n\r\n        if ( idx == -1 )\r\n        {\r\n            this.selectedTracks.push( track );\r\n        }\r\n        else\r\n        {\r\n            this.selectedTracks.splice( idx, 1 );\r\n        }\r\n\r\n        if ( this.onSetTrackSelection && !skipCallback )\r\n        {\r\n            this.onSetTrackSelection( track, oldValue );\r\n        }\r\n\r\n        if ( updateTrackTree )\r\n        {\r\n            this._updateTrackTreeSelection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * updates trackTreesComponent's nodes, to match the selectedTracks\r\n     */\r\n    _updateTrackTreeSelection()\r\n    {\r\n        const data = this.trackTreesComponent.innerTree.data;\r\n        const selected = this.trackTreesComponent.innerTree.selected;\r\n        selected.length = 0;\r\n\r\n        const addToSelection = ( nodes: any[] ) => {\r\n            for ( let i = 0; i < nodes.length; ++i )\r\n            {\r\n                if ( nodes[i].trackData && nodes[i].trackData.isSelected )\r\n                {\r\n                    selected.push( nodes[i] );\r\n                }\r\n\r\n                if ( nodes[i].children )\r\n                {\r\n                    addToSelection( nodes[i].children );\r\n                }\r\n            }\r\n        };\r\n\r\n        // update innerTree ( visible ) selected nodes\r\n        if ( this.selectedTracks.length )\r\n        {\r\n            addToSelection( data );\r\n        }\r\n\r\n        this.trackTreesComponent.innerTree.refresh();\r\n    }\r\n\r\n    deselectAllElements()\r\n    {\r\n    }\r\n\r\n    /**\r\n     * @method setTrackState\r\n     * @param {Int} trackIdx\r\n     * @param {Boolean} isEnbaled\r\n     * @param {Boolean} skipCallback onSetTrackState\r\n     * @param {Boolean} updateTrackTree updates eye icon of the track, if it is visible in the timeline\r\n     */\r\n    setTrackState( trackIdx: number, isEnbaled: boolean = true, skipCallback: boolean = false, updateTrackTree: boolean = true )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n        const oldState = track.active;\r\n        track.active = isEnbaled;\r\n\r\n        if ( this.onSetTrackState && !skipCallback )\r\n        {\r\n            this.onSetTrackState( track, oldState );\r\n        }\r\n\r\n        if ( updateTrackTree && !this.skipVisibility )\r\n        {\r\n            // TODO: a bit of an overkill. Maybe searching the node in the tree is less expensive\r\n            this.updateLeftPanel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Int} trackIdx\r\n     * @param {Boolean} isLocked\r\n     * @param {Boolean} skipCallback onSetTrackLock\r\n     * @param {Boolean} updateTrackTree updates lock icon of the track, if it is visible in the timeline\r\n     */\r\n    setTrackLock( trackIdx: number, isLocked: boolean = false, skipCallback: boolean = false, updateTrackTree: boolean = true )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n\r\n        const oldState = track.locked;\r\n        track.locked = isLocked;\r\n\r\n        if ( this.onSetTrackLock && !skipCallback )\r\n        {\r\n            this.onSetTrackLock( track, oldState );\r\n        }\r\n\r\n        if ( updateTrackTree && !this.skipLock )\r\n        {\r\n            // TODO: a bit of an overkill. Maybe searching the node in the tree is less expensive\r\n            this.updateLeftPanel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Int} trackIdx index of track in the animation ( not local index )\r\n     * @param {Boolean} combineWithPrevious whether to create a new entry or unify changes into a single undo entry\r\n     */\r\n    saveState( trackIdx: number, combineWithPrevious: boolean = false )\r\n    {\r\n        if ( !this.historySaveEnabler ) return;\r\n\r\n        const undoStep = this.historyGenerateTrackStep( trackIdx );\r\n        undoStep.trackIdx = trackIdx;\r\n\r\n        if ( combineWithPrevious && this.historyUndo.length )\r\n        {\r\n            this.historyUndo[this.historyUndo.length - 1].push( undoStep );\r\n        }\r\n        else\r\n        {\r\n            this.historyUndo.push( [ undoStep ] );\r\n        }\r\n\r\n        if ( this.historyUndo.length > this.historyMaxSteps ) this.historyUndo.shift(); // remove first ( oldest ) element\r\n        this.historyRedo = [];\r\n    }\r\n\r\n    #undoRedo( isUndo = true )\r\n    {\r\n        let toBeShown = isUndo ? this.historyUndo : this.historyRedo;\r\n        let toBeStored = isUndo ? this.historyRedo : this.historyUndo;\r\n\r\n        if ( !toBeShown.length ) return false;\r\n\r\n        this.deselectAllElements();\r\n\r\n        const combinedState = toBeShown.pop();\r\n        const combinedStateToStore: any = [];\r\n\r\n        for ( let i = 0; i < combinedState.length; ++i )\r\n        {\r\n            const state = combinedState[i];\r\n            const trackIdx = state.trackIdx;\r\n\r\n            const stateToStore: any = this.historyApplyTrackStep( state, isUndo );\r\n            stateToStore.trackIdx = trackIdx;\r\n            combinedStateToStore.push( stateToStore );\r\n\r\n            // Update animation action interpolation info\r\n            if ( this.onUpdateTrack )\r\n            {\r\n                this.onUpdateTrack( [ state.trackIdx ] );\r\n            }\r\n        }\r\n\r\n        toBeStored.push( combinedStateToStore );\r\n\r\n        return true;\r\n    }\r\n\r\n    undo()\r\n    {\r\n        return this.#undoRedo( true );\r\n    }\r\n    redo()\r\n    {\r\n        return this.#undoRedo( false );\r\n    }\r\n    // historyApplyTrackStep( state, isUndo ) MUST BE IMPLEMENTED BY CHILD CLASS\r\n    // historyGenerateTrackStep( trackIdx ) MUST BE IMPLEMENTED BY CHILD CLASS\r\n\r\n    /**\r\n     * @method resize\r\n     * @param {*} size\r\n     */\r\n    resize( size: Nullable<[ number, number ]> = null )\r\n    {\r\n        if ( size )\r\n        {\r\n            this.size[0] = size[0];\r\n            this.size[1] = size[1];\r\n        }\r\n        else if ( this.root.parentElement )\r\n        {\r\n            this.size[0] = this.root.parentElement.clientWidth;\r\n            this.size[1] = this.root.parentElement.clientHeight;\r\n        }\r\n\r\n        // this.content_area.setSize([ size[ 0 ], size[ 1 ] - this.header_offset] );\r\n        this.mainArea.sections[1].root.style.height = 'calc(100% - ' + this.header_offset + 'px )';\r\n\r\n        let w = this.size[0] - this.leftPanel.root.clientWidth - 8;\r\n        this.mainArea.sections[1]._update(); // update area's this.size attribute\r\n\r\n        this.resizeCanvas();\r\n    }\r\n\r\n    resizeCanvas()\r\n    {\r\n        this.canvas.width = this.canvasArea.root.clientWidth;\r\n        this.canvas.height = this.canvasArea.root.clientHeight;\r\n    }\r\n\r\n    /**\r\n     * @method hide\r\n     * Hide timeline area\r\n     */\r\n    hide()\r\n    {\r\n        this.mainArea.hide();\r\n    }\r\n\r\n    /**\r\n     * @method show\r\n     * Show timeline area if it is hidden\r\n     */\r\n    show()\r\n    {\r\n        this.mainArea.show();\r\n        this.resize();\r\n        this.updateLeftPanel();\r\n    }\r\n\r\n    // ----- BASE FUNCTIONS -----\r\n    /**\r\n        These functions might be overriden by child classes. Nonetheless, they must have the same attributes, at least.\r\n        Usually call a super.whateverFunction to generate its base form, and expand it with extra attributes\r\n    */\r\n\r\n    /**\r\n     * This functions uses the selectedItems and generates the data that will feed the LX.Tree Component.\r\n     * This function is used by updateLeftPanel. Some timelines might allow grouping of tracks. Such timelines may override this function\r\n     * WARNING: track entries MUST have an attribute of 'trackData' with the track info\r\n     * @returns lexgui tree data as expected for the creation of a LX.Tree\r\n     */\r\n    generateSelectedItemsTreeData(): any\r\n    {\r\n        const treeTracks: any[] = [];\r\n\r\n        for ( let i = 0; i < this.selectedItems.length; i++ )\r\n        {\r\n            const track = this.selectedItems[i];\r\n            treeTracks.push( { trackData: track, id: track.id, skipVisibility: this.skipVisibility, visible: track.active, children: [],\r\n                actions: this.skipLock ? null : [ {\r\n                    'name': 'Lock edition',\r\n                    'icon': ( track.locked ? 'TimelineLock' : 'TimelineLockOpen' ),\r\n                    'swap': ( track.locked ? 'TimelineLockOpen' : 'TimelineLock' ),\r\n                    'callback': ( node: any, swapValue: boolean, event: Event ) => {\r\n                        this.setTrackLock( node.trackData.trackIdx, !node.trackData.locked, false, false ); // do not update left panel\r\n                    }\r\n                } ] } );\r\n        }\r\n\r\n        return treeTracks;\r\n    }\r\n\r\n    /**\r\n     * @param {Object} options set some values for the track instance ( groups and trackIdx not included )\r\n     * @returns\r\n     */\r\n    instantiateTrack( options: any = {}, clone: boolean = false )\r\n    {\r\n        return {\r\n            isTrack: true,\r\n            id: options.id ?? ( Math.floor( performance.now() ) + '_' + Math.floor( Math.random() * 0xffff ) ), // must be unique, at least inside a group\r\n            active: options.active ?? true,\r\n            locked: options.locked ?? false,\r\n            isSelected: false, // render and lexgui tree\r\n            trackIdx: -1,\r\n            data: options.data ?? null // user defined data\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates an animationClip using either the parameters set in the animation argument or using default values\r\n     * @param {Object} options data with which to generate an animationClip\r\n     * @param {Boolean} clone whether to clone clips or make a shallow copy\r\n     * @returns\r\n     */\r\n    instantiateAnimationClip( options: any = {}, clone: boolean = false )\r\n    {\r\n        const animationClip: any = {\r\n            id: options.id ?? ( options.name ?? 'animationClip' ),\r\n            duration: options.duration ?? 0,\r\n            tracks: [],\r\n            data: options.data ?? null // user defined data\r\n        };\r\n\r\n        return animationClip;\r\n    }\r\n    // ----- END OF BASE FUNCTIONS -----\r\n}\r\n\r\nTimeline.BACKGROUND_COLOR = LX.getCSSVariable( 'background-blur' );\r\nTimeline.TRACK_COLOR_PRIMARY = LX.getCSSVariable( 'card' );\r\nTimeline.TRACK_COLOR_SECONDARY = LX.getCSSVariable( 'secondary' );\r\nTimeline.TRACK_COLOR_TERTIARY = LX.getCSSVariable( 'accent' );\r\nTimeline.TRACK_SELECTED = LX.getCSSVariable( 'primary' );\r\nTimeline.FONT = LX.getCSSVariable( 'global-font' );\r\nTimeline.FONT_COLOR_PRIMARY = LX.getCSSVariable( 'foreground' );\r\nTimeline.FONT_COLOR_TERTIARY = LX.getCSSVariable( 'primary' );\r\nTimeline.FONT_COLOR_QUATERNARY = LX.getCSSVariable( 'muted-foreground' );\r\nTimeline.TIME_MARKER_COLOR = LX.getCSSVariable( 'primary' );\r\nTimeline.TIME_MARKER_COLOR_TEXT = LX.getCSSVariable( 'primary-foreground' );\r\n\r\nLX.setCSSVariable( 'lxTimeline-keyframe', 'light-dark(#2d69da,#2d69da )' );\r\nLX.setCSSVariable( 'lxTimeline-keyframe-selected', 'light-dark(#f5c700,#fafa14)' );\r\nLX.setCSSVariable( 'lxTimeline-keyframe-hovered', 'light-dark(#f5c700,#fafa14)' );\r\nLX.setCSSVariable( 'lxTimeline-keyframe-locked', 'light-dark(#c62e2e,#ff7d7d )' );\r\nLX.setCSSVariable( 'lxTimeline-keyframe-edited', 'light-dark(#00d000,#00d000 )' );\r\nLX.setCSSVariable( 'lxTimeline-keyframe-inactive', 'light-dark(#706b6b,#706b6b)' );\r\n\r\nTimeline.KEYFRAME_COLOR = LX.getCSSVariable( 'lxTimeline-keyframe' );\r\nTimeline.KEYFRAME_COLOR_SELECTED = Timeline.KEYFRAME_COLOR_HOVERED = LX.getCSSVariable( 'lxTimeline-keyframe-selected' );\r\nTimeline.KEYFRAME_COLOR_LOCK = LX.getCSSVariable( 'lxTimeline-keyframe-locked' );\r\nTimeline.KEYFRAME_COLOR_EDITED = LX.getCSSVariable( 'lxTimeline-keyframe-edited' );\r\nTimeline.KEYFRAME_COLOR_INACTIVE = LX.getCSSVariable( 'lxTimeline-keyframe-inactive' );\r\nTimeline.BOX_SELECTION_COLOR = '#AAA';\r\n\r\nLX.Timeline = Timeline;\r\n\r\n/**\r\n * @class KeyFramesTimeline\r\n */\r\n\r\nexport class KeyFramesTimeline extends Timeline\r\n{\r\n    static ADDKEY_VALUESINARRAYS = 0x01; // addkeyframes as [ [ k0v0, k0v1...], [ k1v0, k1v1...] ] instead of [ k0v0,k0v1,k1v0,k1v1 ]\r\n\r\n    lastKeyFramesSelected: any[];\r\n    keyValuePerPixel: number;\r\n    defaultCurves: boolean;\r\n    defaultCurvesRange: [ number, number ];\r\n\r\n    keyframeSize: number;\r\n    keyframeSizeHovered: number;\r\n\r\n    lastHovered: Nullable<[ number, number ]> = null;\r\n    moveKeyMinTime: number = 0;\r\n\r\n    onContentMoved: Nullable<( trackIdx: number, keyIdx: number ) => void> = null;\r\n    onOptimizeTracks: Nullable<( trackIdx: number ) => void> = null;\r\n    onDeleteKeyFrames: Nullable<( trackIdx: number, indices: number[] ) => void> = null;\r\n    onSelectKeyFrame: Nullable<( selection: [ number, number, number ][] ) => void> = null;\r\n    onDeselectKeyFrames: Nullable<( lastSelected: any[] ) => void> = null;\r\n\r\n    /**\r\n     * @param {String} name unique string\r\n     * @param {Object} options = {animationClip, selectedItems, x, y, width, height, canvas, trackHeight}\r\n     */\r\n    constructor( name: string, options: any = {} )\r\n    {\r\n        super( name, options );\r\n\r\n        this.lastKeyFramesSelected = [];\r\n\r\n        // curves --- track.dim == 1\r\n        this.keyValuePerPixel = 1 / this.trackHeight; // used onMouseMove, vertical move only for dim==1. Normalized value movement / pixels\r\n        this.defaultCurves = true; // whn a track with dim == 1 has no curves attribute, defaultCurves will be used instead. If true, track is rendered using curves\r\n        this.defaultCurvesRange = [ 0, 1 ]; // whn a track with dim == 1 has no curves attribute, defaultCurves will be used instead. If true, track is rendered using curves\r\n\r\n        this.keyframeSize = this.trackHeight * 0.5; // height of keyframe\r\n        this.keyframeSizeHovered = this.trackHeight * 0.5 + 5;\r\n\r\n        if ( options.onShowOptimizeMenu && typeof options.onShowOptimizeMenu == 'boolean' )\r\n        {\r\n            this.onShowOptimizeMenu = ( e: any ): void => {\r\n                if ( this.selectedItems.length == 0 )\r\n                {\r\n                    return;\r\n                }\r\n\r\n                LX.addContextMenu( 'Optimize', e, ( m: any ) => {\r\n                    this.selectedItems.forEach( ( item ) => {\r\n                        if ( item.isTrack )\r\n                        {\r\n                            m.add( ( item.groupId ? item.groupId : '' ) + '@' + item.id, () => {\r\n                                this.optimizeTrack( item.trackIdx, false );\r\n                            } );\r\n                        }\r\n                        else\r\n                        {\r\n                            const tracks = this.animationClip.tracksPerGroup[item];\r\n                            for ( let i = 0; i < tracks.length; ++i )\r\n                            {\r\n                                const t = tracks[i];\r\n                                m.add( ( t.groupId ? t.groupId : '' ) + '@' + t.id, () => {\r\n                                    this.optimizeTrack( t.trackIdx, false );\r\n                                } );\r\n                            }\r\n                        }\r\n                    } );\r\n                } );\r\n            };\r\n        }\r\n\r\n        this.onShowContextMenu = ( e: any ) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n\r\n            let actions: any = [];\r\n            if ( this.lastKeyFramesSelected && this.lastKeyFramesSelected.length )\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: 'Copy',\r\n                        callback: () => {\r\n                            this.copySelectedContent();\r\n                        }\r\n                    }\r\n                );\r\n                actions.push(\r\n                    {\r\n                        title: 'Delete',\r\n                        callback: () => {\r\n                            this.deleteSelectedContent();\r\n                        }\r\n                    }\r\n                );\r\n\r\n                if ( this.lastKeyFramesSelected.length == 1 && this.clipboard && this.clipboard.value )\r\n                {\r\n                    actions.push(\r\n                        {\r\n                            title: 'Paste Value',\r\n                            callback: () => {\r\n                                this.pasteContentValue();\r\n                            }\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: 'Add Here',\r\n                        callback: () => {\r\n                            if ( !e.track ) return;\r\n                            const values: any = new Float32Array( e.track.dim );\r\n                            values.fill( 0 );\r\n                            this.addKeyFrames( e.track.trackIdx, values, [ this.xToTime( e.localX ) ] );\r\n                        }\r\n                    }\r\n                );\r\n                actions.push(\r\n                    {\r\n                        title: 'Add',\r\n                        callback: () => {\r\n                            if ( !e.track ) return;\r\n                            const values: any = new Float32Array( e.track.dim );\r\n                            values.fill( 0 );\r\n                            this.addKeyFrames( e.track.trackIdx, values, [ this.currentTime ] );\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n\r\n            if ( this.clipboard && this.clipboard.keyframes )\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: 'Paste Here',\r\n                        callback: () => {\r\n                            this.pasteContent( this.xToTime( e.localX ) );\r\n                        }\r\n                    }\r\n                );\r\n                actions.push(\r\n                    {\r\n                        title: 'Paste',\r\n                        callback: () => {\r\n                            this.pasteContent( this.currentTime );\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n\r\n            LX.addContextMenu( 'Options', e, ( m: any ) => {\r\n                for ( let i = 0; i < actions.length; i++ )\r\n                {\r\n                    m.add( actions[i].title, actions[i].callback );\r\n                }\r\n            } );\r\n        }; // end of onShowContextMenu\r\n\r\n        if ( this.animationClip )\r\n        {\r\n            this.setAnimationClip( this.animationClip );\r\n        }\r\n    }\r\n\r\n    // OVERRIDE\r\n    generateSelectedItemsTreeData(): any\r\n    {\r\n        const treeTracks: any[] = [];\r\n        const tracksPerGroup = this.animationClip.tracksPerGroup;\r\n\r\n        for ( let i = 0; i < this.selectedItems.length; i++ )\r\n        {\r\n            const item = this.selectedItems[i];\r\n            const isGroup = !item.isTrack;\r\n            const itemTracks = isGroup ? tracksPerGroup[item] : [ item ];\r\n            const nodes: any[] = [];\r\n\r\n            for ( let j = 0; j < itemTracks.length; j++ )\r\n            {\r\n                const track = itemTracks[j];\r\n                nodes.push( { 'trackData': track, 'id': track.id, 'skipVisibility': this.skipVisibility, visible: track.active, 'children': [],\r\n                    actions: this.skipLock ? null : [ {\r\n                        'name': 'Lock edition',\r\n                        'icon': ( track.locked ? 'TimelineLock' : 'TimelineLockOpen' ),\r\n                        'swap': ( track.locked ? 'TimelineLockOpen' : 'TimelineLock' ),\r\n                        'callback': ( node: any, swapValue: boolean, event: Event ) => {\r\n                            this.setTrackLock( node.trackData.trackIdx, !node.trackData.locked, false, false ); // do not update left panel\r\n                        }\r\n                    } ] } );\r\n            }\r\n\r\n            if ( isGroup )\r\n            {\r\n                const t = {\r\n                    'id': item,\r\n                    'skipVisibility': true,\r\n                    'children': nodes\r\n                };\r\n\r\n                treeTracks.push( t );\r\n            }\r\n            else\r\n            {\r\n                treeTracks.push( nodes[0] );\r\n            }\r\n        }\r\n\r\n        return treeTracks;\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE\r\n     * @param {Object} options track information that wants to be set to the new track\r\n     *  id, dim, values, times, selected, edited, hovered\r\n     * @returns\r\n     */\r\n    instantiateTrack( options: any = {}, clone: boolean = false )\r\n    {\r\n        const track: any = super.instantiateTrack( options );\r\n        track.dim = Math.max( 1, options.dim ?? 1 ); // >= 1\r\n        track.groupId = null, track.groupTrackIdx = -1, // track Idx inside group only if in group\r\n            track.values = new Float32Array( 0 );\r\n        track.times = new Float32Array( 0 );\r\n        track.selected = [];\r\n        track.edited = [];\r\n        track.hovered = [];\r\n\r\n        if ( options.values && options.times )\r\n        {\r\n            track.values = clone ? options.values.slice() : options.values;\r\n            track.times = clone ? options.times.slice() : options.times;\r\n\r\n            const numFrames = track.times.length;\r\n            if ( options.selected && options.selected.length == numFrames )\r\n            {\r\n                track.selected = clone ? options.selected.slice() : options.selected;\r\n            }\r\n            else\r\n            {\r\n                track.selected = ( new Array( numFrames ) ).fill( false );\r\n            }\r\n\r\n            if ( options.edited && options.edited.length == numFrames )\r\n            {\r\n                track.edited = clone ? options.edited.slice() : options.edited;\r\n            }\r\n            else\r\n            {\r\n                track.edited = ( new Array( numFrames ) ).fill( false );\r\n            }\r\n\r\n            if ( options.hovered && options.hovered.length == numFrames )\r\n            {\r\n                track.hovered = clone ? options.hovered.slice() : options.hovered;\r\n            }\r\n            else\r\n            {\r\n                track.hovered = ( new Array( numFrames ) ).fill( false );\r\n            }\r\n        }\r\n\r\n        track.curves = options.curves ?? this.defaultCurves; // only works if dim == 1\r\n        track.curvesRange = ( options.curvesRange ?? this.defaultCurvesRange ).slice();\r\n\r\n        return track;\r\n    }\r\n\r\n    /**\r\n     * Generates an animationClip using either the parameters set in the animation argument or using default values\r\n     * @param {Object} animation data with which to generate an animationClip\r\n     * @returns\r\n     */\r\n    instantiateAnimationClip( animation: Nullable<any>, clone: boolean = false )\r\n    {\r\n        const animationClip: any = super.instantiateAnimationClip( animation, clone );\r\n\r\n        animationClip.tracksPerGroup = {};\r\n\r\n        if ( animation && animation.tracks )\r\n        {\r\n            const tracksPerGroup: any = {};\r\n            let duration = 0;\r\n            for ( let i = 0; i < animation.tracks.length; ++i )\r\n            {\r\n                let track = animation.tracks[i];\r\n                let times = track.times ?? [];\r\n                let values = track.values ?? [];\r\n\r\n                let valueDim = track.dim;\r\n                if ( !valueDim || valueDim < 0 )\r\n                {\r\n                    if ( times.length && values.length ) valueDim = Math.round( values.length / times.length );\r\n                    else\r\n                    {\r\n                        valueDim = 1;\r\n                    }\r\n                }\r\n\r\n                let baseName = track.id ?? track.name;\r\n                const [ groupId, trackId ] = baseName ? this._getValidTrackName( baseName ) : [ null, null ];\r\n\r\n                const toInstantiate = Object.assign( {}, track );\r\n                toInstantiate.id = trackId;\r\n                toInstantiate.dim = valueDim;\r\n                const trackInfo = this.instantiateTrack( toInstantiate, clone );\r\n\r\n                // manual group insertion\r\n                if ( groupId )\r\n                {\r\n                    if ( !tracksPerGroup[groupId] )\r\n                    {\r\n                        tracksPerGroup[groupId] = [ trackInfo ];\r\n                    }\r\n                    else\r\n                    {\r\n                        tracksPerGroup[groupId].push( trackInfo );\r\n                    }\r\n\r\n                    trackInfo.groupId = groupId;\r\n                    trackInfo.groupTrackIdx = tracksPerGroup[groupId].length - 1; // index of track in group\r\n                }\r\n\r\n                trackInfo.trackIdx = i; // index of track in the entire animation\r\n\r\n                animationClip.tracks.push( trackInfo );\r\n\r\n                if ( trackInfo.times.length )\r\n                {\r\n                    duration = Math.max( duration, trackInfo.times[trackInfo.times.length - 1] );\r\n                }\r\n            }\r\n\r\n            animationClip.tracksPerGroup = tracksPerGroup;\r\n            if ( !animation || !animation.duration )\r\n            {\r\n                animationClip.duration = duration;\r\n            }\r\n\r\n            // overwrite trackspergroup\r\n            if ( animation.tracksPerGroup )\r\n            {\r\n                // ungroup all tracks (just in case )\r\n                animationClip.tracks.forEach( ( v: any, i: number ) => {\r\n                    v.groupId = null;\r\n                    v.groupTrackIdx = -1;\r\n                } );\r\n\r\n                animationClip.tracksPerGroup = {};\r\n                let tpg = animation.tracksPerGroup;\r\n                for ( let groupId in tpg )\r\n                {\r\n                    const source = tpg[groupId];\r\n                    const target: any[] = [];\r\n                    for ( let ti = 0; ti < source.length; ++ti )\r\n                    {\r\n                        const trackInfo = animationClip.tracks[source[ti].trackIdx]; // redo references\r\n                        target[ti] = trackInfo;\r\n                        trackInfo.groupId = groupId;\r\n                        trackInfo.groupTrackIdx = ti; // index of track in group\r\n                    }\r\n                    animationClip.tracksPerGroup[groupId] = target;\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationClip;\r\n    }\r\n\r\n    // OVERRIDE\r\n    deselectAllElements()\r\n    {\r\n        this.deselectAllKeyFrames();\r\n        this.unHoverAll();\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE\r\n     * @param {Array} itemsToAdd [ trackIdx, \"groupId\" ], array of strings and/or number identifying groups and/or tracks\r\n     * @param {Array} itemsToRemove [ trackIdx, \"groupId\" ], array of strings and/or number identifying groups and/or tracks\r\n     */\r\n    changeSelectedItems( itemsToAdd: Nullable<any[]> = null, itemsToRemove: Nullable<any[]> = null, skipCallback: boolean = false )\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left panel. It is going to be rebuilt anyways\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        const tracksPerGroup = this.animationClip.tracksPerGroup;\r\n\r\n        if ( itemsToRemove )\r\n        {\r\n            for ( let i = 0; i < itemsToRemove.length; ++i )\r\n            {\r\n                const isGroup: boolean = !!itemsToRemove[i].substr;\r\n                let compareObj = isGroup ? itemsToRemove[i] : tracks[itemsToRemove[i]]; // trackData or groupId\r\n                for ( let s = 0; s < this.selectedItems.length; ++s )\r\n                {\r\n                    if ( this.selectedItems[s] === compareObj )\r\n                    {\r\n                        const size = isGroup ? tracksPerGroup[compareObj].length : 1;\r\n                        this.selectedItems.splice( s, size );\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if ( itemsToAdd )\r\n        {\r\n            for ( let i = 0; i < itemsToAdd.length; ++i )\r\n            {\r\n                const v = itemsToAdd[i];\r\n                if ( isNaN( v ) )\r\n                { // assuming it is a string\r\n                    if ( tracksPerGroup[v] )\r\n                    {\r\n                        this.selectedItems.push( v );\r\n                    }\r\n                }\r\n                else if ( tracks[v] )\r\n                {\r\n                    this.selectedItems.push( tracks[v] );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateLeftPanel();\r\n\r\n        if ( this.onItemSelected && !skipCallback )\r\n        {\r\n            this.onItemSelected( this.selectedItems, itemsToAdd, itemsToRemove );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {String} groupId unique identifier\r\n     * @param {Array} groupTracks [ \"trackID\", trackIdx ] array of strings and/or numbers of the existing tracks to include in this group. A track can only be part of 1 group\r\n     *  if groupTracks == null, groupId is removed from the list\r\n     */\r\n    setTracksGroup( groupId: string, groupTracks: Nullable<(string | number)[]> = null )\r\n    {\r\n        const tracks = this.animationClip.tracks;\r\n        const tracksPerGroup = this.animationClip.tracksPerGroup;\r\n        const result: any = [];\r\n\r\n        let selectedItemsCounter = -1;\r\n\r\n        if ( tracksPerGroup[groupId] )\r\n        {\r\n            // if group exists, ungroup tracks.\r\n            tracksPerGroup[groupId].forEach( ( t: any ) => {\r\n                t.groupId = null;\r\n                t.groupTrackIdx = -1;\r\n            } );\r\n\r\n            // modify groups cannot appear more than once\r\n            for ( let i = 0; i < this.selectedItems.length; ++i )\r\n            {\r\n                if ( this.selectedItems[i] === groupId )\r\n                {\r\n                    selectedItemsCounter = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ( !groupTracks )\r\n        {\r\n            delete tracksPerGroup.groupId;\r\n            // remove entry from selectedItems\r\n            if ( selectedItemsCounter > -1 )\r\n            {\r\n                this.selectedItems.splice( selectedItemsCounter, 1 );\r\n            }\r\n            return;\r\n        }\r\n\r\n        // find tracks and group them\r\n        for ( let i = 0; i < groupTracks.length; ++i )\r\n        {\r\n            const v = groupTracks[i];\r\n            let track: any = null;\r\n            if ( typeof v == 'string' )\r\n            {\r\n                // v is an id  ( string)\r\n                for ( let t = 0; t < tracks.length; ++t )\r\n                {\r\n                    if ( tracks[t].id == v )\r\n                    {\r\n                        track = tracks[t];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else if ( tracks[v] )\r\n            {\r\n                track = tracks[v];\r\n            }\r\n\r\n            if ( track )\r\n            {\r\n                track.groupId = groupId;\r\n                track.groupTrackIdx = result.length;\r\n                result.push( track );\r\n            }\r\n        }\r\n\r\n        tracksPerGroup[groupId] = result;\r\n\r\n        // if group is currently visible\r\n        if ( selectedItemsCounter > -1 )\r\n        {\r\n            this.updateLeftPanel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {String} groupId\r\n     * @returns array of tracks or null\r\n     */\r\n    getTracksGroup( groupId: string ): any[] | null\r\n    {\r\n        return this.animationClip.tracksPerGroup[groupId] ?? null;\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE\r\n     * @param {String} trackId\r\n     * @param {String} groupId optionl. If not set, it will find the first occurrence of trackId in animationClip.tracks\r\n     * @returns\r\n     */\r\n    getTrack( trackId: string, groupId: Nullable<string> = null )\r\n    {\r\n        let tracks = this.animationClip.tracks;\r\n        if ( groupId )\r\n        {\r\n            tracks = this.animationClip.tracksPerGroup[groupId] ?? [];\r\n        }\r\n\r\n        for ( let i = 0; i < tracks.length; ++i )\r\n        {\r\n            if ( tracks[i].id == trackId )\r\n            {\r\n                return tracks[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @param {Number} size pixels, height of keyframe\r\n     * @param {Number} sizeHovered optional, size in pixels when hovered\r\n     */\r\n    setKeyframeSize( size: number, sizeHovered: Nullable<number> = null )\r\n    {\r\n        this.keyframeSizeHovered = sizeHovered ?? size;\r\n        this.keyframeSize = size;\r\n    }\r\n\r\n    onMouseUp( e: any, time: number )\r\n    {\r\n        let track = e.track;\r\n        let localX = e.localX;\r\n        let discard = e.discard; // true when too much time has passed between Down and Up\r\n\r\n        if ( e.shiftKey )\r\n        {\r\n            // Manual multiple selection\r\n            if ( !discard && track )\r\n            {\r\n                const thresholdPixels = this.keyframeSize * 0.5; // radius of circle ( curves ) or rotated square (keyframes )\r\n                const keyFrameIdx = this.getCurrentKeyFrame( track, this.xToTime( localX ), this.secondsPerPixel * thresholdPixels );\r\n                if ( keyFrameIdx > -1 )\r\n                {\r\n                    track.selected[keyFrameIdx]\r\n                        ? this.deselectKeyFrame( track.trackIdx, keyFrameIdx )\r\n                        : this.processSelectionKeyFrame( track.trackIdx, keyFrameIdx, true );\r\n                }\r\n            }\r\n            // Box selection\r\n            else if ( this.boxSelection )\r\n            {\r\n                let tracks = this.getTracksInRange( this.boxSelectionStart[1], this.boxSelectionEnd[1] );\r\n\r\n                for ( let t of tracks )\r\n                {\r\n                    let keyFrameIndices = this.getKeyFramesInRange( t, this.xToTime( this.boxSelectionStart[0] ),\r\n                        this.xToTime( this.boxSelectionEnd[0] ), this.secondsPerPixel * 5 );\r\n\r\n                    if ( keyFrameIndices )\r\n                    {\r\n                        for ( let index = keyFrameIndices[0]; index <= keyFrameIndices[1]; ++index )\r\n                        {\r\n                            this.processSelectionKeyFrame( t.trackIdx, index, true );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if ( !this.movingKeys && !discard )\r\n        { // if not moving timeline and not adding keyframes through e.shiftkey (just a click )\r\n            if ( this.lastKeyFramesSelected.length )\r\n            {\r\n                if ( this.onDeselectKeyFrames )\r\n                {\r\n                    this.onDeselectKeyFrames( this.lastKeyFramesSelected );\r\n                }\r\n\r\n                this.deselectAllKeyFrames();\r\n            }\r\n\r\n            if ( track )\r\n            {\r\n                const thresholdPixels = this.keyframeSize * 0.5; // radius of circle ( curves ) or rotated square (keyframes )\r\n                const keyFrameIndex = this.getCurrentKeyFrame( track, this.xToTime( localX ), this.secondsPerPixel * thresholdPixels );\r\n                if ( keyFrameIndex > -1 )\r\n                {\r\n                    this.processSelectionKeyFrame( track.trackIdx, keyFrameIndex, false ); // Settings this as multiple so time is not being set\r\n                }\r\n            }\r\n        }\r\n\r\n        this.canvas.classList.remove( 'grabbing' );\r\n    }\r\n\r\n    onMouseDown( e: any, time: number )\r\n    {\r\n        // function not called if shift is pressed (boxselection )\r\n\r\n        let localX = e.localX;\r\n        let localY = e.localY;\r\n        let track = e.track;\r\n\r\n        if ( ( e.ctrlKey || e.altKey ) && this.lastKeyFramesSelected.length )\r\n        { // move keyframes\r\n            this.movingKeys = true;\r\n            this.canvas.style.cursor = 'grab';\r\n            this.canvas.classList.add( 'grabbing' );\r\n\r\n            // Set pre-move state\r\n            this.moveKeyMinTime = Infinity;\r\n            const tracks = this.animationClip.tracks;\r\n            let lastTrackIdx = -1;\r\n            for ( let selectedKey of this.lastKeyFramesSelected )\r\n            { // WARNING assumes lasKeyFramesSelected is sorted, so all keyframes of the same track are grouped\r\n                let [ trackIdx, keyIndex, keyTime ] = selectedKey;\r\n                const track = tracks[trackIdx];\r\n\r\n                selectedKey[2] = track.times[keyIndex]; // update original time just in case\r\n\r\n                if ( lastTrackIdx != trackIdx )\r\n                {\r\n                    // save track states only once\r\n                    if ( this.moveKeyMinTime < Infinity )\r\n                    {\r\n                        this.saveState( track.trackIdx, true );\r\n                    }\r\n                    else\r\n                    {\r\n                        this.saveState( track.trackIdx, false );\r\n                    }\r\n\r\n                    this.moveKeyMinTime = Math.min( this.moveKeyMinTime, selectedKey[2] );\r\n                    lastTrackIdx = trackIdx;\r\n                }\r\n            }\r\n\r\n            this.timeBeforeMove = this.xToTime( localX );\r\n\r\n            this.grabbing = false;\r\n            this.grabbingTimeBar = false;\r\n        }\r\n    }\r\n\r\n    onMouseMove( e: any, time: number )\r\n    {\r\n        // function not called if shift is pressed (boxselection )\r\n\r\n        let localX = e.localX;\r\n        let localY = e.localY;\r\n        let track = e.track;\r\n\r\n        if ( this.movingKeys )\r\n        { // move keyframes\r\n            let newTime = this.xToTime( localX );\r\n            let deltaTime = newTime - this.timeBeforeMove;\r\n\r\n            if ( deltaTime + this.moveKeyMinTime < 0 )\r\n            {\r\n                deltaTime = -this.moveKeyMinTime;\r\n            }\r\n\r\n            this.timeBeforeMove = this.timeBeforeMove + deltaTime;\r\n\r\n            if ( e.ctrlKey )\r\n            {\r\n                this.moveKeyMinTime += deltaTime;\r\n                const tracks = this.animationClip.tracks;\r\n                for ( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n                {\r\n                    let idx = i;\r\n                    if ( deltaTime > 0 )\r\n                    {\r\n                        idx = this.lastKeyFramesSelected.length - 1 - i;\r\n                    }\r\n\r\n                    const [ trackIdx, keyIndex, originalKeyTime ] = this.lastKeyFramesSelected[idx];\r\n                    track = tracks[trackIdx];\r\n\r\n                    if ( track && track.locked )\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    this.canvas.style.cursor = 'grabbing';\r\n\r\n                    const times = this.animationClip.tracks[track.trackIdx].times;\r\n                    times[keyIndex] = Math.max( 0, times[keyIndex] + deltaTime );\r\n\r\n                    if ( times[keyIndex] > this.duration )\r\n                    {\r\n                        this.setDuration( times[keyIndex] );\r\n                    }\r\n\r\n                    // sort keyframe\r\n                    let k = keyIndex;\r\n                    if ( deltaTime > 0 )\r\n                    {\r\n                        for ( ; k < times.length - 1; ++k )\r\n                        {\r\n                            if ( times[k] < times[k + 1] )\r\n                            {\r\n                                break;\r\n                            }\r\n\r\n                            this.swapKeyFrames( track, k + 1, k );\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        for ( ; k > 0; --k )\r\n                        {\r\n                            if ( times[k - 1] < times[k] )\r\n                            {\r\n                                break;\r\n                            }\r\n                            this.swapKeyFrames( track, k - 1, k );\r\n                        }\r\n                    }\r\n                    this.lastKeyFramesSelected[idx][1] = k; // update keyframe index\r\n                    this.lastKeyFramesSelected[idx][2] = times[k]; // update keyframe time\r\n                }\r\n\r\n                if ( this.onContentMoved )\r\n                {\r\n                    for ( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n                    {\r\n                        const [ trackIdx, keyIndex, originalKeyTime ] = this.lastKeyFramesSelected[i];\r\n                        track = this.animationClip.tracks[trackIdx];\r\n                        if ( track && track.locked )\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        this.onContentMoved( trackIdx, keyIndex );\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Track.dim == 1:  move keyframes vertically ( change values instead of time )\r\n            // RELIES ON SORTED ARRAY OF lastKeyFramesSelected\r\n            if ( e.altKey && e.buttons & 0x01 )\r\n            {\r\n                const tracks = this.animationClip.tracks;\r\n                let lastTrackChanged = -1;\r\n                for ( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n                {\r\n                    const [ trackIdx, keyIndex, originalKeyTime ] = this.lastKeyFramesSelected[i];\r\n                    track = tracks[trackIdx];\r\n                    if ( track.locked || track.dim != 1 || !track.curves )\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    let value = track.values[keyIndex];\r\n                    let delta = e.deltay * this.keyValuePerPixel * ( track.curvesRange[1] - track.curvesRange[0] );\r\n                    track.values[keyIndex] = Math.max( track.curvesRange[0], Math.min( track.curvesRange[1], value - delta ) ); // invert delta because of screen y\r\n                    track.edited[keyIndex] = true;\r\n\r\n                    if ( this.onUpdateTrack && track.trackIdx != lastTrackChanged && lastTrackChanged > -1 )\r\n                    { // do it only once all keyframes of the same track have been modified\r\n                        this.onUpdateTrack( [ track.trackIdx ] );\r\n                    }\r\n                    lastTrackChanged = track.trackIdx;\r\n                }\r\n                if ( this.onUpdateTrack && lastTrackChanged > -1 )\r\n                { // do the last update, once the last track has been processed\r\n                    this.onUpdateTrack( [ track.trackIdx ] );\r\n                }\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        if ( this.grabbing && e.button != 2 )\r\n        {\r\n        }\r\n        else if ( track )\r\n        {\r\n            this.unHoverAll();\r\n            const thresholdPixels = this.keyframeSize * 0.5; // radius of circle ( curves ) or rotated square (keyframes )\r\n            let keyFrameIndex = this.getCurrentKeyFrame( track, this.xToTime( localX ), this.secondsPerPixel * thresholdPixels );\r\n\r\n            if ( keyFrameIndex > -1 )\r\n            {\r\n                if ( track && track.locked )\r\n                {\r\n                    return;\r\n                }\r\n\r\n                this.lastHovered = [ track.trackIdx, keyFrameIndex ];\r\n                track.hovered[keyFrameIndex] = true;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.unHoverAll();\r\n        }\r\n    }\r\n\r\n    drawContent( ctx: CanvasRenderingContext2D )\r\n    {\r\n        if ( !this.animationClip )\r\n        {\r\n            return;\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        const trackHeight = this.trackHeight;\r\n        const scrollY = -this.currentScrollInPixels;\r\n\r\n        // elements from \"ul\" should match the visible tracks ( and groups ) as if this.selectedItems was flattened\r\n        const visibleElements = this.getVisibleItems();\r\n\r\n        let offset = scrollY;\r\n\r\n        // compute track from which to start rendering ( avoid rendering unseen tracks )\r\n        let startElIdx = 0;\r\n        if ( offset < -this.lastTrackTreesComponentOffset )\r\n        { // offset 0 = ( 0 of canvas ) + track-Tree-Offset. This renders tracks under the time zone\r\n            startElIdx = Math.floor( -( offset + this.lastTrackTreesComponentOffset ) / this.trackHeight ); // how many tracks to skip\r\n            offset += startElIdx * this.trackHeight;\r\n        }\r\n\r\n        ctx.translate( 0, offset );\r\n\r\n        // compute track to end rendering ( avoid rendering unseen tracks )\r\n        let endElIdx = startElIdx\r\n            + Math.ceil( ( ctx.canvas.height - this.lastTrackTreesComponentOffset - offset ) / this.trackHeight );\r\n        endElIdx = endElIdx > visibleElements.length ? visibleElements.length : endElIdx;\r\n\r\n        for ( let t = startElIdx; t < endElIdx; t++ )\r\n        {\r\n            const track = visibleElements[t].treeData.trackData;\r\n            if ( track )\r\n            {\r\n                if ( track.dim == 1 && track.curves )\r\n                {\r\n                    this.drawTrackWithCurves( ctx, trackHeight, track );\r\n                }\r\n                else\r\n                {\r\n                    this.drawTrackWithKeyframes( ctx, trackHeight, track );\r\n                }\r\n            }\r\n\r\n            ctx.translate( 0, trackHeight );\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * @method drawTrackWithKeyframes\r\n     * @param {*} ctx\r\n     * ...\r\n     * @description helper function, you can call it from drawContent to render all the keyframes\r\n     */\r\n    drawTrackWithKeyframes( ctx: CanvasRenderingContext2D, trackHeight: number, track: any )\r\n    {\r\n        if ( track.isSelected )\r\n        {\r\n            ctx.globalAlpha = 0.2;\r\n            ctx.fillStyle = Timeline.TRACK_SELECTED;\r\n            ctx.fillRect( 0, 0, ctx.canvas.width, trackHeight );\r\n        }\r\n\r\n        ctx.fillStyle = Timeline.KEYFRAME_COLOR;\r\n        ctx.globalAlpha = 1;\r\n\r\n        const keyframes = track.times;\r\n        const startTime = this.visualTimeRange[0];\r\n        const endTime = this.visualTimeRange[1] + 0.0000001;\r\n        const defaultPointSize = this.keyframeSize / Math.SQRT2; // pythagoras with equal sides h2 = c2 + c2 = 2 * c2\r\n        const hoverPointSize = this.keyframeSizeHovered / Math.SQRT2;\r\n\r\n        for ( let j = 0; j < keyframes.length; ++j )\r\n        {\r\n            let time = keyframes[j];\r\n            if ( time < startTime || time > endTime )\r\n            {\r\n                continue;\r\n            }\r\n\r\n            let keyframePosX = this.timeToX( time );\r\n            let size = defaultPointSize;\r\n\r\n            if ( !this.active || track.active == false )\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_INACTIVE;\r\n            }\r\n            else if ( track.locked )\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_LOCK;\r\n            }\r\n            else if ( track.hovered[j] )\r\n            {\r\n                size = hoverPointSize;\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_HOVERED;\r\n            }\r\n            else if ( track.selected[j] )\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_SELECTED;\r\n            }\r\n            else if ( track.edited[j] )\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_EDITED;\r\n            }\r\n            else\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR;\r\n            }\r\n\r\n            ctx.save();\r\n            ctx.translate( keyframePosX, trackHeight * 0.5 );\r\n            ctx.rotate( 45 * Math.PI / 180 );\r\n            ctx.fillRect( -size * 0.5, -size * 0.5, size, size );\r\n            ctx.restore();\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n    }\r\n\r\n    drawTrackWithCurves( ctx: CanvasRenderingContext2D, trackHeight: number, track: any )\r\n    {\r\n        if ( track.isSelected )\r\n        {\r\n            ctx.globalAlpha = 0.2;\r\n            ctx.fillStyle = Timeline.TRACK_SELECTED;\r\n            ctx.fillRect( 0, 0, ctx.canvas.width, trackHeight );\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n        const keyframes = track.times;\r\n        const values = track.values;\r\n        const defaultPointSize = this.keyframeSize * 0.5; // radius\r\n        const hoverPointSize = this.keyframeSizeHovered * 0.5; // radius\r\n        const valueRange = track.curvesRange; // [ min, max ]\r\n        const displayRange = trackHeight - defaultPointSize * 2;\r\n        const startTime = this.visualTimeRange[0];\r\n        const endTime = this.visualTimeRange[1] + 0.0000001;\r\n        // draw lines\r\n        ctx.strokeStyle = KeyFramesTimeline.FONT_COLOR_PRIMARY;\r\n        ctx.beginPath();\r\n\r\n        if ( keyframes.length > 1 )\r\n        {\r\n            let startPosX = this.timeToX( keyframes[0] );\r\n            let startValue = values[0];\r\n            startValue = LX.clamp( ( startValue - valueRange[0] ) / ( valueRange[1] - valueRange[0] ), 0, 1 ) * ( -displayRange )\r\n                + ( trackHeight - defaultPointSize ); // normalize and offset\r\n            ctx.moveTo( startPosX, startValue );\r\n\r\n            for ( let j = 1; j < keyframes.length; ++j )\r\n            {\r\n                let time = keyframes[j];\r\n                let keyframePosX = this.timeToX( time );\r\n                let value = values[j];\r\n                value = LX.clamp( ( value - valueRange[0] ) / ( valueRange[1] - valueRange[0] ), 0, 1 ) * ( -displayRange )\r\n                    + ( trackHeight - defaultPointSize ); // normalize and offset\r\n\r\n                if ( time < startTime )\r\n                {\r\n                    ctx.moveTo( keyframePosX, value );\r\n                    continue;\r\n                }\r\n\r\n                if ( time > endTime )\r\n                {\r\n                    let lastKeyframePosX = this.timeToX( keyframes[j - 1] );\r\n                    let dt = keyframePosX - lastKeyframePosX;\r\n                    if ( dt > 0 )\r\n                    {\r\n                        let lastValue = values[j - 1];\r\n                        lastValue = LX.clamp( ( lastValue - valueRange[0] ) / ( valueRange[1] - valueRange[0] ), 0, 1 )\r\n                                * ( -displayRange ) + ( trackHeight - defaultPointSize ); // normalize and offset\r\n                        let f = ( this.timeToX( endTime ) - lastKeyframePosX ) / dt;\r\n                        ctx.lineTo( lastKeyframePosX + dt * f, lastValue * ( 1 - f ) + value * f );\r\n                    }\r\n                    break; // end loop, but print line\r\n                }\r\n\r\n                // convert to timeline track range\r\n                ctx.lineTo( keyframePosX, value );\r\n            }\r\n            ctx.stroke();\r\n        }\r\n\r\n        // draw points\r\n        ctx.fillStyle = Timeline.KEYFRAME_COLOR;\r\n        for ( let j = 0; j < keyframes.length; ++j )\r\n        {\r\n            let time = keyframes[j];\r\n            if ( time < startTime || time > endTime )\r\n            {\r\n                continue;\r\n            }\r\n\r\n            let size = defaultPointSize;\r\n            let keyframePosX = this.timeToX( time );\r\n\r\n            if ( !this.active || !track.active )\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_INACTIVE;\r\n            }\r\n            else if ( track.locked )\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_LOCK;\r\n            }\r\n            else if ( track.hovered[j] )\r\n            {\r\n                size = hoverPointSize;\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_HOVERED;\r\n            }\r\n            else if ( track.selected[j] )\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_SELECTED;\r\n            }\r\n            else if ( track.edited[j] )\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_EDITED;\r\n            }\r\n            else\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR;\r\n            }\r\n\r\n            let value = values[j];\r\n            value = LX.clamp( ( value - valueRange[0] ) / ( valueRange[1] - valueRange[0] ), 0, 1 ) * ( -displayRange )\r\n                + ( trackHeight - defaultPointSize ); // normalize, clamp and offset\r\n\r\n            ctx.beginPath();\r\n            ctx.arc( keyframePosX, value, size, 0, Math.PI * 2 );\r\n            ctx.fill();\r\n            ctx.closePath();\r\n        }\r\n    }\r\n\r\n    _getValidTrackName( uglyName: string )\r\n    {\r\n        let groupId = null;\r\n        let trackId = null;\r\n        let trackNameInfo;\r\n        // Support other versions\r\n        if ( uglyName.includes( '[' ) )\r\n        {\r\n            const nameIndex = uglyName.indexOf( '[' );\r\n            trackNameInfo = uglyName.substring( nameIndex + 1 ).split( '].' );\r\n        }\r\n        else\r\n        {\r\n            trackNameInfo = uglyName.split( '.' );\r\n        }\r\n\r\n        if ( trackNameInfo.length > 1 )\r\n        {\r\n            groupId = trackNameInfo[0];\r\n            trackId = trackNameInfo[1];\r\n        }\r\n        else\r\n        {\r\n            trackId = trackNameInfo[0];\r\n        }\r\n\r\n        return [ groupId, trackId ];\r\n    }\r\n\r\n    /**\r\n     * updates an existing track with new values and times.\r\n     * @param {Int} trackIdx index of track in the animationClip\r\n     * @param {*} newTrack object with two arrays: values and times. These will be set to the selected track\r\n     * @returns\r\n     */\r\n    updateTrack( trackIdx: number, newTrack: any )\r\n    {\r\n        if ( !this.animationClip )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        const track = this.animationClip.tracks[trackIdx];\r\n        track.values = newTrack.values;\r\n        track.times = newTrack.times;\r\n\r\n        track.selected = newTrack.selected ?? ( new Array( track.times.length ) ).fill( false );\r\n        track.hovered = newTrack.hovered ?? ( new Array( track.times.length ) ).fill( false );\r\n        track.edited = newTrack.edited ?? ( new Array( track.times.length ) ).fill( false );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * removes equivalent sequential keys either because of equal times or values\r\n     * ( 0,0,0,0,1,1,1,0,0,0,0,0,0,0 ) --> ( 0, 0,1,1,0, 0 )\r\n     * @param {Int} trackIdx index of track in the animation\r\n     * @param {Boolean} onlyEqualTime if true, removes only keyframes with equal times. Otherwise, values are ALSO compared through the class threshold\r\n     * @param {Boolean} skipCallback if false, triggers \"onOptimizeTracks\" after optimizing\r\n     */\r\n    optimizeTrack( trackIdx: number, onlyEqualTime: boolean = false, skipCallback: boolean = false )\r\n    {\r\n        if ( !this.animationClip ) return;\r\n\r\n        const track = this.animationClip.tracks[trackIdx],\r\n            times = track.times,\r\n            values = track.values,\r\n            stride = track.dim,\r\n            threshold = this.optimizeThreshold;\r\n\r\n        if ( track.locked )\r\n        {\r\n            return;\r\n        }\r\n\r\n        let cmpFunction = ( v: number, p: number, n: number, t: number ) => {\r\n            return Math.abs( v - p ) >= t || Math.abs( v - n ) >= t;\r\n        };\r\n        let lastSavedIndex = 0;\r\n        const lastIndex = times.length - 1;\r\n\r\n        this.saveState( track.trackIdx );\r\n\r\n        for ( let i = 1; i < lastIndex; ++i )\r\n        {\r\n            let keep = false;\r\n            const time = times[i];\r\n            const timePrev = times[lastSavedIndex];\r\n\r\n            // remove adjacent keyframes scheduled at the same time\r\n            if ( time !== timePrev )\r\n            {\r\n                if ( !onlyEqualTime )\r\n                {\r\n                    // remove unnecessary keyframes same as their neighbors\r\n                    const offset = i * stride,\r\n                        offsetP = lastSavedIndex * stride,\r\n                        offsetN = offset + stride;\r\n\r\n                    for ( let j = 0; j !== stride; ++j )\r\n                    {\r\n                        if ( cmpFunction(\r\n                            values[offset + j],\r\n                            values[offsetP + j],\r\n                            values[offsetN + j],\r\n                            threshold\r\n                        ) )\r\n                        {\r\n                            keep = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    keep = true;\r\n                }\r\n            }\r\n\r\n            // in-place compaction\r\n            if ( keep )\r\n            {\r\n                ++lastSavedIndex;\r\n\r\n                if ( i !== lastSavedIndex )\r\n                {\r\n                    times[lastSavedIndex] = times[i];\r\n                    const readOffset = i * stride,\r\n                        writeOffset = lastSavedIndex * stride;\r\n                    for ( let j = 0; j !== stride; ++j )\r\n                    {\r\n                        values[writeOffset + j] = values[readOffset + j];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // add last frame. first and last keyframes should be always kept\r\n        if ( times.length > 1 )\r\n        {\r\n            ++lastSavedIndex;\r\n\r\n            times[lastSavedIndex] = times[times.length - 1];\r\n            const readOffset = values.length - stride,\r\n                writeOffset = lastSavedIndex * stride;\r\n            for ( let j = 0; j !== stride; ++j )\r\n            {\r\n                values[writeOffset + j] = values[readOffset + j];\r\n            }\r\n        }\r\n\r\n        // commit changes\r\n        if ( lastSavedIndex < times.length - 1 )\r\n        {\r\n            track.times = times.slice( 0, lastSavedIndex + 1 );\r\n            track.values = values.slice( 0, ( lastSavedIndex + 1 ) * stride );\r\n            this.updateTrack( track.trackIdx, track ); // update control variables (hover, edited, selected )\r\n        }\r\n\r\n        if ( this.onOptimizeTracks && !skipCallback )\r\n        {\r\n            this.onOptimizeTracks( trackIdx );\r\n        }\r\n    }\r\n\r\n    optimizeTracks( onlyEqualTime: boolean = false )\r\n    {\r\n        if ( !this.animationClip ) return;\r\n\r\n        // save all states into a single entry\r\n        if ( this.historySaveEnabler )\r\n        {\r\n            for ( let i = 0; i < this.animationClip.tracks.length; ++i )\r\n            {\r\n                this.saveState( i, i != 0 );\r\n            }\r\n        }\r\n\r\n        // disable state saving\r\n        const oldStateEnabler = this.historySaveEnabler;\r\n        this.historySaveEnabler = false;\r\n\r\n        // optimize\r\n        for ( let i = 0; i < this.animationClip.tracks.length; ++i )\r\n        {\r\n            const track = this.animationClip.tracks[i];\r\n            this.optimizeTrack( track.trackIdx, onlyEqualTime, true );\r\n        }\r\n\r\n        // restore old enabler status\r\n        this.historySaveEnabler = oldStateEnabler;\r\n\r\n        // callback\r\n        if ( this.onOptimizeTracks )\r\n        {\r\n            this.onOptimizeTracks( -1 ); // signal as \"all tracks\"\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saveState function uses this to generate a \"copy\" of the track.\r\n     * @param {Number} trackIdx\r\n     * @returns All necessary information to reconstruct the track state\r\n     */\r\n    historyGenerateTrackStep( trackIdx: number )\r\n    {\r\n        const trackInfo = this.animationClip.tracks[trackIdx];\r\n\r\n        const undoStep = {\r\n            trackIdx: trackIdx, // already done by saveState\r\n            t: trackInfo.times.slice(),\r\n            v: trackInfo.values.slice(),\r\n            edited: trackInfo.edited.slice( 0, trackInfo.times.length )\r\n        };\r\n\r\n        return undoStep;\r\n    }\r\n\r\n    /**\r\n     * It should swap the previous state with the incoming state of the track. It must return the previous state.\r\n     * historyGenerateTrackStep could be used to copy the previous state. However, as it is a swap, it suffices to just copy the references.\r\n     * @param {Object} state object with a trackIdx:Number and whatever information was saved in historyGenerateTrackStep\r\n     * @param {Boolean} isUndo\r\n     * @returns previous state object\r\n     */\r\n    historyApplyTrackStep( state: any, isUndo: boolean )\r\n    {\r\n        const track = this.animationClip.tracks[state.trackIdx];\r\n\r\n        const stateToReturn = {\r\n            trackIdx: state.trackIdx,\r\n            t: track.times,\r\n            v: track.values,\r\n            edited: track.edited\r\n        };\r\n\r\n        track.times = state.t;\r\n        track.values = state.v;\r\n        track.edited = state.edited;\r\n        if ( track.selected.length != track.times.length ) track.selected.length = track.times.length;\r\n        if ( track.hovered.length != track.times.length ) track.hovered.length = track.times.length;\r\n        track.selected.fill( false );\r\n        track.hovered.fill( false );\r\n\r\n        return stateToReturn;\r\n    }\r\n\r\n    /**\r\n     * @param {*} track\r\n     * @param {Number} srcIdx keyFrame index\r\n     * @param {Number} trgIdx keyFrame index\r\n     */\r\n    swapKeyFrames( track: any, srcIdx: number, trgIdx: number )\r\n    {\r\n        const times = track.times;\r\n        const values = track.values;\r\n\r\n        let tmp = times[srcIdx];\r\n        times[srcIdx] = times[trgIdx];\r\n        times[trgIdx] = tmp;\r\n\r\n        tmp = track.hovered[srcIdx];\r\n        track.hovered[srcIdx] = track.hovered[trgIdx];\r\n        track.hovered[trgIdx] = tmp;\r\n\r\n        tmp = track.edited[srcIdx];\r\n        track.edited[srcIdx] = track.edited[trgIdx];\r\n        track.edited[trgIdx] = tmp;\r\n\r\n        tmp = track.selected[srcIdx];\r\n        track.selected[srcIdx] = track.selected[trgIdx];\r\n        track.selected[trgIdx] = tmp;\r\n\r\n        let src = srcIdx * track.dim;\r\n        let end = src + track.dim;\r\n        let trg = trgIdx * track.dim;\r\n        for ( ; src < end; ++src )\r\n        {\r\n            tmp = values[src];\r\n            values[src] = values[trg];\r\n            values[trg] = tmp;\r\n            ++trg;\r\n        }\r\n    }\r\n\r\n    copySelectedContent()\r\n    {\r\n        if ( !this.lastKeyFramesSelected.length )\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.clipboard = this.clipboard ?? {};\r\n        this.clipboard.keyframes = {}; // reset clipboard\r\n\r\n        // sort keyframes selected by track\r\n        let toCopy: any = {};\r\n        const tracks = this.animationClip.tracks;\r\n        for ( let i = 0; i < this.lastKeyFramesSelected.length; i++ )\r\n        {\r\n            let [ trackIdx, keyIdx ] = this.lastKeyFramesSelected[i];\r\n            const track = tracks[trackIdx];\r\n\r\n            if ( toCopy[trackIdx] )\r\n            {\r\n                toCopy[trackIdx].idxs.push( keyIdx );\r\n            }\r\n            else\r\n            {\r\n                toCopy[trackIdx] = { track: track, idxs: [ keyIdx ] };\r\n            }\r\n\r\n            if ( i == 0 )\r\n            {\r\n                this.copyKeyFrameValue( track, keyIdx );\r\n            }\r\n        }\r\n\r\n        // for each track selected, copy its values\r\n        for ( let trackIdx in toCopy )\r\n        {\r\n            this.copyKeyFrames( toCopy[trackIdx].track, toCopy[trackIdx].idxs );\r\n        }\r\n    }\r\n\r\n    // copies the current value of the keyframe. This value can be pasted across any track ( as long as they are of the same type )\r\n    copyKeyFrameValue( track: any, index: number )\r\n    {\r\n        // 1 element clipboard by now\r\n        const start = index * track.dim;\r\n        const values = this.animationClip.tracks[track.trackIdx].values.slice( start, start + track.dim );\r\n\r\n        this.clipboard = this.clipboard ?? {};\r\n        this.clipboard.value = {\r\n            type: track.type,\r\n            values: values\r\n        };\r\n    }\r\n\r\n    // each track will have its own entry of copied keyframes. When pasting, only the apropiate track's keyframes are pasted\r\n    copyKeyFrames( track: any, indices: number[] )\r\n    {\r\n        let trackIdx = track.trackIdx;\r\n        this.clipboard = this.clipboard ?? {};\r\n\r\n        indices.sort( ( a, b ) => a < b ? -1 : 1 ); // just in case\r\n\r\n        let obj: any = { track: track, values: [], times: [] };\r\n\r\n        for ( let i = 0; i < indices.length; i++ )\r\n        {\r\n            let keyIdx = indices[i];\r\n            let start = keyIdx * track.dim;\r\n            let keyValues = track.values.slice( start, start + track.dim ); // copy values into a new array\r\n            obj.values.push( keyValues ); // save to clipboard\r\n            obj.times.push( track.times[keyIdx] ); // save to clipboard\r\n        }\r\n\r\n        this.clipboard.keyframes[trackIdx] = obj;\r\n    }\r\n\r\n    canPasteKeyFrame()\r\n    {\r\n        return this.clipboard != null;\r\n    }\r\n\r\n    // raw paste of values\r\n    #paste( track: any, index: number, values: number[] )\r\n    {\r\n        const start = index * track.dim;\r\n        let j = 0;\r\n        for ( let i = start; i < start + track.dim; ++i )\r\n        {\r\n            track.values[i] = values[j];\r\n            ++j;\r\n        }\r\n\r\n        track.edited[index] = true;\r\n    }\r\n\r\n    // paste value on selected content ( only one keyframe can be selected )\r\n    pasteContentValue()\r\n    {\r\n        if ( !this.clipboard )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        // copy the value into the only selected keyframe\r\n        if ( this.clipboard.value && this.lastKeyFramesSelected.length == 1 )\r\n        {\r\n            let [ trackIdx, keyIdx ] = this.lastKeyFramesSelected[0];\r\n            this.pasteKeyFrameValue( this.animationClip.tracks[trackIdx], keyIdx );\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // paste copied keyframes. New keyframes are created and overlapping ones are overwritten\r\n    pasteContent( time = this.currentTime )\r\n    {\r\n        if ( !this.clipboard )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        // create new keyframes from the ones copied\r\n        if ( this.clipboard.keyframes )\r\n        {\r\n            for ( let trackIdx in this.clipboard.keyframes )\r\n            {\r\n                const clipboardItem = this.animationClip.tracks[trackIdx];\r\n\r\n                // ensure all tracks are visible\r\n                const idx = this.selectedItems.findIndex( ( item ) => {\r\n                    if ( item.isTrack ) return ( item === clipboardItem );\r\n                    return item === clipboardItem.groupId;\r\n                } );\r\n\r\n                if ( idx == -1 )\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            this.pasteKeyFrames( time );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    pasteKeyFrameValue( track: any, index: number )\r\n    {\r\n        if ( track.locked || ( this.clipboard.value.type != track.type ) )\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.saveState( track.trackIdx );\r\n\r\n        // Copy to current key\r\n        this.#paste( track, index, this.clipboard.value.values );\r\n\r\n        if ( this.onUpdateTrack )\r\n        {\r\n            this.onUpdateTrack( [ track.trackIdx ] );\r\n        }\r\n    }\r\n\r\n    pasteKeyFrames( pasteTime: number = this.currentTime )\r\n    {\r\n        if ( !this.clipboard.keyframes ) return false;\r\n\r\n        this.unHoverAll();\r\n        this.deselectAllKeyFrames();\r\n\r\n        let clipboardTracks = this.clipboard.keyframes;\r\n        let globalStart = Infinity;\r\n        for ( let trackIdx in clipboardTracks )\r\n        {\r\n            if ( globalStart > clipboardTracks[trackIdx].times[0] )\r\n            {\r\n                globalStart = clipboardTracks[trackIdx].times[0];\r\n            }\r\n        }\r\n\r\n        if ( globalStart == Infinity ) return false;\r\n\r\n        // disable callback. It will be done once at the end\r\n        const onUpdateTrack = this.onUpdateTrack;\r\n        this.onUpdateTrack = null;\r\n\r\n        // disable history. It will be done with all changes combined into a single entry\r\n        const oldSaveEnabler = this.historySaveEnabler;\r\n        let trackCount: number = 0; // to detect when to create an entry or\r\n\r\n        for ( let trackIdx in clipboardTracks )\r\n        {\r\n            const clipboardInfo = this.clipboard.keyframes[trackIdx];\r\n            const times = clipboardInfo.times;\r\n            const values = clipboardInfo.values;\r\n            const track = this.animationClip.tracks[trackIdx];\r\n\r\n            if ( track.locked )\r\n            {\r\n                continue;\r\n            }\r\n\r\n            this.saveState( track.trackIdx, Boolean( trackCount++ ) );\r\n            this.historySaveEnabler = false;\r\n            this.addKeyFrames( track.trackIdx, values, times, -globalStart + pasteTime, KeyFramesTimeline.ADDKEY_VALUESINARRAYS );\r\n            this.historySaveEnabler = oldSaveEnabler;\r\n        }\r\n\r\n        // do only one update\r\n        if ( onUpdateTrack )\r\n        {\r\n            this.onUpdateTrack = onUpdateTrack;\r\n            this.onUpdateTrack( Object.keys( clipboardTracks ) );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Int} trackIdx\r\n     * @param {Array} newValues array of values for each keyframe. It should be a flat array of size track.dim*numKeyframes. Check ADDKEY_VALUESINARRAYS flag\r\n     * @param {Array of numbers } newTimes must be ordered ascendently\r\n     * @param {Number} timeOffset\r\n     * @param {Int} flags\r\n     *      KeyFramesTimeline.ADDKEY_VALUESINARRAYS: if set, newValues is an array of arrays, one for each entry [ [1,2,3], [5,6,7] ]. Times is still a flat array of values [ 0, 0.2 ]\r\n\r\n     * @returns\r\n     */\r\n    addKeyFrames( trackIdx: number, newValues: any[], newTimes: number[], timeOffset: number = 0, flags: number = 0x00 )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n\r\n        if ( !newTimes.length || track.locked ) return null;\r\n\r\n        const valueDim = track.dim;\r\n        const trackTimes = track.times;\r\n        const trackValues = track.values;\r\n        const times = new Float32Array( trackTimes.length + newTimes.length );\r\n        const values = new Float32Array( trackValues.length + newTimes.length * valueDim );\r\n\r\n        // let newIdx = this.getNearestKeyFrame( track, newTimes[ newTimes.length - 1 ], -1 );\r\n        this.saveState( trackIdx );\r\n\r\n        let newIdx = newTimes.length - 1;\r\n        let oldIdx = trackTimes.length - 1;\r\n        let resultIndices: number[] = [];\r\n\r\n        if ( KeyFramesTimeline.ADDKEY_VALUESINARRAYS & flags )\r\n        {\r\n            for ( let i: number = times.length - 1; i > -1; --i )\r\n            {\r\n                // copy new value in this place if needed\r\n                if ( oldIdx < 0 || ( newIdx > -1 && trackTimes[oldIdx] < ( newTimes[newIdx] + timeOffset ) ) )\r\n                {\r\n                    const vals: any = newValues[newIdx];\r\n                    for ( let v = 0; v < valueDim; ++v )\r\n                    {\r\n                        values[i * valueDim + v] = vals[v];\r\n                    }\r\n                    times[i] = newTimes[newIdx--] + timeOffset;\r\n                    // Add new entry into each control array\r\n                    track.hovered.splice( oldIdx + 1, 0, false );\r\n                    track.selected.splice( oldIdx + 1, 0, false );\r\n                    track.edited.splice( oldIdx + 1, 0, true );\r\n\r\n                    resultIndices.push( i );\r\n                    continue;\r\n                }\r\n\r\n                // copy old values instead\r\n                for ( let v = 0; v < valueDim; ++v )\r\n                {\r\n                    values[i * valueDim + v] = trackValues[oldIdx * valueDim + v];\r\n                }\r\n                times[i] = trackTimes[oldIdx--];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for ( let i = times.length - 1; i > -1; --i )\r\n            {\r\n                // copy new value in this place if needed\r\n                if ( oldIdx < 0 || ( newIdx > -1 && trackTimes[oldIdx] < ( newTimes[newIdx] + timeOffset ) ) )\r\n                {\r\n                    // ----------- this is different from the 'if' -----------\r\n                    for ( let v = 0; v < valueDim; ++v )\r\n                    {\r\n                        values[i * valueDim + v] = newValues[newIdx * valueDim + v];\r\n                    }\r\n                    times[i] = newTimes[newIdx--] + timeOffset;\r\n                    // Add new entry into each control array\r\n                    track.hovered.splice( oldIdx + 1, 0, false );\r\n                    track.selected.splice( oldIdx + 1, 0, false );\r\n                    track.edited.splice( oldIdx + 1, 0, true );\r\n\r\n                    resultIndices.push( i );\r\n                    continue;\r\n                }\r\n\r\n                // copy old values instead\r\n                for ( let v = 0; v < valueDim; ++v )\r\n                {\r\n                    values[i * valueDim + v] = trackValues[oldIdx * valueDim + v];\r\n                }\r\n                times[i] = trackTimes[oldIdx--];\r\n            }\r\n        }\r\n\r\n        // update track pointers\r\n        track.times = times;\r\n        track.values = values;\r\n\r\n        if ( ( newTimes[newTimes.length - 1] + timeOffset ) > this.duration )\r\n        {\r\n            this.setDuration( newTimes[newTimes.length - 1] + timeOffset );\r\n        }\r\n\r\n        if ( this.onUpdateTrack )\r\n        {\r\n            this.onUpdateTrack( [ trackIdx ] );\r\n        }\r\n\r\n        return resultIndices;\r\n    }\r\n\r\n    deleteSelectedContent( skipCallback = false )\r\n    {\r\n        // *********** WARNING: RELIES ON SORTED lastKeyFramesSelected ***********\r\n\r\n        if ( !this.lastKeyFramesSelected.length ) return;\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        const firstTrack = this.lastKeyFramesSelected[0][0];\r\n        let trackToRemove = firstTrack;\r\n        let toDelete: number[] = []; // indices to delete of the same track\r\n\r\n        const oldSaveEnabler = this.historySaveEnabler;\r\n\r\n        const numSelected = this.lastKeyFramesSelected.length;\r\n        for ( let i = 0; i < numSelected; ++i )\r\n        {\r\n            const [ trackIdx, frameIdx ] = this.lastKeyFramesSelected[i];\r\n\r\n            if ( tracks[trackIdx].locked )\r\n            {\r\n                tracks[trackIdx].selected[frameIdx] = false; // unselect\r\n                continue;\r\n            }\r\n\r\n            if ( trackToRemove != trackIdx )\r\n            {\r\n                this.saveState( trackToRemove, trackToRemove != firstTrack );\r\n\r\n                this.historySaveEnabler = false;\r\n                this.deleteKeyFrames( trackToRemove, toDelete, skipCallback );\r\n                this.historySaveEnabler = oldSaveEnabler;\r\n\r\n                trackToRemove = trackIdx;\r\n                toDelete.length = 0;\r\n            }\r\n\r\n            toDelete.push( frameIdx );\r\n        }\r\n\r\n        this.saveState( trackToRemove, trackToRemove != firstTrack );\r\n        this.historySaveEnabler = false;\r\n        this.deleteKeyFrames( trackToRemove, toDelete, skipCallback );\r\n        this.historySaveEnabler = oldSaveEnabler;\r\n\r\n        this.lastKeyFramesSelected = [];\r\n    }\r\n\r\n    // for typed arrays. Does not update lastSelectedKeyframes\r\n    deleteKeyFrames( trackIdx: number, indices: number[], skipCallback: boolean = false )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n\r\n        if ( !indices.length || track.locked )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        this.saveState( trackIdx );\r\n\r\n        const oldNumFrames = track.times.length;\r\n        const newNumFrames = track.times.length - indices.length;\r\n        const newTimes = track.times.slice( 0, newNumFrames );\r\n        const newValues = track.values.slice( 0, newNumFrames * track.dim );\r\n\r\n        let resultIdx = indices[0];\r\n        let resultValIdx = indices[0] * track.dim;\r\n\r\n        for ( let i = 0; i < indices.length; ++i )\r\n        {\r\n            track.edited.splice( resultIdx, 1 );\r\n            track.selected.splice( resultIdx, 1 );\r\n            track.hovered.splice( resultIdx, 1 );\r\n\r\n            const idx = indices[i];\r\n            const endIdx = ( i < ( indices.length - 1 ) ) ? indices[i + 1] : oldNumFrames;\r\n            const endValIdx = endIdx * track.dim;\r\n            for ( let v = ( idx + 1 ) * track.dim; v < endValIdx; ++v )\r\n            {\r\n                newValues[resultValIdx++] = track.values[v];\r\n            }\r\n            for ( let f = idx + 1; f < endIdx; ++f )\r\n            {\r\n                newTimes[resultIdx++] = track.times[f];\r\n            }\r\n        }\r\n\r\n        track.times = newTimes;\r\n        track.values = newValues;\r\n\r\n        // Update animation action interpolation info\r\n        if ( this.onDeleteKeyFrames && !skipCallback )\r\n        {\r\n            this.onDeleteKeyFrames( trackIdx, indices );\r\n        }\r\n\r\n        if ( ( newTimes[newTimes.length - 1] ) > this.duration )\r\n        {\r\n            this.setDuration( newTimes[newTimes.length - 1] );\r\n        }\r\n\r\n        // if( this.onUpdateTrack )\r\n        //     this.onUpdateTrack( [ trackIdx ] );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binary search. Relies on track.times being a sorted array\r\n     * @param {Object} track\r\n     * @param {Number} time\r\n     * @param {Number} mode on of the possible values\r\n     *  - -1 = nearest frame with t[ f ] <= time\r\n     *  - 0 = nearest frame\r\n     *  - 1 = nearest frame with t[ f ] >= time\r\n     * @returns a zero/positive value if successful. On failure returnes -1 meaning either there are no frames ( 0 ), no frame-time is lower ( -1 ) or no frame-time is higher (1 )\r\n     */\r\n    getNearestKeyFrame( track: any, time: number, mode: number = 0 )\r\n    {\r\n        if ( !track || !track.times || !track.times.length )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        // binary search\r\n        const times = track.times;\r\n        let min = 0, max = times.length - 1;\r\n\r\n        // edge cases\r\n        if ( times[min] > time )\r\n        {\r\n            return mode == -1 ? -1 : 0;\r\n        }\r\n        if ( times[max] < time )\r\n        {\r\n            return mode == 1 ? -1 : max;\r\n        }\r\n\r\n        // time is between first and last frame\r\n        let half = Math.floor( ( min + max ) / 2 );\r\n        while ( min < half && half < max )\r\n        {\r\n            if ( time < times[half] ) max = half;\r\n            else min = half;\r\n            half = Math.floor( ( min + max ) / 2 );\r\n        }\r\n\r\n        if ( mode == 0 )\r\n        {\r\n            return Math.abs( time - times[min] ) < Math.abs( time - times[max] ) ? min : max;\r\n        }\r\n        else if ( mode == -1 )\r\n        {\r\n            return times[max] == time ? max : min;\r\n        }\r\n        return times[min] == time ? min : max;\r\n    }\r\n\r\n    /**\r\n     * get the nearest keyframe to \"time\" given a maximum threshold.\r\n     * @param {Object} track\r\n     * @param {Number} time\r\n     * @param {Number} threshold must be positive value\r\n     * @returns returns a postive/zero value if there is a frame inside the threshold range. Otherwise, -1\r\n     */\r\n    getCurrentKeyFrame( track: any, time: number, threshold: number = 0.0 )\r\n    {\r\n        if ( !track || !track.times.length )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        let frame = this.getNearestKeyFrame( track, time );\r\n        if ( frame > -1 )\r\n        {\r\n            frame = Math.abs( track.times[frame] - time ) > threshold ? -1 : frame;\r\n        }\r\n\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Returns the interval of frames between minTime and maxTime (both included )\r\n     * @param {Object} track\r\n     * @param {Number} minTime\r\n     * @param {Number} maxTime\r\n     * @param {Number} threshold must be positive value\r\n     * @returns an array with two values [ minFrame, maxFrame ]. Otherwise null\r\n     */\r\n    getKeyFramesInRange( track: any, minTime: number, maxTime: number, threshold: number = 0.0 )\r\n    {\r\n        if ( !track || !track.times.length ) return null;\r\n\r\n        // Manage negative selection\r\n        if ( minTime > maxTime )\r\n        {\r\n            let aux = minTime;\r\n            minTime = maxTime;\r\n            maxTime = aux;\r\n        }\r\n\r\n        const minFrame = this.getNearestKeyFrame( track, minTime - threshold, 1 );\r\n        const maxFrame = this.getNearestKeyFrame( track, maxTime + threshold, -1 );\r\n\r\n        if ( maxFrame == -1 || minFrame == -1 ) return null;\r\n\r\n        return [ minFrame, maxFrame ];\r\n    }\r\n\r\n    unHoverAll()\r\n    {\r\n        if ( this.lastHovered )\r\n        {\r\n            this.animationClip.tracks[this.lastHovered[0]].hovered[this.lastHovered[1]] = false;\r\n        }\r\n\r\n        let h = this.lastHovered;\r\n        this.lastHovered = null;\r\n        return h;\r\n    }\r\n\r\n    deselectAllKeyFrames()\r\n    {\r\n        for ( let [ trackIdx, keyIndex ] of this.lastKeyFramesSelected )\r\n        {\r\n            this.animationClip.tracks[trackIdx].selected[keyIndex] = false;\r\n        }\r\n\r\n        // Something has been deselected\r\n        const deselected = this.lastKeyFramesSelected.length > 0;\r\n        this.lastKeyFramesSelected.length = 0;\r\n        return deselected;\r\n    }\r\n\r\n    isKeyFrameSelected( track: any, index: number )\r\n    {\r\n        return track.selected[index];\r\n    }\r\n\r\n    /**\r\n     * @param {Int} trackIdx track index of animation clip\r\n     * @param {Int} frameIdx frame ( index ) to select inside the track\r\n     * @param {Boolean} skipCallback\r\n     * @returns\r\n     */\r\n    selectKeyFrame( trackIdx: number, frameIdx: number, skipCallback: boolean = false )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n        if ( track.locked || !track.active || track.selected[frameIdx] )\r\n        {\r\n            return null;\r\n        }\r\n\r\n        // [ track idx, keyframe, keyframe time ]\r\n        const selection = [ track.trackIdx, frameIdx, track.times[frameIdx] ];\r\n\r\n        // sort lastkeyframeselected ascending order ( track and frame )\r\n        let i = 0;\r\n        for ( ; i < this.lastKeyFramesSelected.length; ++i )\r\n        {\r\n            let s = this.lastKeyFramesSelected[i];\r\n            if ( s[0] > trackIdx || ( s[0] == trackIdx && s[1] > frameIdx ) )\r\n            {\r\n                break;\r\n            }\r\n        }\r\n        this.lastKeyFramesSelected.splice( i, 0, selection );\r\n        track.selected[frameIdx] = true;\r\n\r\n        if ( this.onSelectKeyFrame && !skipCallback )\r\n        {\r\n            this.onSelectKeyFrame( selection );\r\n        }\r\n\r\n        return selection;\r\n    }\r\n\r\n    deselectKeyFrame( trackIdx: number, frameIdx: number )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n        if ( track.locked || !track.active || !track.selected[frameIdx] )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        track.selected[frameIdx] = false;\r\n\r\n        for ( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n        {\r\n            const sk = this.lastKeyFramesSelected[i];\r\n            if ( sk[0] === trackIdx && sk[1] === frameIdx )\r\n            {\r\n                this.lastKeyFramesSelected.splice( i, 1 );\r\n                break;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    getNumKeyFramesSelected()\r\n    {\r\n        return this.lastKeyFramesSelected.length;\r\n    }\r\n\r\n    /**\r\n     * helper function to process a selection with multiple keyframes. Sets the time of the timeline to the first selected keyframe\r\n     * @param {Number} trackIdx\r\n     * @param {Number} keyFrameIndex\r\n     * @param {Boolean} multipleSelection whether to append to selection or reset it and make this keyframe the only current selection\r\n     * @returns\r\n     */\r\n    processSelectionKeyFrame( trackIdx: number, keyFrameIndex: number, multipleSelection: boolean = false )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n        if ( track.locked )\r\n        {\r\n            return;\r\n        }\r\n\r\n        if ( !multipleSelection )\r\n        {\r\n            this.deselectAllKeyFrames();\r\n        }\r\n\r\n        this.selectKeyFrame( trackIdx, keyFrameIndex );\r\n\r\n        if ( !multipleSelection )\r\n        {\r\n            this.setTime( track.times[keyFrameIndex] );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method clearTrack\r\n     */\r\n    clearTrack( trackIdx: number )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n\r\n        this.unHoverAll();\r\n        this.deselectAllKeyFrames();\r\n\r\n        if ( track.locked )\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.saveState( track.trackIdx );\r\n\r\n        track.times = track.times.slice( 0, 0 );\r\n        track.values = track.values.slice( 0, 0 );\r\n        track.edited.length = 0;\r\n        track.hovered.length = 0;\r\n        track.selected.length = 0;\r\n\r\n        return trackIdx;\r\n    }\r\n}\r\n\r\nLX.KeyFramesTimeline = KeyFramesTimeline;\r\n/**\r\n * @class ClipsTimeline\r\n */\r\n\r\nexport class ClipsTimeline extends Timeline\r\n{\r\n    static CLONEREASON_COPY = 1;\r\n    static CLONEREASON_PASTE = 2;\r\n    static CLONEREASON_HISTORY = 3;\r\n    static CLONEREASON_TRACKCLONE = 4;\r\n\r\n    lastClipsSelected: any = [];\r\n    lastTrackClipsMove: number = 0; // vertical movement of clips, onMouseMove onMousedown\r\n    dragClipMode: Nullable<string> = '';\r\n    lastHovered: Nullable<[ number, number ]> = null;\r\n\r\n    onSelectClip: Nullable<( clip: Nullable<any> ) => void> = null;\r\n    onContentMoved: Nullable<( clip: Nullable<any>, delta: number ) => void> = null;\r\n    onDeleteSelectedClips: Nullable<( selected: any[] ) => void> = null;\r\n    onDeleteClip: Nullable<( trackIdx: number, clipIdx: number, clip: any ) => void> = null;\r\n\r\n    /**\r\n     * @param {String} name\r\n     * @param {Object} options = {animationClip, selectedItems, x, y, width, height, canvas, trackHeight}\r\n     */\r\n    constructor( name: string, options: any = {} )\r\n    {\r\n        super( name, options );\r\n\r\n        this.lastClipsSelected = [];\r\n        this.lastTrackClipsMove = 0; // vertical movement of clips, onMouseMove onMousedown\r\n        this.dragClipMode = '';\r\n\r\n        this.setAnimationClip( this.animationClip );\r\n\r\n        this.onDblClick = ( e: any ) => {\r\n            const track = e.track;\r\n            const localX = e.localX;\r\n\r\n            if ( track )\r\n            {\r\n                const clipIdx = this.getClipOnTime( track, this.xToTime( localX ), 0.001 );\r\n                this.selectClip( track.trackIdx, clipIdx ); // deselect and try to select clip in localX, if any\r\n            }\r\n        };\r\n\r\n        this.onShowContextMenu = ( e: any ) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n\r\n            let actions: any[] = [];\r\n            if ( this.lastClipsSelected.length )\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: 'Copy',\r\n                        callback: () => {\r\n                            this.copySelectedContent();\r\n                        }\r\n                    }\r\n                );\r\n                actions.push(\r\n                    {\r\n                        title: 'Delete',\r\n                        callback: () => {\r\n                            this.deleteSelectedContent();\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n            else\r\n            {\r\n                if ( this.clipboard )\r\n                {\r\n                    actions.push(\r\n                        {\r\n                            title: 'Paste',\r\n                            callback: () => {\r\n                                this.pasteContent();\r\n                            }\r\n                        }\r\n                    );\r\n                    actions.push(\r\n                        {\r\n                            title: 'Paste Here',\r\n                            callback: () => {\r\n                                this.pasteContent( this.xToTime( e.localX ) );\r\n                            }\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n\r\n            LX.addContextMenu( 'Options', e, ( m: any ) => {\r\n                for ( let i = 0; i < actions.length; i++ )\r\n                {\r\n                    m.add( actions[i].title, actions[i].callback );\r\n                }\r\n            } );\r\n        }; // end of onShowContextMenu\r\n    }\r\n\r\n    /**\r\n     * Generates an animationClip using either the parameters set in the animation argument or using default values\r\n     * @param {Object} animation data with which to generate an animationClip\r\n     * @returns\r\n     */\r\n    instantiateAnimationClip( animation: any, clone: boolean = false )\r\n    {\r\n        const animationClip = super.instantiateAnimationClip( animation );\r\n\r\n        if ( animation && animation.tracks )\r\n        {\r\n            for ( let i = 0; i < animation.tracks.length; ++i )\r\n            {\r\n                const trackInfo: any = this.instantiateTrack( animation.tracks[i], clone );\r\n                trackInfo.trackIdx = animationClip.tracks.length;\r\n                animationClip.tracks.push( trackInfo );\r\n            }\r\n        }\r\n\r\n        return animationClip;\r\n    }\r\n\r\n    /**\r\n     * @param {Object} options set some values for the track instance ( groups and trackIdx not included )\r\n     * @returns\r\n     */\r\n    instantiateTrack( options: any = {}, clone: boolean = false )\r\n    {\r\n        const track: any = super.instantiateTrack( options );\r\n\r\n        track.trackIdx = this.animationClip.tracks.length;\r\n\r\n        track.selected = [];\r\n        track.edited = [];\r\n        track.hovered = [];\r\n\r\n        if ( options.clips )\r\n        {\r\n            track.clips = clone\r\n                ? this.cloneClips( options.clips, 0, ClipsTimeline.CLONEREASON_TRACKCLONE )\r\n                : options.clips;\r\n        }\r\n        else\r\n        {\r\n            track.clips = [];\r\n        }\r\n\r\n        const numClips = track.clips.length;\r\n\r\n        if ( options.selected && options.selected.length == numClips )\r\n        {\r\n            track.selected = clone ? options.selected.slice() : options.selected;\r\n        }\r\n        else\r\n        {\r\n            track.selected = ( new Array( numClips ) ).fill( false );\r\n        }\r\n\r\n        if ( options.edited && options.edited.length == numClips )\r\n        {\r\n            track.edited = clone ? options.edited.slice() : options.edited;\r\n        }\r\n        else\r\n        {\r\n            track.edited = ( new Array( numClips ) ).fill( false );\r\n        }\r\n\r\n        if ( options.hovered && options.hovered.length == numClips )\r\n        {\r\n            track.hovered = clone ? options.hovered.slice() : options.hovered;\r\n        }\r\n        else\r\n        {\r\n            track.hovered = ( new Array( numClips ) ).fill( false );\r\n        }\r\n\r\n        // sanity check. Also done in addClip\r\n        for ( let i = 0; i < track.clips.length; ++i )\r\n        {\r\n            track.clips[i].active = track.clips[i].active ?? true;\r\n        }\r\n        return track;\r\n    }\r\n\r\n    // provides an base example of a proper clip\r\n    instantiateClip( options: any = {} )\r\n    {\r\n        return {\r\n            id: options.id ?? ( options.name ?? 'clip' ),\r\n\r\n            start: options.start ?? 0,\r\n            duration: options.duration ?? 1,\r\n            fadein: options.fadein ?? undefined,\r\n            fadeout: options.fadeout ?? undefined,\r\n\r\n            clipColor: options.clipColor ?? LX.getCSSVariable( 'color-blue-600' ),\r\n            fadeColor: options.fadeColor ?? null,\r\n            active: options.active ?? true,\r\n            trackIdx: -1 // filled by addClip\r\n        };\r\n    }\r\n    // use default updateleftpanel\r\n    // generateSelectedItemsTreeData() {}\r\n\r\n    addNewTrack( options: any = {}, updateLeftPanel: boolean = true, skipCallback: boolean = false )\r\n    {\r\n        const trackInfo = this.instantiateTrack( options ?? {} );\r\n        trackInfo.trackIdx = this.animationClip.tracks.length;\r\n        this.animationClip.tracks.push( trackInfo );\r\n\r\n        if ( this.onAddNewTrack && !skipCallback )\r\n        {\r\n            this.onAddNewTrack( trackInfo, options );\r\n        }\r\n\r\n        this.selectedItems.push( trackInfo );\r\n        if ( updateLeftPanel )\r\n        {\r\n            this.updateLeftPanel();\r\n        }\r\n\r\n        return trackInfo.trackIdx;\r\n    }\r\n\r\n    // OVERRIDE ITEM SELECTION - ClipsTimeline will not offer any selection. Alltracks are visible\r\n    setAnimationClip( animation: any, needsToProcess: boolean = true )\r\n    {\r\n        super.setAnimationClip( animation, needsToProcess );\r\n        this.changeSelectedItems();\r\n        return this.animationClip;\r\n    }\r\n\r\n    // OVERRIDE\r\n    deselectAllElements()\r\n    {\r\n        this.deselectAllClips();\r\n        this.unHoverAll();\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE ITEM SELECTION.\r\n     * CLIPS WILL OFFER NO SELECTION. All tracks are visible\r\n     */\r\n    changeSelectedItems()\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left\r\n\r\n        this.selectedItems = this.animationClip.tracks.slice();\r\n\r\n        this.updateLeftPanel();\r\n    }\r\n\r\n    unHoverAll()\r\n    {\r\n        if ( this.lastHovered )\r\n        {\r\n            this.animationClip.tracks[this.lastHovered[0]].hovered[this.lastHovered[1]] = false;\r\n        }\r\n\r\n        let h = this.lastHovered;\r\n        this.lastHovered = null;\r\n        return h;\r\n    }\r\n\r\n    onMouseUp( e: any )\r\n    {\r\n        let track = e.track;\r\n        let localX = e.localX;\r\n        let discard = e.discard; // true when too much time has passed between Down and Up\r\n\r\n        if ( e.shiftKey )\r\n        {\r\n            // Manual Multiple selection\r\n            if ( !discard )\r\n            {\r\n                if ( track )\r\n                {\r\n                    let clipIndex = this.getClipOnTime( track, this.xToTime( localX ), this.secondsPerPixel * 5 );\r\n                    if ( clipIndex > -1 )\r\n                    {\r\n                        track.selected[clipIndex]\r\n                            ? this.deselectClip( track.trackIdx, clipIndex )\r\n                            : this.selectClip( track.trackIdx, clipIndex, false );\r\n                    }\r\n                }\r\n            }\r\n            // Box selection\r\n            else if ( this.boxSelection )\r\n            {\r\n                let tracks = this.getTracksInRange( this.boxSelectionStart[1], this.boxSelectionEnd[1] );\r\n\r\n                for ( let t of tracks )\r\n                {\r\n                    let clipsIndices = this.getClipsInRange( t, this.xToTime( this.boxSelectionStart[0] ), this.xToTime( this.boxSelectionEnd[0] ),\r\n                        0.000001 );\r\n\r\n                    if ( clipsIndices )\r\n                    {\r\n                        for ( let index of clipsIndices )\r\n                        {\r\n                            this.selectClip( t.trackIdx, index, false );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            let boundingBox = this.canvas.getBoundingClientRect();\r\n            if ( e.y < boundingBox.top || e.y > boundingBox.bottom )\r\n            {\r\n                return;\r\n            }\r\n\r\n            // Check exact track clip\r\n            if ( !discard && track )\r\n            {\r\n                if ( e.button != 2 )\r\n                {\r\n                    const clipIdx = this.getClipOnTime( track, this.xToTime( localX ), 0.001 );\r\n                    this.selectClip( track.trackIdx, clipIdx );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.movingKeys = false;\r\n    }\r\n\r\n    onMouseDown( e: any, time: number )\r\n    {\r\n        // function not called if shift is pressed (boxselection )\r\n        let localX = e.localX;\r\n        let localY = e.localY;\r\n        let track = e.track;\r\n\r\n        if ( e.button > 0 )\r\n        {\r\n            return;\r\n        }\r\n\r\n        if ( e.ctrlKey && track )\r\n        { // move clips\r\n            let x = e.offsetX;\r\n            // clip selection is done on MouseUP\r\n            const selectedClips = this.lastClipsSelected;\r\n\r\n            this.canvas.style.cursor = 'grab';\r\n            let curTrackIdx = -1;\r\n\r\n            this.lastTrackClipsMove = Math.floor(\r\n                ( e.localY - this.topMargin + this.trackTreesPanel.root.scrollTop ) / this.trackHeight\r\n            );\r\n\r\n            for ( let i = 0; i < selectedClips.length; i++ )\r\n            {\r\n                let [ trackIndex, clipIndex ] = selectedClips[i];\r\n                const clip = this.animationClip.tracks[trackIndex].clips[clipIndex];\r\n\r\n                let endingX = this.timeToX( clip.start + clip.duration );\r\n\r\n                if ( Math.abs( endingX - x ) < 5 )\r\n                {\r\n                    this.dragClipMode = 'duration';\r\n                    this.canvas.style.cursor = 'column-resize';\r\n                }\r\n                else\r\n                {\r\n                    this.dragClipMode = 'move';\r\n                }\r\n\r\n                // *********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n                if ( curTrackIdx != trackIndex )\r\n                {\r\n                    this.saveState( trackIndex, curTrackIdx != -1 );\r\n                    curTrackIdx = trackIndex;\r\n                }\r\n            }\r\n\r\n            this.movingKeys = true;\r\n        }\r\n        else if ( !track || track && this.getClipOnTime( track, time, 0.001 ) == -1 )\r\n        { // clicked on empty space\r\n            if ( this.lastClipsSelected.length )\r\n            {\r\n                this.deselectAllClips();\r\n\r\n                if ( this.onSelectClip )\r\n                {\r\n                    this.onSelectClip( null );\r\n                }\r\n            }\r\n        }\r\n        else if ( track\r\n            && ( this.dragClipMode == 'duration' || this.dragClipMode == 'fadein' || this.dragClipMode == 'fadeout' ) )\r\n        { // clicked while mouse was over fadeIn, fadeOut, duration\r\n            const clipIdx = this.getClipOnTime( track, this.xToTime( localX ), 0.001 );\r\n            this.selectClip( track.trackIdx, clipIdx ); // select current clip if any ( deselect others )\r\n            if ( this.lastClipsSelected.length )\r\n            {\r\n                this.saveState( track.trackIdx );\r\n            }\r\n            this.movingKeys = true;\r\n        }\r\n    }\r\n\r\n    onMouseMove( e: any, time: number )\r\n    {\r\n        // function not called if shift is pressed (boxselection )\r\n\r\n        if ( this.grabbingTimeBar || this.grabbingScroll )\r\n        {\r\n            return;\r\n        }\r\n        else if ( this.grabbing && e.buttons != 2 )\r\n        {\r\n            this.unHoverAll();\r\n\r\n            let delta = time - this.grabTime;\r\n            this.grabTime = time;\r\n            if ( time < 0 && delta > 0 ) delta = 0;\r\n\r\n            if ( this.dragClipMode != 'move' && this.lastClipsSelected.length == 1 )\r\n            { // change fade and duration of clips\r\n                const track = this.animationClip.tracks[this.lastClipsSelected[0][0]];\r\n                let clip = track.clips[this.lastClipsSelected[0][1]];\r\n                if ( this.dragClipMode == 'fadein' )\r\n                {\r\n                    clip.fadein = Math.min( Math.max( clip.fadein + delta, clip.start ), clip.fadeout ?? ( clip.start + clip.duration ) );\r\n                }\r\n                else if ( this.dragClipMode == 'fadeout' )\r\n                {\r\n                    clip.fadeout = Math.max( Math.min( clip.fadeout + delta, clip.start + clip.duration ), clip.fadein ?? clip.start );\r\n                }\r\n                else if ( this.dragClipMode == 'duration' )\r\n                {\r\n                    let duration = Math.max( 0, clip.duration + delta );\r\n                    if ( this.lastClipsSelected[0][1] < track.clips.length - 1 )\r\n                    { // max next clip's start\r\n                        duration = Math.min( track.clips[this.lastClipsSelected[0][1] + 1].start - clip.start - 0.0001, duration );\r\n                    }\r\n                    clip.duration = duration;\r\n                    if ( clip.fadeout != undefined )\r\n                    {\r\n                        clip.fadeout = Math.max(\r\n                            Math.min( ( clip.fadeout ?? ( clip.start + clip.duration ) ) + delta, clip.start + clip.duration ),\r\n                            clip.start\r\n                        );\r\n                    }\r\n                    if ( clip.fadein != undefined )\r\n                    {\r\n                        clip.fadein = Math.max(\r\n                            Math.min( clip.fadein ?? ( clip.start + clip.duration ), clip.fadeout ?? ( clip.start + clip.duration ) ),\r\n                            clip.start\r\n                        );\r\n                    }\r\n                    if ( this.duration < clip.start + clip.duration ) this.setDuration( clip.start + clip.duration );\r\n                }\r\n\r\n                if ( this.onContentMoved )\r\n                { // content changed\r\n                    this.onContentMoved( clip, 0 );\r\n                }\r\n            }\r\n            else if ( this.dragClipMode == 'move' && this.lastClipsSelected.length )\r\n            { // move clips\r\n                // *********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n\r\n                const treeOffset = this.lastTrackTreesComponentOffset;\r\n                let newTrackClipsMove = Math.floor( ( e.localY - treeOffset ) / this.trackHeight );\r\n\r\n                // move clips vertically\r\n                if ( e.altKey )\r\n                {\r\n                    let deltaTracks = newTrackClipsMove - this.lastTrackClipsMove;\r\n\r\n                    if ( this.lastClipsSelected[0][0] + deltaTracks < 0 )\r\n                    {\r\n                        deltaTracks = -this.lastClipsSelected[0][0];\r\n                    }\r\n\r\n                    // if no movement of tracks, do not check\r\n                    if ( deltaTracks != 0 )\r\n                    {\r\n                        // check if ALL selected clips can move track\r\n                        for ( let i = 0; i < this.lastClipsSelected.length; ++i )\r\n                        {\r\n                            const track = this.animationClip.tracks[this.lastClipsSelected[i][0]];\r\n                            const newTrack = this.animationClip.tracks[this.lastClipsSelected[i][0] + deltaTracks];\r\n                            const clip = track.clips[this.lastClipsSelected[i][1]];\r\n\r\n                            const clipsInRange = this.getClipsInRange( newTrack, clip.start, clip.start + clip.duration, 0.0001 );\r\n                            if ( !clipsInRange )\r\n                            {\r\n                                continue;\r\n                            }\r\n\r\n                            for ( let c = 0; c < clipsInRange.length; ++c )\r\n                            {\r\n                                if ( !newTrack.selected[clipsInRange[c]] )\r\n                                {\r\n                                    // at least one clip cannot move, abort\r\n                                    c = clipsInRange.length;\r\n                                    i = this.lastClipsSelected.length;\r\n                                    deltaTracks = 0;\r\n                                    newTrackClipsMove = this.lastTrackClipsMove;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // if movement was not canceled\r\n                        if ( deltaTracks != 0 )\r\n                        {\r\n                            let oldStateEnabler = this.historySaveEnabler;\r\n                            this.historySaveEnabler = false;\r\n\r\n                            const selectedClips = this.lastClipsSelected;\r\n                            this.lastClipsSelected = []; // avoid delete and addclips index reassignment loop ( not necessary because of order of operations in for )\r\n\r\n                            for ( let i = selectedClips[selectedClips.length - 1][0] + deltaTracks\r\n                                - this.animationClip.tracks.length + 1; i > 0; --i )\r\n                            {\r\n                                this.addNewTrack( null, i == 1 );\r\n                                if ( i == 1 )\r\n                                {\r\n                                    this.updateLeftPanel();\r\n                                }\r\n                            }\r\n\r\n                            // selected clips MUST be ordered ( ascendently )\r\n                            let startSel = deltaTracks > 0 ? selectedClips.length - 1 : 0;\r\n                            let endSel = startSel;\r\n                            let currTrack = selectedClips[startSel][0];\r\n\r\n                            // i <= length; to update last track. Otherwise a check outside of for would be needed\r\n                            for ( let i = 1; i <= selectedClips.length; ++i )\r\n                            {\r\n                                let idx = deltaTracks > 0 ? ( selectedClips.length - 1 - i ) : i;\r\n                                if ( i == selectedClips.length || selectedClips[idx][0] != currTrack )\r\n                                {\r\n                                    const newTrackIdx = currTrack + deltaTracks;\r\n                                    const newTrack = this.animationClip.tracks[newTrackIdx];\r\n                                    const track = this.animationClip.tracks[currTrack];\r\n\r\n                                    // save track state if necessary\r\n                                    const undoState = this.historyUndo[this.historyUndo.length - 1];\r\n                                    let state = 0;\r\n                                    for ( ; state < undoState.length; ++state )\r\n                                    {\r\n                                        if ( newTrackIdx == undoState[state].trackIdx ) break;\r\n                                    }\r\n\r\n                                    if ( state == undoState.length )\r\n                                    {\r\n                                        this.historySaveEnabler = true;\r\n                                        this.saveState( newTrackIdx, true );\r\n                                        this.historySaveEnabler = false;\r\n                                    }\r\n\r\n                                    // add clips of a track, from first to last\r\n                                    for ( let c = startSel; c <= endSel; ++c )\r\n                                    {\r\n                                        let newClipIdx = this.addClip( track.clips[selectedClips[c][1]], newTrackIdx, 0 );\r\n                                        selectedClips[c][0] = newClipIdx; // temporarily store new clip index in trackIndex (HACK START )\r\n                                        newTrack.selected[newClipIdx] = true;\r\n                                    }\r\n\r\n                                    // delete clips of a track, from last to first\r\n                                    for ( let c = endSel; c >= startSel; --c )\r\n                                    {\r\n                                        this.#delete( currTrack, selectedClips[c][1] );\r\n                                        selectedClips[c][1] = selectedClips[c][0]; // put new clip index (HACK )\r\n                                        selectedClips[c][0] = newTrackIdx; // put new track index (HACK FIX )\r\n                                    }\r\n\r\n                                    currTrack = i < selectedClips.length ? selectedClips[idx][0] : -1;\r\n                                    startSel = idx;\r\n                                    endSel = idx;\r\n                                    continue;\r\n                                }\r\n\r\n                                deltaTracks > 0 ? startSel = idx : endSel = idx;\r\n                            }\r\n\r\n                            this.lastClipsSelected = selectedClips;\r\n                            this.historySaveEnabler = oldStateEnabler;\r\n                        }\r\n                    }\r\n                }\r\n                this.lastTrackClipsMove = newTrackClipsMove;\r\n\r\n                // move clips horizontally\r\n\r\n                let leastDelta = delta;\r\n                let moveAccepted = true;\r\n\r\n                // find if all clips can move and/or how much they can move\r\n                for ( let i = 0; i < this.lastClipsSelected.length; ++i )\r\n                {\r\n                    let trackIdx = this.lastClipsSelected[i][0];\r\n                    let clipIdx = this.lastClipsSelected[i][1];\r\n                    const track = this.animationClip.tracks[trackIdx];\r\n                    const trackClips = track.clips;\r\n                    const clip = track.clips[clipIdx];\r\n\r\n                    if ( delta >= 0 )\r\n                    {\r\n                        if ( trackClips.length - 1 == clipIdx ) continue; // all alowed\r\n                        if ( !track.selected[clipIdx + 1] )\r\n                        { // if next is selected, force AllOrNothing and let next clip manage the leastDelta\r\n                            if ( trackClips[clipIdx + 1].start >= ( clip.start + clip.duration + delta ) ) continue; // has not reached next clip. Enough space. All allowed\r\n                            const nextClip = trackClips[clipIdx + 1];\r\n                            leastDelta = Math.max( 0, Math.min( leastDelta, nextClip.start - clip.start - clip.duration ) );\r\n                        }\r\n                    }\r\n                    else if ( delta < 0 )\r\n                    {\r\n                        if ( clipIdx > 0\r\n                            && ( trackClips[clipIdx - 1].start + trackClips[clipIdx - 1].duration )\r\n                                <= ( clip.start + delta ) ) continue; // has not reached previous clip. Enough space\r\n                        if ( clipIdx > 0 )\r\n                        {\r\n                            const prevClip = trackClips[clipIdx - 1];\r\n                            leastDelta = Math.min( 0, Math.max( leastDelta, prevClip.start + prevClip.duration - clip.start ) ); // delta is a negative value, that is why the leastDelta is the max\r\n                        }\r\n                        if ( clip.start + delta < 0 )\r\n                        {\r\n                            leastDelta = Math.max( leastDelta, -clip.start );\r\n                            moveAccepted = false; // force it to be a leastDelta move only. No jumps\r\n                        }\r\n                    }\r\n\r\n                    if ( !moveAccepted ) continue;\r\n                    let clipsInRange = this.getClipsInRange( track, clip.start + delta, clip.start + clip.duration + delta, 0.01 );\r\n                    if ( clipsInRange\r\n                        && ( clipsInRange[0] != clipIdx || clipsInRange[clipsInRange.length - 1] != clipIdx ) )\r\n                    {\r\n                        for ( let c = 0; c < clipsInRange.length; ++c )\r\n                        {\r\n                            if ( !track.selected[clipsInRange[c]] )\r\n                            {\r\n                                moveAccepted = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // if moveAccepted -> use full delta\r\n                // if !moveAccepted -> use leastDelta\r\n                if ( moveAccepted ) leastDelta = delta;\r\n                this.grabTime = time - delta + leastDelta;\r\n\r\n                // *********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n                // move all selected clips using the computed delta.\r\n                for ( let i = 0; i < this.lastClipsSelected.length; ++i )\r\n                {\r\n                    const lcs = this.lastClipsSelected[delta > 0 ? ( this.lastClipsSelected.length - 1 - i ) : i]; // delta > 0, move last-to-first; delta < 0, move first-to-last\r\n                    const track = this.animationClip.tracks[lcs[0]];\r\n                    const trackClips = track.clips;\r\n                    let clipIdx = lcs[1];\r\n                    const clip = track.clips[clipIdx];\r\n                    clip.start += leastDelta;\r\n                    if ( clip.fadein != undefined ) clip.fadein += leastDelta;\r\n                    if ( clip.fadeout != undefined ) clip.fadeout += leastDelta;\r\n\r\n                    // prepare swap\r\n                    const editedFlag = track.edited[clipIdx];\r\n                    const selectedFlag = track.selected[clipIdx];\r\n                    const hoveredFlag = track.hovered[clipIdx];\r\n\r\n                    // move other clips\r\n                    if ( delta > 0 )\r\n                    {\r\n                        while ( clipIdx < trackClips.length - 1 )\r\n                        {\r\n                            if ( trackClips[clipIdx + 1].start >= clip.start )\r\n                            {\r\n                                break;\r\n                            }\r\n                            trackClips[clipIdx] = trackClips[clipIdx + 1];\r\n                            track.selected[clipIdx] = track.selected[clipIdx + 1];\r\n                            track.edited[clipIdx] = track.edited[clipIdx + 1];\r\n                            track.hovered[clipIdx] = track.hovered[clipIdx + 1];\r\n                            clipIdx++;\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        while ( clipIdx > 0 )\r\n                        {\r\n                            if ( trackClips[clipIdx - 1].start <= clip.start )\r\n                            {\r\n                                break;\r\n                            }\r\n\r\n                            trackClips[clipIdx] = trackClips[clipIdx - 1];\r\n                            track.selected[clipIdx] = track.selected[clipIdx - 1];\r\n                            track.edited[clipIdx] = track.edited[clipIdx - 1];\r\n                            track.hovered[clipIdx] = track.hovered[clipIdx - 1];\r\n                            clipIdx--;\r\n                        }\r\n                    }\r\n                    // commit swap\r\n                    trackClips[clipIdx] = clip;\r\n                    track.edited[clipIdx] = editedFlag;\r\n                    track.selected[clipIdx] = selectedFlag;\r\n                    track.hovered[clipIdx] = hoveredFlag;\r\n\r\n                    // update selected clip index\r\n                    lcs[1] = clipIdx;\r\n\r\n                    if ( clip.start + clip.duration > this.duration )\r\n                    {\r\n                        this.setDuration( clip.start + clip.duration );\r\n                    }\r\n\r\n                    if ( this.onContentMoved )\r\n                    {\r\n                        this.onContentMoved( clip, leastDelta );\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n        else if ( e.track && e.buttons == 0 )\r\n        { // mouse not dragging, just hovering\r\n            this.unHoverAll();\r\n            let clips = this.getClipsInRange( e.track, time, time, 0.00001 );\r\n            if ( !e.track.locked && clips )\r\n            {\r\n                this.lastHovered = [ e.track.trackIdx, clips[0] ];\r\n                e.track.hovered[clips[0]] = true;\r\n\r\n                let clip = e.track.clips[clips[0]];\r\n                if ( !clip )\r\n                {\r\n                    return;\r\n                }\r\n\r\n                if ( Math.abs( e.localX - this.timeToX( clip.start + clip.duration ) ) < 8 )\r\n                { // duration\r\n                    this.canvas.style.cursor = 'col-resize';\r\n                    this.dragClipMode = 'duration';\r\n                }\r\n                else if ( clip.fadein != undefined && Math.abs( e.localX - this.timeToX( clip.fadein ) ) < 8 )\r\n                { // fadein\r\n                    this.canvas.style.cursor = 'e-resize';\r\n                    this.dragClipMode = 'fadein';\r\n                }\r\n                else if ( clip.fadeout != undefined && Math.abs( e.localX - this.timeToX( clip.fadeout ) ) < 8 )\r\n                { // fadeout\r\n                    this.canvas.style.cursor = 'e-resize';\r\n                    this.dragClipMode = 'fadeout';\r\n                }\r\n                else\r\n                {\r\n                    this.dragClipMode = '';\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.unHoverAll();\r\n        }\r\n    }\r\n\r\n    drawContent( ctx: CanvasRenderingContext2D )\r\n    {\r\n        if ( !this.animationClip ) return;\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        const trackHeight = this.trackHeight;\r\n        const scrollY = -this.currentScrollInPixels;\r\n\r\n        ctx.save();\r\n\r\n        for ( let i = 0; i < tracks.length; i++ )\r\n        {\r\n            let track = tracks[i];\r\n            this.drawTrackWithBoxes( ctx, i * trackHeight + scrollY, trackHeight, track );\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * @method drawTrackWithBoxes\r\n     * @param {*} ctx\r\n     */\r\n    drawTrackWithBoxes( ctx: CanvasRenderingContext2D, y: number, trackHeight: number, track: any )\r\n    {\r\n        // Fill track background if it's selected\r\n        ctx.globalAlpha = 0.2;\r\n        ctx.fillStyle = Timeline.TRACK_SELECTED;\r\n        if ( track.isSelected )\r\n        {\r\n            ctx.fillRect( 0, y, ctx.canvas.width, trackHeight );\r\n        }\r\n\r\n        const clips = track.clips;\r\n\r\n        // set clip box size\r\n        const offset = ( trackHeight * 0.4 ) * 0.5;\r\n        trackHeight *= 0.6;\r\n\r\n        let selectedClipArea: any = null;\r\n\r\n        ctx.font = Math.floor( trackHeight * 0.8 ) + 'px' + Timeline.FONT;\r\n        ctx.textAlign = 'left';\r\n        ctx.textBaseline = 'middle';\r\n\r\n        for ( var j = 0; j < clips.length; ++j )\r\n        {\r\n            selectedClipArea = null;\r\n            const clip = clips[j];\r\n            // let selected = track.selected[ j ];\r\n            var x = Math.floor( this.timeToX( clip.start ) ) + 0.5;\r\n            var x2 = Math.floor( this.timeToX( clip.start + clip.duration ) ) + 0.5;\r\n            var w = x2 - x;\r\n\r\n            if ( x2 < 0 || x > this.canvas.width )\r\n            {\r\n                continue;\r\n            }\r\n\r\n            // Overwrite clip color state depending on its state\r\n            ctx.globalAlpha = 1;\r\n            ctx.fillStyle = clip.clipColor || ( track.hovered[j]\r\n                ? Timeline.KEYFRAME_COLOR_HOVERED\r\n                : ( track.selected[j] ? Timeline.TRACK_SELECTED : Timeline.KEYFRAME_COLOR ) );\r\n            if ( !this.active || !track.active || !clip.active )\r\n            {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_INACTIVE;\r\n            }\r\n\r\n            // Draw clip background\r\n            drawRoundRect( ctx, x, y + offset, w, trackHeight, 5, true );\r\n\r\n            if ( this.active && track.active && clip.active )\r\n            {\r\n                ctx.fillStyle = clip.fadeColor ?? '#0004';\r\n\r\n                if ( clip.fadein != undefined )\r\n                {\r\n                    const fadeinX = this.pixelsPerSecond * ( clip.fadein - clip.start );\r\n                    drawRoundRect( ctx, x, y + offset, fadeinX, trackHeight, { tl: 5, bl: 5, tr: 0, br: 0 }, true );\r\n                }\r\n                if ( clip.fadeout != undefined )\r\n                {\r\n                    const fadeoutX = this.pixelsPerSecond * ( clip.start + clip.duration - ( clip.fadeout ) );\r\n                    drawRoundRect( ctx, x + w - fadeoutX, y + offset, fadeoutX, trackHeight, { tl: 0, bl: 0, tr: 5, br: 5 }, true );\r\n                }\r\n            }\r\n\r\n            ctx.fillStyle = Timeline.TRACK_COLOR_PRIMARY;\r\n\r\n            if ( track.selected[j] || track.hovered[j] )\r\n            {\r\n                ctx.strokeStyle = ctx.shadowColor = clip.clipColor || Timeline.TRACK_SELECTED;\r\n                ctx.shadowBlur = 10;\r\n                ctx.shadowOffsetX = 1.5;\r\n                ctx.shadowOffsetY = 1.5;\r\n\r\n                selectedClipArea = [ x - 1, y + offset - 1, x2 - x + 2, trackHeight + 2 ];\r\n                drawRoundRect( ctx, selectedClipArea[0], selectedClipArea[1], selectedClipArea[2], selectedClipArea[3], 5, false, true );\r\n\r\n                ctx.shadowBlur = 0;\r\n                ctx.shadowOffsetX = 0;\r\n                ctx.shadowOffsetY = 0;\r\n\r\n                ctx.font = 'bold' + Math.floor( trackHeight ) + 'px ' + Timeline.FONT;\r\n                ctx.fillStyle = Timeline.FONT_COLOR_PRIMARY;\r\n            }\r\n\r\n            let text = clip.id ?? ''; // clip.id.replaceAll(\"_\", \" \").replaceAll(\"-\", \" \");\r\n            const textInfo = ctx.measureText( text );\r\n\r\n            let textWidth = textInfo.width;\r\n            if ( textWidth > w && textWidth > 0 )\r\n            {\r\n                let amount = Math.floor( w * text.length / textWidth );\r\n                text = text.substr( 0, amount );\r\n                textWidth = w;\r\n            }\r\n\r\n            ctx.fillText( text, x + ( w - textWidth ) * 0.5, y + offset + trackHeight * 0.5 );\r\n\r\n            ctx.fillStyle = track.hovered[j] ? 'white' : '#f5f5f5'; // track.hovered[ j ] ? \"white\" : Timeline.FONT_COLOR_QUATERNARY;\r\n            ctx.strokeStyle = 'rgba(125,125,125,0.4)';\r\n\r\n            // Draw resize bounding\r\n            drawRoundRect( ctx, x + w - 8, y + offset, 8, trackHeight, { tl: 4, bl: 4, tr: 4, br: 4 }, true, true );\r\n        }\r\n\r\n        ctx.font = '12px' + Timeline.FONT;\r\n    }\r\n\r\n    /**\r\n     * @method optimizeTrack\r\n     */\r\n    optimizeTrack( trackIdx: number )\r\n    {\r\n    }\r\n\r\n    /**\r\n     * @method optimizeTracks\r\n     */\r\n    optimizeTracks()\r\n    {\r\n    }\r\n\r\n    /**\r\n     * @param {Object} clip  clip to be added\r\n     * @param {Int} trackIdx ( optional ) track where to put the clip. -1 will find the first free slot. ***WARNING*** Must call getClipsInRange, before calling this function with a valid trackdIdx\r\n     * @param {Number} offsetTime ( optional ) offset time of current time\r\n     * @param {Number} searchStartTrackIdx ( optional ) if trackIdx is set to -1, this idx will be used as the starting point to find a valid track\r\n     * @returns  a zero/positive value if successful. Otherwise, -1\r\n     */\r\n    addClip( clip: any, trackIdx: number = -1, offsetTime: number = 0, searchStartTrackIdx: number = 0 )\r\n    {\r\n        if ( !this.animationClip ) return -1;\r\n\r\n        this.deselectAllElements(); // TODO: consider adjusting values of hovered and selected instead of deselecting everything\r\n\r\n        // Update clip information\r\n        let newStart = clip.start + offsetTime;\r\n        if ( clip.fadein != undefined ) clip.fadein += newStart - clip.start;\r\n        if ( clip.fadeout != undefined ) clip.fadeout += newStart - clip.start;\r\n        clip.start = newStart;\r\n\r\n        // sanity check\r\n        clip.active = clip.active ?? true;\r\n\r\n        // find appropriate track\r\n        if ( trackIdx >= this.animationClip.tracks.length )\r\n        { // new track ad the end\r\n            trackIdx = this.addNewTrack();\r\n        }\r\n        else if ( trackIdx < 0 )\r\n        { // find first free track slot\r\n            for ( let i = searchStartTrackIdx; i < this.animationClip.tracks.length; i++ )\r\n            {\r\n                let clipInCurrentSlot = this.animationClip.tracks[i].clips.find( ( t: any ) => {\r\n                    return LX.compareThresholdRange( newStart, clip.start + clip.duration, t.start, t.start + t.duration );\r\n                } );\r\n\r\n                if ( !clipInCurrentSlot )\r\n                {\r\n                    trackIdx = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if ( trackIdx < 0 )\r\n            {\r\n                trackIdx = this.addNewTrack();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // check specific track slot\r\n            // commented to avoid double checks with \"addclips\" fn\r\n            // let clipsInRange = this.getClipsInRange( this.animationClip.tracks[ trackIdx ], clip.start, clip.start+clip.duration, 0.0001 );\r\n            // if( clipsInRange ) {\r\n            //     return -1;\r\n            // }\r\n        }\r\n\r\n        clip.trackIdx = trackIdx;\r\n\r\n        const track = this.animationClip.tracks[trackIdx];\r\n\r\n        // Find new index\r\n        let newIdx = track.clips.findIndex( ( t: any ) => t.start > newStart );\r\n\r\n        // Add as last index\r\n        if ( newIdx < 0 )\r\n        {\r\n            newIdx = track.clips.length;\r\n        }\r\n\r\n        // Save track state before add the new clip\r\n        this.saveState( trackIdx );\r\n\r\n        // Add clip\r\n        track.clips.splice( newIdx, 0, clip ); // insert clip into newIdx ( or push at the end )\r\n\r\n        // Reset this clip's properties\r\n        track.hovered.splice( newIdx, 0, false );\r\n        track.selected.splice( newIdx, 0, false );\r\n        track.edited.splice( newIdx, 0, false );\r\n\r\n        if ( !this.animationClip || ( clip.start + clip.duration ) > this.duration )\r\n        {\r\n            this.setDuration( clip.start + clip.duration );\r\n        }\r\n\r\n        // Update animation action interpolation info\r\n        if ( this.onUpdateTrack )\r\n        {\r\n            this.onUpdateTrack( [ trackIdx ] );\r\n        }\r\n\r\n        return newIdx;\r\n    }\r\n\r\n    /**\r\n     *  Add an array of clips to the timeline in the first suitable tracks. It tries to put clips in the same track if possible. All clips will be in adjacent tracks to each other\r\n     * @param {Object[] } clips\r\n     * @param {Number} offsetTime\r\n     * @param {Int} searchStartTrackIdx\r\n     * @returns\r\n     */\r\n    addClips( clips: any[], offsetTime: number = 0, searchStartTrackIdx: number = 0 )\r\n    {\r\n        if ( !this.animationClip || !clips.length ) return false;\r\n\r\n        let clipTrackIdxs = new Int16Array( clips.length );\r\n        let baseTrackIdx = searchStartTrackIdx - 1; // every time the algorithm fails, it increments the starting track Idx\r\n        let currTrackIdx = -1;\r\n        const tracks = this.animationClip.tracks;\r\n        const lastTrackLength = tracks.length;\r\n        let c = 0;\r\n        for ( ; c < clips.length; ++c )\r\n        {\r\n            const clip = clips[c];\r\n            const clipStart = clip.start + offsetTime;\r\n            const clipEnd = clipStart + clip.duration;\r\n\r\n            if ( c == 0 )\r\n            { // last search failed, move one track down and check again\r\n                ++baseTrackIdx;\r\n                currTrackIdx = baseTrackIdx;\r\n\r\n                while ( currTrackIdx >= tracks.length ) this.addNewTrack( null, false );\r\n                let clipsInCurrentSlot = tracks[baseTrackIdx].clips.find( ( t: any ) => {\r\n                    return LX.compareThresholdRange( clipStart, clipEnd, t.start, t.start + t.duration );\r\n                } );\r\n\r\n                // reset search\r\n                if ( clipsInCurrentSlot )\r\n                {\r\n                    c = -1;\r\n                    continue;\r\n                }\r\n\r\n                // success\r\n                clipTrackIdxs[c] = baseTrackIdx;\r\n            }\r\n            else\r\n            {\r\n                // check if it fits in current track\r\n                let clipsInCurrentSlot = tracks[currTrackIdx].clips.find( ( t: any ) => {\r\n                    return LX.compareThresholdRange( clipStart, clipEnd, t.start, t.start + t.duration );\r\n                } );\r\n\r\n                // check no previous added clips are in the way\r\n                for ( let i = c - 1; i > -1; --i )\r\n                {\r\n                    if ( clipTrackIdxs[i] != currTrackIdx || clipsInCurrentSlot ) break;\r\n                    clipsInCurrentSlot = LX.compareThresholdRange( clipStart, clipEnd, clips[i].start + offsetTime,\r\n                        clips[i].start + offsetTime + clips[i].duration );\r\n                }\r\n\r\n                // check if it fits in the next track\r\n                if ( clipsInCurrentSlot )\r\n                {\r\n                    ++currTrackIdx;\r\n                    if ( currTrackIdx >= tracks.length ) this.addNewTrack( null, false );\r\n                    clipsInCurrentSlot = tracks[currTrackIdx].clips.find( ( t: any ) => {\r\n                        return LX.compareThresholdRange( clipStart, clipEnd, t.start, t.start + t.duration );\r\n                    } );\r\n                }\r\n\r\n                // reset search\r\n                if ( clipsInCurrentSlot )\r\n                {\r\n                    c = -1;\r\n                    continue;\r\n                }\r\n\r\n                // success\r\n                clipTrackIdxs[c] = currTrackIdx;\r\n            }\r\n        }\r\n\r\n        // avoid updating panel on each new track. Instead just once at the end\r\n        if ( lastTrackLength != tracks.length )\r\n        {\r\n            this.updateLeftPanel();\r\n        }\r\n\r\n        // save state for all to-be-modified tracks. Do it once for all tracks\r\n        for ( let i = baseTrackIdx; i <= currTrackIdx; ++i )\r\n        {\r\n            this.saveState( i, i != baseTrackIdx );\r\n        }\r\n\r\n        // disable history saving\r\n        let oldStateEnabler = this.historySaveEnabler;\r\n        this.historySaveEnabler = false;\r\n\r\n        for ( c = 0; c < clips.length; ++c )\r\n        {\r\n            this.addClip( clips[c], clipTrackIdxs[c], offsetTime );\r\n        }\r\n\r\n        // recover old state of enabler\r\n        this.historySaveEnabler = oldStateEnabler;\r\n\r\n        return true;\r\n    }\r\n\r\n    deleteSelectedContent( skipCallback: boolean = false )\r\n    {\r\n        // *********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n        if ( !this.lastClipsSelected.length )\r\n        {\r\n            return;\r\n        }\r\n\r\n        // delete selected clips from last to first. lastClipsSelected is sorted\r\n        const selected = this.lastClipsSelected;\r\n        this.lastClipsSelected = []; // so this.#delete does not check clipsselected on each loop ( all will be destroyed )\r\n        let prevTrack = -1;\r\n        for ( let i = selected.length - 1; i > -1; --i )\r\n        {\r\n            let s = selected[i];\r\n            if ( s[0] != prevTrack )\r\n            {\r\n                this.saveState( s[0], prevTrack != -1 );\r\n                prevTrack = s[0];\r\n            }\r\n\r\n            this.#delete( s[0], s[1] );\r\n        }\r\n\r\n        if ( this.onDeleteSelectedClips && !skipCallback )\r\n        {\r\n            this.onDeleteSelectedClips( selected );\r\n        }\r\n    }\r\n\r\n    /** Delete clip from the timeline\r\n     * @param {Number} trackIdx\r\n     * @param {Number} clipIdx clip to be deleted\r\n     */\r\n    deleteClip( trackIdx: number, clipIdx: number, skipCallback: boolean = false )\r\n    {\r\n        this.saveState( trackIdx );\r\n        const clip = this.#delete( trackIdx, clipIdx );\r\n\r\n        if ( this.onDeleteClip && !skipCallback )\r\n        {\r\n            this.onDeleteClip( trackIdx, clipIdx, clip );\r\n        }\r\n    }\r\n\r\n    #delete( trackIdx: number, clipIdx: number )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n\r\n        // remove from selected clips\r\n        for ( let i = 0; i < this.lastClipsSelected.length; i++ )\r\n        {\r\n            const [ selectedTrackIdx, selectedClipIdx ] = this.lastClipsSelected[i];\r\n            if ( selectedTrackIdx == trackIdx )\r\n            {\r\n                if ( selectedClipIdx == clipIdx )\r\n                { // remove self\r\n                    this.lastClipsSelected.splice( i--, 1 );\r\n                }\r\n                else if ( selectedClipIdx > clipIdx )\r\n                { // move upper clips to the left\r\n                    this.lastClipsSelected[i][1]--;\r\n                }\r\n            }\r\n            else if ( trackIdx < selectedTrackIdx )\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if ( this.lastHovered && this.lastHovered[0] == trackIdx )\r\n        {\r\n            if ( this.lastHovered[1] == clipIdx ) this.unHoverAll();\r\n            else if ( this.lastHovered[1] > clipIdx ) this.lastHovered[1]--;\r\n        }\r\n\r\n        const clip = track[clipIdx];\r\n        track.hovered.splice( clipIdx, 1 );\r\n        track.selected.splice( clipIdx, 1 );\r\n        track.edited.splice( clipIdx, 1 );\r\n        track.clips.splice( clipIdx, 1 );\r\n        return clip;\r\n    }\r\n\r\n    /**\r\n     * User defined. Used when copying and pasting\r\n     * @param {Array of clips } clipsToClone array of original clips. Do not modify clips in this array\r\n     * @param {Number} timeOffset Value of time that should be added ( or subtracted ) from the timing attributes\r\n     * @param {Int} reason Flag to signal the reason of the clone\r\n     * @returns {Array of clips }\r\n     */\r\n    cloneClips( clipsToClone: any[], timeOffset: number, reason: number = 0 )\r\n    {\r\n        let clipsToReturn = JSON.parse( JSON.stringify( clipsToClone ) );\r\n        for ( let i = 0; i < clipsToReturn.length; ++i )\r\n        {\r\n            let clip = clipsToReturn[i];\r\n            clip.start += timeOffset;\r\n            if ( clip.fadein == null || clip.fadein == undefined ) clip.fadein = undefined;\r\n            else clip.fadein += timeOffset;\r\n\r\n            if ( clip.fadeout == null || clip.fadeout == undefined ) clip.fadeout = undefined;\r\n            else clip.fadeout += timeOffset;\r\n        }\r\n\r\n        return clipsToReturn;\r\n    }\r\n\r\n    /**\r\n     * Overwrite the \"cloneClips\" function to provide a custom cloning of clips. Otherwise, JSON serialization is used\r\n     */\r\n    copySelectedContent()\r\n    {\r\n        if ( this.lastClipsSelected.length == 0 )\r\n        {\r\n            return;\r\n        }\r\n\r\n        let clipsToCopy: any = [];\r\n        const lastClipsSelected = this.lastClipsSelected;\r\n        const tracks = this.animationClip.tracks;\r\n        let globalStart = Infinity;\r\n        for ( let i = 0; i < lastClipsSelected.length; ++i )\r\n        {\r\n            let clip: any = tracks[lastClipsSelected[i][0]].clips[lastClipsSelected[i][1]];\r\n            clipsToCopy.push( clip );\r\n            if ( globalStart > clip.start ) globalStart = clip.start;\r\n        }\r\n\r\n        globalStart = Math.max( 0, globalStart );\r\n        this.clipboard = this.cloneClips( clipsToCopy, -globalStart, ClipsTimeline.CLONEREASON_COPY );\r\n    }\r\n\r\n    pasteContent( time: number = this.currentTime )\r\n    {\r\n        this.deselectAllClips();\r\n\r\n        if ( !this.clipboard )\r\n        {\r\n            return;\r\n        }\r\n\r\n        time = Math.max( 0, time );\r\n\r\n        let clipsToAdd = this.cloneClips( this.clipboard, time, ClipsTimeline.CLONEREASON_PASTE );\r\n        this.addClips( clipsToAdd, 0 );\r\n    }\r\n\r\n    /**\r\n     * @method clearTrack\r\n     */\r\n\r\n    clearTrack( trackIdx: number )\r\n    {\r\n        if ( !this.animationClip )\r\n        {\r\n            this.animationClip = { tracks: [] };\r\n            return;\r\n        }\r\n\r\n        this.saveState( trackIdx );\r\n\r\n        if ( this.animationClip.tracks[trackIdx].locked )\r\n        {\r\n            return;\r\n        }\r\n\r\n        const track = this.animationClip.tracks[trackIdx];\r\n        track.selected = [];\r\n        track.edited = [];\r\n        track.hovered = [];\r\n        track.clips = [];\r\n\r\n        // remove from selected clips\r\n        for ( let i = 0; i < this.lastClipsSelected.length; i++ )\r\n        {\r\n            const [ selectedTrackIdx, selectedClipIdx ] = this.lastClipsSelected[i];\r\n            if ( selectedTrackIdx == trackIdx )\r\n            {\r\n                this.lastClipsSelected.splice( i--, 1 );\r\n            }\r\n            else if ( trackIdx < selectedTrackIdx )\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if ( this.lastHovered && this.lastHovered[0] == trackIdx ) this.unHoverAll();\r\n\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * saveState function uses this to generate a \"copy\" of the track.\r\n     * @param {Number} trackIdx\r\n     * @returns All necessary information to reconstruct the track state\r\n     */\r\n    historyGenerateTrackStep( trackIdx: number )\r\n    {\r\n        const track = this.animationClip.tracks[trackIdx];\r\n        const clips = this.cloneClips( track.clips, 0, ClipsTimeline.CLONEREASON_HISTORY );\r\n\r\n        // sanity check in case cloneClips misses this\r\n        for ( let i = 0; i < clips.length; ++i )\r\n        {\r\n            clips[i].trackIdx = trackIdx;\r\n        }\r\n\r\n        const undoStep = {\r\n            trackIdx: trackIdx, // already done by saveState\r\n            clips: clips,\r\n            edited: track.edited.slice( 0, track.clips.length )\r\n        };\r\n\r\n        return undoStep;\r\n    }\r\n\r\n    /**\r\n     * It should swap the previous state with the incoming state of the track. It must return the previous state.\r\n     * historyGenerateTrackStep could be used to copy the previous state. However, as it is a swap, it suffices to just copy the references.\r\n     * @param {Object} state object with a trackIdx:Number and whatever information was saved in historyGenerateTrackStep\r\n     * @param {Boolean} isUndo\r\n     * @returns previous state object\r\n     */\r\n    historyApplyTrackStep( state: any, isUndo: boolean )\r\n    {\r\n        const track = this.animationClip.tracks[state.trackIdx];\r\n\r\n        const stateToReturn = {\r\n            trackIdx: state.trackIdx, // already done by saveState\r\n            clips: track.clips,\r\n            edited: track.edited\r\n        };\r\n\r\n        track.clips = state.clips;\r\n        track.edited = state.edited;\r\n        if ( track.selected.length < track.clips.length ) track.selected.length = track.clips.length;\r\n        if ( track.hovered.length < track.clips.length ) track.hovered.length = track.clips.length;\r\n        track.selected.fill( false );\r\n        track.hovered.fill( false );\r\n\r\n        // sanity check. Also done in addClip\r\n        for ( let i = 0; i < track.clips.length; ++i )\r\n        {\r\n            track.clips[i].active = track.clips[i].active ?? true;\r\n        }\r\n\r\n        return stateToReturn;\r\n    }\r\n\r\n    getClipOnTime( track: any, time: number, threshold: number )\r\n    {\r\n        if ( !track || !track.clips.length )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        // Avoid iterating through all timestamps\r\n        if ( ( time + threshold ) < track.clips[0].start )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        for ( let i = 0; i < track.clips.length; ++i )\r\n        {\r\n            let t = track.clips[i];\r\n            if ( t.start + t.duration >= ( time - threshold ) && t.start <= ( time + threshold ) )\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    deselectAllClips()\r\n    {\r\n        for ( let [ trackIdx, clipIdx ] of this.lastClipsSelected )\r\n        {\r\n            this.animationClip.tracks[trackIdx].selected[clipIdx] = false;\r\n        }\r\n\r\n        // Something has been deselected\r\n        const deselected = this.lastClipsSelected.length > 0;\r\n        this.lastClipsSelected.length = 0;\r\n        return deselected;\r\n    }\r\n\r\n    selectAll( skipCallback = false )\r\n    {\r\n        this.deselectAllClips();\r\n\r\n        for ( let trackIdx = 0; trackIdx < this.animationClip.tracks.length; trackIdx++ )\r\n        {\r\n            for ( let clipIdx = 0; clipIdx < this.animationClip.tracks[trackIdx].clips.length; clipIdx++ )\r\n            {\r\n                this.animationClip.tracks[trackIdx].selected[clipIdx] = true;\r\n                this.lastClipsSelected.push( [ trackIdx, clipIdx ] ); // already sorted\r\n            }\r\n        }\r\n\r\n        if ( this.onSelectClip && !skipCallback )\r\n        {\r\n            this.onSelectClip( null );\r\n        }\r\n    }\r\n\r\n    selectClip( trackIdx: number, clipIndex: number, deselect: boolean = true, skipCallback: boolean = false )\r\n    {\r\n        if ( deselect )\r\n        {\r\n            this.deselectAllClips();\r\n        }\r\n\r\n        if ( clipIndex < 0 )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        const track = this.animationClip.tracks[trackIdx];\r\n        if ( track.selected[clipIndex] )\r\n        {\r\n            return clipIndex;\r\n        }\r\n\r\n        // Select if not handled\r\n\r\n        // push selection sorted by track index and clip index\r\n        let i = 0;\r\n        for ( ; i < this.lastClipsSelected.length; ++i )\r\n        {\r\n            let t = this.lastClipsSelected[i];\r\n            if ( t[0] < track.trackIdx ) continue;\r\n            if ( t[0] > track.trackIdx || t[1] > clipIndex ) break;\r\n        }\r\n        this.lastClipsSelected.splice( i, 0, [ track.trackIdx, clipIndex, track.clips[clipIndex] ] ); //\r\n        track.selected[clipIndex] = true;\r\n\r\n        if ( !skipCallback && this.onSelectClip )\r\n        {\r\n            this.onSelectClip( track.clips[clipIndex] );\r\n            // Event handled\r\n        }\r\n        return clipIndex;\r\n    }\r\n\r\n    deselectClip( trackIdx: number, clipIndex: number )\r\n    {\r\n        if ( clipIndex == -1 )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        const track = this.animationClip.tracks[trackIdx];\r\n        if ( !track.selected[clipIndex] )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        track.selected[clipIndex] = false;\r\n\r\n        // deselect\r\n        for ( let i = 0; i < this.lastClipsSelected.length; ++i )\r\n        {\r\n            let t = this.lastClipsSelected[i];\r\n            if ( t[0] == trackIdx && t[1] == clipIndex )\r\n            {\r\n                this.lastClipsSelected.splice( i, 1 );\r\n                break;\r\n            }\r\n        }\r\n\r\n        return clipIndex;\r\n    }\r\n\r\n    getClipsInRange( track: any, minTime: number, maxTime: number, threshold: number = 0 )\r\n    {\r\n        if ( !track || !track.clips.length )\r\n        {\r\n            return null;\r\n        }\r\n\r\n        // Manage negative selection\r\n        if ( minTime > maxTime )\r\n        {\r\n            let aux = minTime;\r\n            minTime = maxTime;\r\n            maxTime = aux;\r\n        }\r\n\r\n        minTime -= threshold;\r\n        maxTime += threshold;\r\n\r\n        // Avoid iterating through all timestamps\r\n        minTime -= threshold;\r\n        maxTime += threshold;\r\n\r\n        const clips = track.clips;\r\n        if ( maxTime < clips[0].start\r\n            || minTime > ( clips[clips.length - 1].start + clips[clips.length - 1].duration ) )\r\n        {\r\n            return null;\r\n        }\r\n\r\n        let indices: number[] = [];\r\n\r\n        for ( let i = 0; i < clips.length; ++i )\r\n        {\r\n            const c = clips[i];\r\n            if ( c.start + c.duration < minTime ) continue;\r\n            if ( c.start > maxTime ) break;\r\n            indices.push( i );\r\n        }\r\n\r\n        return indices.length ? indices : null;\r\n    }\r\n\r\n    validateDuration( t: number )\r\n    {\r\n        for ( let i = 0; i < this.animationClip.tracks.length; i++ )\r\n        {\r\n            const track = this.animationClip.tracks[i];\r\n            if ( track.clips.length )\r\n            {\r\n                const clip = track.clips[track.clips.length - 1]; // assuming they are ordered ascendently\r\n                t = Math.max( t, clip.start + clip.duration );\r\n            }\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    setDuration( t: number, skipCallback: boolean = false, updateHeader: boolean = true )\r\n    {\r\n        const oldT = t;\r\n        const newT = this.validateDuration( t );\r\n        super.setDuration( newT, skipCallback, oldT != newT || updateHeader );\r\n    }\r\n}\r\n\r\nLX.ClipsTimeline = ClipsTimeline;\r\n\r\n/**\r\n * Draws a rounded rectangle using the current state of the canvas.\r\n * If you omit the last three params, it will draw a rectangle\r\n * outline with a 5 pixel border radius\r\n * @param {Number} x The top left x coordinate\r\n * @param {Number} y The top left y coordinate\r\n * @param {Number} width The width of the rectangle\r\n * @param {Number} height The height of the rectangle\r\n * @param {Number} [radius = 5] The corner radius; It can also be an object\r\n *                 to specify different radii for corners\r\n * @param {Number} [radius.tl = 0] Top left\r\n * @param {Number} [radius.tr = 0] Top right\r\n * @param {Number} [radius.br = 0] Bottom right\r\n * @param {Number} [radius.bl = 0] Bottom left\r\n * @param {Boolean} [ fill = false ] Whether to fill the rectangle.\r\n * @param {Boolean} [ stroke = true ] Whether to stroke the rectangle.\r\n */\r\n\r\nfunction drawRoundRect( ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: any = 5, fill: boolean = false,\r\n    stroke: boolean = false )\r\n{\r\n    if ( typeof radius === 'number' )\r\n    {\r\n        radius = { tl: radius, tr: radius, br: radius, bl: radius };\r\n    }\r\n    else\r\n    {\r\n        var defaultRadius: any = { tl: 0, tr: 0, br: 0, bl: 0 };\r\n        for ( var side in defaultRadius )\r\n        {\r\n            radius[side] = radius[side] ?? defaultRadius[side];\r\n        }\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo( x + radius.tl, y );\r\n    ctx.lineTo( x + width - radius.tr, y );\r\n    ctx.quadraticCurveTo( x + width, y, x + width, y + radius.tr );\r\n    ctx.lineTo( x + width, y + height - radius.br );\r\n    ctx.quadraticCurveTo( x + width, y + height, x + width - radius.br, y + height );\r\n    ctx.lineTo( x + radius.bl, y + height );\r\n    ctx.quadraticCurveTo( x, y + height, x, y + height - radius.bl );\r\n    ctx.lineTo( x, y + radius.tl );\r\n    ctx.quadraticCurveTo( x, y, x + radius.tl, y );\r\n    ctx.closePath();\r\n\r\n    if ( fill )\r\n    {\r\n        ctx.fill();\r\n    }\r\n\r\n    if ( stroke )\r\n    {\r\n        ctx.stroke();\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}