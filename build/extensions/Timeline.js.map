{"version":3,"file":"Timeline.js","sources":["../../src/extensions/Timeline.ts"],"sourcesContent":["// Timeline.ts @evallsg, @japopra\r\n\r\nimport { LX } from '../core/Namespace';\r\n\r\nif( !LX )\r\n{\r\n    throw( \"Missing LX namespace!\" );\r\n}\r\n\r\nLX.extensions.push( 'Timeline' );\r\n\r\nLX.registerIcon(\"TimelineLock\", '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path fill=\"none\" d=\"M7 11V7a4 4 0 0 1 9 0v4 M5,11h13 a2 2 0 0 1 2 2 v7 a2 2 0 0 1 -2 2 h-13 a2 2 0 0 1 -2 -2 v-7 a2 2 0 0 1 2 -2 M12 16 v2\"/></svg>' );\r\nLX.registerIcon(\"TimelineLockOpen\", '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path fill=\"none\" d=\"M14 11V7a4 4 0 0 1 9 0v2 M3,11h13 a2 2 0 0 1 2 2 v7 a2 2 0 0 1 -2 2 h-13 a2 2 0 0 1 -2 -2 v-7 a2 2 0 0 1 2 -2 M8 17 h3\"/></svg>' );\r\n\r\nconst Area = LX.Area;\r\nconst Panel = LX.Panel;\r\nconst Dialog = LX.Dialog;\r\nconst TreeEvent = LX.TreeEvent;\r\n\r\ntype Nullable<T> = T | null | undefined;\r\n\r\n/**\r\n * @class Timeline\r\n * @description Agnostic timeline, do not impose any timeline content. Renders to a canvas\r\n */\r\n\r\nexport abstract class Timeline\r\n{\r\n    static BACKGROUND_COLOR: string;\r\n    static TRACK_COLOR_PRIMARY: string;\r\n    static TRACK_COLOR_SECONDARY: string;\r\n    static TRACK_COLOR_TERCIARY: string;\r\n    static TRACK_COLOR_QUATERNARY: string;\r\n    static TRACK_SELECTED: string\r\n    static TRACK_SELECTED_LIGHT: string\r\n    static FONT: string;\r\n    static FONT_COLOR_PRIMARY: string;\r\n    static FONT_COLOR_TERTIARY: string;\r\n    static FONT_COLOR_QUATERNARY: string;\r\n    static KEYFRAME_COLOR: string;\r\n    static KEYFRAME_COLOR_HOVERED: string;\r\n    static KEYFRAME_COLOR_SELECTED: string;\r\n    static KEYFRAME_COLOR_LOCK: string;\r\n    static KEYFRAME_COLOR_EDITED: string;\r\n    static KEYFRAME_COLOR_INACTIVE: string;\r\n    static TIME_MARKER_COLOR: string\r\n    static TIME_MARKER_COLOR_TEXT: string\r\n    static BOX_SELECTION_COLOR: string\r\n\r\n    uniqueID: string;\r\n    timelineTitle: string;\r\n\r\n    animationClip: any;\r\n\r\n    duration: number = 1;\r\n    currentTime: number = 0; // seconds\r\n    visualTimeRange: [ number,number] = [0, 0]; // [ start time, end time ] - visible range of time. 0 <= time <= duration\r\n    visualOriginTime: number = 0; // time visible at pixel 0. -infinity < time < infinity\r\n    pixelsPerSecond: number = 300;\r\n    secondsPerPixel: number;\r\n\r\n    clickTime: number = 0; // real world time when mouse was pressed down. Used for discard\r\n    clickDiscardTimeout: number = 200; // ms\r\n    lastMouse: [ number,number] = [0, 0];\r\n    boxSelection: boolean = false;\r\n    boxSelectionStart: [ number, number] = [0, 0];\r\n    boxSelectionEnd: [ number, number] = [0, 0];\r\n\r\n    historyUndo: Array<any> = [];\r\n    historyRedo: Array<any> = [];\r\n    historySaveEnabler: boolean = true; // used in saveState\r\n    historyMaxSteps: number = 100; // used in saveState\r\n    clipboard: any = null;\r\n\r\n    grabbing: boolean = false;\r\n    grabTime: number = 0;\r\n    grabbingTimeBar: boolean = false;\r\n    grabbingScroll: boolean = false;\r\n    movingKeys: boolean = false;\r\n    timeBeforeMove: number = 0;\r\n\r\n    currentScroll: number = 0; //in percentage\r\n    currentScrollInPixels: number = 0; //in pixels\r\n    trackHeight: number = 32;\r\n    timeSeparators: number[] = [0.01, 0.1, 0.5, 1, 5];\r\n\r\n    playing: boolean = false;\r\n    loop: boolean = true;\r\n    active: boolean = true;\r\n    skipVisibility: boolean;\r\n    skipLock: boolean;\r\n    disableNewTracks: boolean;\r\n\r\n    optimizeThreshold: number = 0.01;\r\n\r\n    selectedTracks: any[] = []; // [ track, track] contains selected (highlighted ) tracks. That is, tracks with .isSelected == true. Elements in array are not ordered. Only visible tracks should be selected\r\n    selectedItems: any[] = []; // [ trackInfo, \"groupId\"], contains the visible items ( tracks or groups ) of the timeline\r\n    leftPanel: typeof Panel; // where tree will be placed\r\n    trackTreesPanel: any = null;\r\n    trackTreesComponent: any = null;\r\n    lastTrackTreesComponentOffset: any = 0; // this.trackTreesComponent.innerTree.domEl.offsetTop - canvas.offsetTop. Check draw()\r\n\r\n    mainArea: typeof Area;\r\n    root: HTMLBodyElement;\r\n    header: typeof Panel;\r\n    canvasArea: typeof Area; // parent of canvas\r\n    canvas: HTMLCanvasElement;\r\n    size: [ number, number] = [0.000001, 0.000001 ];\r\n    topMargin: number = 40;\r\n    header_offset: number = 48;\r\n\r\n    updateTheme: () => void;\r\n\r\n    onCreateBeforeTopBar: Nullable< ( headerPanel : typeof Panel ) => void > = null;\r\n    onCreateAfterTopBar: Nullable< ( headerPanel : typeof Panel ) => void > = null;\r\n    onCreateControlsButtons: Nullable< ( headerPanel : typeof Panel ) => void > = null;\r\n    onCreateSettingsButtons: Nullable< ( headerPanel : typeof Panel ) => void > = null;\r\n    onShowOptimizeMenu: Nullable< ( event: any ) => void > = null;\r\n    onShowConfiguration: Nullable< ( panel: typeof Panel ) => void > = null;\r\n    onMouse: Nullable< ( event: any, t: number ) => void > = null;\r\n    onDblClick: Nullable< ( event: any ) => void > = null;\r\n    onShowContextMenu: Nullable< ( event: any ) => void > = null;\r\n    onAddNewTrackButton: Nullable< () => void > = null; // overrides button \"add track\" behaviour\r\n    onAddNewTrack: Nullable< ( track: any, options: any ) => void > = null;\r\n    onTrackTreeEvent: Nullable< ( event: typeof TreeEvent ) => void > = null;\r\n    onBeforeDrawContent: Nullable< ( ctx: CanvasRenderingContext2D ) => void > = null;\r\n    onStateStop: Nullable< () => void > = null;\r\n    onStateChange: Nullable< ( s: boolean ) => void > = null;\r\n    onChangeLoopMode: Nullable< ( l: boolean ) => void > = null;\r\n    onSetDuration: Nullable< ( d: number ) => void > = null;\r\n    onSetTime: Nullable< ( t: number ) => void > = null;\r\n    onItemSelected: Nullable< ( selected: any[], itemsToAdd: Nullable< any[] >, itemsToRemove: Nullable< any[] >) => void > = null;\r\n    onSetTrackSelection: Nullable< ( track: object, oldValue: boolean ) => void > = null;\r\n    onSetTrackState: Nullable< ( track: object, oldValue: boolean ) => void > = null;\r\n    onSetTrackLock: Nullable< ( track: object, oldValue: boolean ) => void > = null;\r\n    onUpdateTrack: Nullable< ( tracks: number[] | string[] ) => void > = null;\r\n\r\n    configurationDialog: Nullable< typeof Dialog > = null;\r\n\r\n    abstract onMouseUp( event: any, t: number ): void;\r\n    abstract onMouseDown( event: any, t: number ): void;\r\n    abstract onMouseMove( event: any, t: number ): void;\r\n\r\n    abstract drawContent( ctx: CanvasRenderingContext2D ): void;\r\n    abstract deleteSelectedContent( skipCallback: boolean ): void;\r\n    abstract copySelectedContent(): void;\r\n    abstract pasteContent( time: number ): void;\r\n    abstract historyGenerateTrackStep( trackIdx: number ): any;\r\n    abstract historyApplyTrackStep( state: any, isUndo: boolean ): any;\r\n\r\n    /**\r\n     * @param {String} id = string unique id\r\n     * @param {Object} options = {skipLock, skipVisibility}\r\n     */\r\n    constructor( id : string, options: any = {} )\r\n    {\r\n        this.uniqueID = id ?? ( 'timeline' + Math.floor( Math.random()*0xffffffff ) );\r\n        this.timelineTitle = options.title ?? null;\r\n\r\n        // required before updateHeader\r\n        this.onCreateBeforeTopBar = options.onCreateBeforeTopBar;\r\n        this.onCreateAfterTopBar = options.onCreateAfterTopBar;\r\n        this.onCreateControlsButtons = options.onCreateControlsButtons;\r\n        this.onCreateSettingsButtons = options.onCreateSettingsButtons;\r\n        this.onShowOptimizeMenu = options.onShowOptimizeMenu;\r\n        this.onShowConfiguration = options.onShowConfiguration;\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.style.width = \"100%\";\r\n        this.canvas.style.height = \"100%\";\r\n\r\n        this.secondsPerPixel = 1 / this.pixelsPerSecond;\r\n        this.animationClip = this.instantiateAnimationClip();\r\n\r\n        this.loop = options.loop ?? true;\r\n        this.skipVisibility = options.skipVisibility ?? false;\r\n        this.skipLock = options.skipLock ?? false;\r\n        this.disableNewTracks = options.disableNewTracks ?? false;\r\n\r\n        // main area -- root\r\n        this.mainArea = new Area({className : 'lextimeline'} );\r\n        this.root = this.mainArea.root;\r\n        this.mainArea.split({ type: \"vertical\", sizes: [ this.header_offset, \"auto\"],  resize: false } );\r\n\r\n        // header\r\n        this.header = new Panel( { id: 'lextimelineheader'} );\r\n        this.mainArea.sections[ 0 ].attach( this.header );\r\n        this.updateHeader();\r\n\r\n        // content area\r\n        const contentArea = this.mainArea.sections[ 1 ];\r\n        contentArea.root.id = \"bottom-timeline-area\";\r\n        contentArea.split({ type: \"horizontal\", sizes: [\"15%\", \"85%\"] } );\r\n        let [ left, right ] = contentArea.sections;\r\n\r\n        right.attach( this.canvas );\r\n        this.canvasArea = right;\r\n        this.canvasArea.root.classList.add(\"lextimelinearea\");\r\n\r\n        this.leftPanel = left.addPanel( { className: 'lextimelinepanel', width: \"100%\", height: \"100%\" } );\r\n        this.updateLeftPanel();\r\n\r\n        if( this.uniqueID.length )\r\n        {\r\n            this.root.id = this.uniqueID;\r\n            this.canvas.id = this.uniqueID + '-canvas';\r\n        }\r\n\r\n        // Process mouse events\r\n        this.canvas.addEventListener( \"mousedown\", this.processMouse.bind( this ) );\r\n        this.canvas.addEventListener( \"mouseup\", this.processMouse.bind( this ) );\r\n        this.canvas.addEventListener( \"mousemove\", this.processMouse.bind( this ) );\r\n        this.canvas.addEventListener( \"wheel\", this.processMouse.bind( this ) );\r\n        this.canvas.addEventListener( \"dblclick\", this.processMouse.bind( this ) );\r\n        this.canvas.addEventListener( \"contextmenu\", this.processMouse.bind( this ) );\r\n\r\n        this.canvas.tabIndex = 1;\r\n        // Process keys events\r\n        this.canvasArea.root.addEventListener( \"keydown\", ( e: KeyboardEvent ) =>{ this.processKeys( e ); } ); // so this.processKeys can be overwritten by the user\r\n\r\n        this.canvasArea.onresize = (bounding : { width: number, height: number } ) =>\r\n        {\r\n            if( !( bounding.width && bounding.height ) )\r\n            {\r\n                return;\r\n            }\r\n\r\n            this.resizeCanvas();\r\n        }\r\n        this.resize( this.size );\r\n\r\n        /**\r\n         * updates theme ( light - dark ) based on LX's current theme\r\n         */\r\n        function updateTheme( )\r\n        {\r\n            Timeline.BACKGROUND_COLOR = LX.getThemeColor(\"global-blur-background\");\r\n            Timeline.TRACK_COLOR_PRIMARY = LX.getThemeColor(\"global-color-primary\");\r\n            Timeline.TRACK_COLOR_SECONDARY = LX.getThemeColor(\"global-color-secondary\");\r\n            Timeline.TRACK_COLOR_TERCIARY = LX.getThemeColor(\"global-color-terciary\");\r\n            Timeline.TRACK_COLOR_QUATERNARY = LX.getThemeColor(\"global-color-quaternary\");\r\n            Timeline.FONT = LX.getThemeColor(\"global-font\");\r\n            Timeline.FONT_COLOR_PRIMARY = LX.getThemeColor(\"global-text-primary\");\r\n            Timeline.FONT_COLOR_TERTIARY = LX.getThemeColor(\"global-text-tertiary\");\r\n            Timeline.FONT_COLOR_QUATERNARY = LX.getThemeColor(\"global-text-quaternary\");\r\n            Timeline.KEYFRAME_COLOR = LX.getThemeColor(\"lxTimeline-keyframe\");\r\n            Timeline.KEYFRAME_COLOR_SELECTED = Timeline.KEYFRAME_COLOR_HOVERED = LX.getThemeColor(\"lxTimeline-keyframe-selected\");\r\n            Timeline.KEYFRAME_COLOR_LOCK = LX.getThemeColor(\"lxTimeline-keyframe-locked\");\r\n            Timeline.KEYFRAME_COLOR_EDITED = LX.getThemeColor(\"lxTimeline-keyframe-edited\");\r\n            Timeline.KEYFRAME_COLOR_INACTIVE = LX.getThemeColor(\"lxTimeline-keyframe-inactive\");\r\n        }\r\n\r\n        this.updateTheme = updateTheme.bind( this );\r\n        LX.addSignal( \"@on_new_color_scheme\", this.updateTheme );\r\n    }\r\n\r\n    // makes it ready to be deleted\r\n    clear()\r\n    {\r\n        if( this.header )\r\n        {\r\n            this.header.clear();\r\n        }\r\n\r\n        if( this.leftPanel )\r\n        {\r\n            this.leftPanel.clear();\r\n        }\r\n\r\n        if( this.updateTheme )\r\n        {\r\n            let signals = LX.signals[ \"@on_new_color_scheme\" ] ?? [];\r\n            for( let i = 0; i < signals.length; ++i )\r\n            {\r\n                if( signals[ i ] == this.updateTheme )\r\n                {\r\n                    signals.splice( i, 1 );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method updateHeader\r\n     */\r\n    updateHeader()\r\n    {\r\n        this.header.clear();\r\n\r\n        const header = this.header;\r\n        header.sameLine();\r\n\r\n        if( this.timelineTitle )\r\n        {\r\n            header.addTitle( this.timelineTitle, { style: { background: \"none\", fontSize: \"18px\", fontStyle: \"bold\", alignItems: \"center\" } } );\r\n        }\r\n\r\n        const buttonContainer = LX.makeContainer( [\"auto\", \"100%\"], \"flex flex-row gap-1\" );\r\n\r\n        header.queue( buttonContainer );\r\n\r\n        const playbtn = header.addButton(\"playBtn\", '', ( value: any, event: Event ) => {\r\n           this.changeState();\r\n        }, { buttonClass: \"accept\", title: \"Play\", hideName: true, icon: \"Play@solid\", swap: \"Pause@solid\" } );\r\n        playbtn.setState( this.playing, true );\r\n\r\n        header.addButton(\"stopBtn\", '', ( value: any, event: Event ) => {\r\n            this.setState( false, true ); // skip callback of set state\r\n            if( this.onStateStop )\r\n            {\r\n                this.onStateStop();\r\n            }\r\n        }, { buttonClass: \"accept\", title: \"Stop\", hideName: true, icon: \"Stop@solid\" } );\r\n\r\n        header.addButton(\"loopBtn\", '', ( value: any, event: Event ) => {\r\n            this.setLoopMode( !this.loop );\r\n        }, { selectable: true, selected: this.loop, title: 'Loop', hideName: true, icon: \"RefreshCw\" } );\r\n\r\n        if( this.onCreateControlsButtons )\r\n        {\r\n            this.onCreateControlsButtons( header );\r\n        }\r\n\r\n        header.clearQueue( buttonContainer );\r\n        header.addContent( \"header-buttons\", buttonContainer );\r\n\r\n        // time number inputs - duration, current time, etc\r\n\r\n        if( this.onCreateBeforeTopBar )\r\n        {\r\n            this.onCreateBeforeTopBar( header );\r\n        }\r\n\r\n        header.addNumber(\"Current Time\", this.currentTime, ( value: number, event: Event ) => {\r\n            this.setTime( value );\r\n        }, {\r\n            units: \"s\",\r\n            step: 0.01, min: 0, precision: 3,\r\n            skipSlider: true,\r\n            skipReset: true,\r\n            nameWidth: \"auto\"\r\n        } );\r\n\r\n        header.addNumber(\"Duration\", + this.duration.toFixed(3), ( value: number, event: Event ) => {\r\n            this.setDuration( value, false, false );\r\n        }, {\r\n            units: \"s\",\r\n            step: 0.01, min: 0,\r\n            skipReset: true,\r\n            nameWidth: \"auto\"\r\n        } );\r\n\r\n        if( this.onCreateAfterTopBar )\r\n        {\r\n            this.onCreateAfterTopBar( header );\r\n        }\r\n\r\n        // settings buttons - optimize, settings, etc\r\n\r\n        const buttonContainerEnd = LX.makeContainer( [\"auto\", \"100%\"], \"flex flex-row gap-1\" );\r\n        header.queue( buttonContainerEnd );\r\n\r\n        if( this.onCreateSettingsButtons )\r\n        {\r\n            this.onCreateSettingsButtons( header );\r\n        }\r\n\r\n        if( this.onShowOptimizeMenu )\r\n        {\r\n            header.addButton( null, \"\", ( value: any, event: Event ) => {\r\n                if( this.onShowOptimizeMenu )\r\n                {\r\n                    this.onShowOptimizeMenu( event );\r\n                }\r\n            }, { tooltip: true, title: \"Optimize\", icon:\"Filter\" } );\r\n        }\r\n\r\n        if( this.onShowConfiguration )\r\n        {\r\n            header.addButton( null, \"\", ( value: any, event: Event ) => {\r\n                if( this.configurationDialog )\r\n                {\r\n                    this.configurationDialog.close();\r\n                    this.configurationDialog = null;\r\n                    return;\r\n                }\r\n                this.configurationDialog = new Dialog(\"Configuration\", ( p: typeof Panel ) => {\r\n                    if( this.onShowConfiguration )\r\n                    {\r\n                        this.onShowConfiguration( p );\r\n                    }\r\n                }, {\r\n                    onBeforeClose: () => {\r\n                        this.configurationDialog.panel.clear(); // clear signals\r\n                        this.configurationDialog = null;\r\n                    }\r\n                } )\r\n            }, { title: \"Settings\", icon: \"Settings\", tooltip: true } )\r\n        }\r\n\r\n        header.clearQueue( buttonContainerEnd );\r\n        header.addContent( \"header-buttons-end\", buttonContainerEnd );\r\n\r\n        header.endLine( \"justify-between\" );\r\n    }\r\n\r\n    /**\r\n    * @method updateLeftPanel\r\n    *\r\n    */\r\n    updateLeftPanel()\r\n    {\r\n        this.leftPanel.clear();\r\n\r\n        const panel = this.leftPanel;\r\n\r\n        panel.sameLine();\r\n        let titleComponent = panel.addTitle( \"Tracks\", { style: { background: \"none\"}, className: \"fg-secondary text-lg px-4\"} );\r\n        let title = titleComponent.root;\r\n\r\n        if( !this.disableNewTracks )\r\n        {\r\n            panel.addButton(\"addTrackBtn\", '', ( value: any, event: Event ) => {\r\n                if( this.onAddNewTrackButton )\r\n                {\r\n                    this.onAddNewTrackButton();\r\n                }\r\n                else\r\n                {\r\n                    this.addNewTrack();\r\n                }\r\n            }, { hideName: true, title: \"Add Track\", icon: \"Plus\" } );\r\n        }\r\n        panel.endLine();\r\n\r\n        const styles = window.getComputedStyle( title );\r\n        const titleHeight = title.clientHeight + parseFloat( styles['marginTop'] ) + parseFloat( styles['marginBottom'] );\r\n\r\n        let p = new LX.Panel({height: \"calc(100% - \" + titleHeight + \"px )\"} );\r\n\r\n        let treeTracks: any[] = [];\r\n        if( this.animationClip && this.selectedItems.length )\r\n        {\r\n            treeTracks = this.generateSelectedItemsTreeData();\r\n        }\r\n\r\n        this.trackTreesComponent = p.addTree( null, treeTracks, { filter: false, rename: false, draggable: false, onevent: ( e: typeof TreeEvent ) => {\r\n            switch( e.type )\r\n            {\r\n                case LX.TreeEvent.NODE_SELECTED:\r\n                    if( !e.event.shiftKey )\r\n                    {\r\n                        this.deselectAllTracks( false ); // no need to update left panel\r\n                    }\r\n                    if( e.node.trackData )\r\n                    {\r\n                        const flag = e.event.shiftKey? !e.node.trackData.isSelected : true;\r\n                        this.setTrackSelection( e.node.trackData.trackIdx, flag, false, false ); // do callback, do not update left panel\r\n                    }\r\n                    break;\r\n                case LX.TreeEvent.NODE_VISIBILITY:\r\n                    if( e.node.trackData )\r\n                    {\r\n                        this.setTrackState( e.node.trackData.trackIdx, e.value, false, false ); // do not update left panel\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            if( this.onTrackTreeEvent )\r\n            {\r\n                this.onTrackTreeEvent( e );\r\n            }\r\n        }} );\r\n\r\n        const that = this;\r\n        this.trackTreesComponent.innerTree._refresh = this.trackTreesComponent.innerTree.refresh;\r\n        this.trackTreesComponent.innerTree.refresh = function( newData: any, selectedId: Nullable< string > )\r\n        {\r\n            this._refresh( newData, selectedId );\r\n            that.setTrackHeight( that.trackHeight );\r\n        }\r\n\r\n        if( this.selectedTracks.length )\r\n        {\r\n            this._updateTrackTreeSelection(); // select visible tracks\r\n        }\r\n\r\n        // setting a name in the addTree function adds an undesired node\r\n        this.trackTreesComponent.name = \"tracksTrees\";\r\n        p.components[ this.trackTreesComponent.name ] = this.trackTreesComponent;\r\n\r\n        this.trackTreesPanel = p;\r\n        panel.attach( p.root );\r\n        p.root.addEventListener(\"scroll\", ( e: any ) => {\r\n            if( e.currentTarget.scrollHeight > e.currentTarget.clientHeight )\r\n            {\r\n                this.currentScroll = e.currentTarget.scrollTop / ( e.currentTarget.scrollHeight - e.currentTarget.clientHeight );\r\n                this.currentScrollInPixels = e.currentTarget.scrollTop;\r\n            }\r\n            else\r\n            {\r\n                this.currentScroll = 0;\r\n                this.currentScrollInPixels = 0;\r\n            }\r\n        } );\r\n\r\n        this.trackTreesPanel.root.scrollTop = this.currentScrollInPixels;\r\n        this.setTrackHeight( this.trackHeight );\r\n\r\n        if( this.leftPanel.parent.root.classList.contains(\"hidden\") || !this.root.parentElement )\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.resizeCanvas();\r\n\r\n        this.setScroll( this.currentScroll ); // avoid scroll bugs\r\n\r\n    }\r\n\r\n    setTrackHeight( trackHeight: number )\r\n    {\r\n        // ul list has a \"gap\" of 0.25rem. Compute pixel count of 0.25 rem\r\n        const gapSize = parseFloat( getComputedStyle( document.documentElement ).fontSize ) * 0.25;\r\n\r\n        this.trackHeight = trackHeight = Math.max( gapSize, trackHeight );\r\n\r\n        if( !this.trackTreesComponent )\r\n        {\r\n            return;\r\n        }\r\n\r\n        trackHeight -= gapSize;\r\n        const tracks = this.trackTreesComponent.root.querySelector( \"ul\" ).children;\r\n        for( let i = 0; i < tracks.length; ++i )\r\n        {\r\n            tracks[ i ].style.height = trackHeight + \"px\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Object} options options for the new track\r\n     *  { id: string, active: bool, locked: bool, }\r\n     * @returns\r\n     */\r\n    addNewTrack( options: any = {}, skipCallback: boolean = false )\r\n    {\r\n        const trackInfo = this.instantiateTrack( options );\r\n        trackInfo.trackIdx = this.animationClip.tracks.length;\r\n        this.animationClip.tracks.push( trackInfo );\r\n\r\n        if( this.onAddNewTrack && !skipCallback )\r\n        {\r\n            this.onAddNewTrack( trackInfo, options );\r\n        }\r\n\r\n        return trackInfo.trackIdx;\r\n    }\r\n\r\n    /**\r\n     * Finds tracks ( wholy and partially ) inside the range minY maxY.\r\n     * ( Full ) Canvas local coordinates.\r\n     * @param {Number} minY pixels\r\n     * @param {Number} maxY pixels\r\n     * @returns array of trackDatas\r\n     */\r\n    getTracksInRange( minY: number , maxY: number )\r\n    {\r\n        let tracks: any = [];\r\n\r\n        // Manage negative selection\r\n        if( minY > maxY )\r\n        {\r\n            let aux = minY;\r\n            minY = maxY;\r\n            maxY = aux;\r\n        }\r\n\r\n        const elements = this.getVisibleItems();\r\n        if( elements.length < 1 )\r\n        {\r\n            return [];\r\n        }\r\n\r\n        const startY = minY - this.lastTrackTreesComponentOffset + this.currentScrollInPixels;\r\n        const endY = maxY - this.lastTrackTreesComponentOffset + this.currentScrollInPixels;\r\n\r\n        const startIdx = Math.max( 0, Math.floor( startY / this.trackHeight ) );\r\n        const endIdx = Math.min( elements.length - 1, Math.floor( endY / this.trackHeight ) ) + 1;\r\n\r\n        for( let i = startIdx; i < endIdx; ++i )\r\n        {\r\n            const e = elements[ i ];\r\n            if( e.treeData && e.treeData.trackData )\r\n            {\r\n                tracks.push( e.treeData.trackData );\r\n            }\r\n        }\r\n\r\n        return tracks;\r\n    }\r\n\r\n    /**\r\n     * @method setAnimationClip\r\n     * @param {*} animation\r\n     * @param {Boolean} needsToProcess\r\n     * @param {Object} processOptions\r\n     * [ KeyFrameTimeline ] - each track should contain an attribute \"dim\" to indicate the value dimension ( e.g. vector3 -> dim=3). Otherwise dimensions will be infered from track's values and times. Default is 1\r\n     */\r\n    setAnimationClip( animation: any, needsToProcess: boolean = true )\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left panel yet\r\n\r\n        this.selectedItems = [];\r\n\r\n        this.clearState();\r\n\r\n        if( !animation || !animation.tracks || needsToProcess )\r\n        {\r\n            this.animationClip = this.instantiateAnimationClip( animation ); // generate default animationclip or process the user's one\r\n        }\r\n        else\r\n        {\r\n            this.animationClip = animation;\r\n        }\r\n\r\n        this.setDuration( this.animationClip.duration, true, true );\r\n\r\n        this.updateLeftPanel();\r\n\r\n        this.resize();\r\n\r\n        return this.animationClip;\r\n    }\r\n\r\n    drawTimeInfo( w: number, h: number = this.topMargin )\r\n    {\r\n        let ctx : any = this.canvas.getContext( \"2d\" );\r\n        ctx.font = \"11px \" + Timeline.FONT;//\"11px Calibri\";\r\n        ctx.textAlign = \"center\";\r\n\r\n        // Draw time markers\r\n        ctx.save();\r\n\r\n        // background of timeinfo\r\n        ctx.fillStyle = Timeline.BACKGROUND_COLOR;\r\n        ctx.fillRect( 0, 0, this.canvas.width, h );\r\n        ctx.strokeStyle = Timeline.FONT_COLOR_PRIMARY;\r\n\r\n        // set tick and sub tick times\r\n        let tickTime = 4;\r\n        if( this.pixelsPerSecond > 900 ) { tickTime = 1; }\r\n        else if( this.pixelsPerSecond > 100 ) { tickTime = 2; }\r\n        else if( this.pixelsPerSecond > 50 ) { tickTime = 3; }\r\n\r\n        let subtickTime = this.timeSeparators[ tickTime - 1 ];\r\n        tickTime = this.timeSeparators[ tickTime ];\r\n\r\n        const startTime = this.visualTimeRange[ 0 ];\r\n        const endTime = this.visualTimeRange[ 1 ];\r\n        // Transform times into pixel coords\r\n        let tickX = this.timeToX( startTime + tickTime ) - this.timeToX( startTime );\r\n        let subtickX = subtickTime * tickX / tickTime;\r\n\r\n        let startx = this.timeToX( Math.floor( startTime / tickTime ) * tickTime ); // floor because might need to draw previous subticks\r\n        startx += 0.0000001; // slight offset to avoid \"-0.0\"\r\n        let endx = this.timeToX( endTime ); // draw up to endTime\r\n\r\n        // Begin drawing\r\n        ctx.beginPath();\r\n        ctx.fillStyle = Timeline.FONT_COLOR_PRIMARY;\r\n        ctx.globalAlpha = 1;\r\n\r\n        for( let x = startx; x <= endx; x += tickX )\r\n        {\r\n            // Draw main line\r\n            ctx.moveTo( Math.round( x ) + 0.5, h * 0.4 + h * 0.3 );\r\n            ctx.lineTo( Math.round( x ) + 0.5, h * 0.95 );\r\n\r\n            // Draw following sub lines\r\n            let endsub = x + tickX - subtickX * 0.5;\r\n            for ( let subX = x; subX < endsub && subX < endx; subX += subtickX )\r\n            {\r\n                ctx.moveTo( Math.round( subX ) + 0.5, h * 0.4 + h * 0.45 );\r\n                ctx.lineTo( Math.round( subX ) + 0.5, h * 0.95 );\r\n            }\r\n\r\n            // Draw time number\r\n            let t = this.xToTime( x );\r\n            ctx.fillText( t.toFixed( tickTime < 1 ? 1 : 0 ), x, h * 0.6 );\r\n        }\r\n\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n\r\n    drawTracksBackground( w: number, h: number )\r\n    {\r\n        let canvas = this.canvas;\r\n        let ctx: any = canvas.getContext( \"2d\" );\r\n        let duration = this.duration;\r\n        ctx.globalAlpha = 1;\r\n\r\n        // Content\r\n        const topMargin = this.topMargin;\r\n        const treeOffset = this.lastTrackTreesComponentOffset;\r\n        const line_height = this.trackHeight;\r\n\r\n        //fill track lines\r\n        w = w || canvas.width;\r\n        let max_tracks = Math.ceil( ( h - topMargin ) / line_height ) + 1;\r\n\r\n        ctx.save();\r\n        ctx.fillStyle = Timeline.TRACK_COLOR_SECONDARY;\r\n\r\n        const rectsOffset = this.currentScrollInPixels % line_height;\r\n        const blackOrWhite = 1 - Math.floor( this.currentScrollInPixels / line_height ) % 2;\r\n        for( let i = blackOrWhite; i <= max_tracks; i += 2 )\r\n        {\r\n            ctx.fillRect( 0, treeOffset - rectsOffset + i * line_height, w, line_height );\r\n        }\r\n\r\n        //bg lines\r\n        ctx.strokeStyle = Timeline.TRACK_COLOR_TERCIARY;\r\n        ctx.beginPath();\r\n\r\n        let pos = this.timeToX( 0 );\r\n        if( pos < 0 ) { pos = 0; }\r\n        ctx.lineWidth = 1;\r\n        ctx.moveTo( pos + 0.5, topMargin );\r\n        ctx.lineTo( pos + 0.5, canvas.height );\r\n        ctx.moveTo( Math.round( this.timeToX( duration ) ) + 0.5, topMargin );\r\n        ctx.lineTo( Math.round( this.timeToX( duration ) ) + 0.5, canvas.height );\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * @method draw\r\n     */\r\n\r\n    draw()\r\n    {\r\n        let ctx: any = this.canvas.getContext( \"2d\" );\r\n        ctx.textBaseline = \"bottom\";\r\n        ctx.font = \"11px \" + Timeline.FONT;//\"11px Calibri\";\r\n        ctx.globalAlpha = 1;\r\n\r\n        const w = ctx.canvas.width;\r\n        const h = ctx.canvas.height;\r\n\r\n        const scrollableHeight = this.trackTreesComponent.root.scrollHeight;\r\n        // tree has gaps of 0.25rem (4px ) inbetween entries but not in the beginning nor ending. Move half gap upwards.\r\n        const treeOffset = this.lastTrackTreesComponentOffset = this.trackTreesComponent.innerTree.domEl.offsetTop - this.canvas.offsetTop - 2;\r\n\r\n        //zoom\r\n        let startTime = this.visualOriginTime; //seconds\r\n        startTime = Math.min( this.duration, Math.max( 0, startTime ) );\r\n        let endTime = this.visualOriginTime + w * this.secondsPerPixel; //seconds\r\n        endTime = Math.max( startTime, Math.min( this.duration, endTime ) );\r\n        this.visualTimeRange[ 0 ] = startTime;\r\n        this.visualTimeRange[ 1 ] = endTime;\r\n\r\n        // Background\r\n        ctx.globalAlpha = 1;\r\n        ctx.fillStyle = Timeline.TRACK_COLOR_SECONDARY;\r\n        ctx.clearRect( 0, 0, this.canvas.width, this.canvas.height );\r\n\r\n        this.drawTracksBackground( w, h );\r\n\r\n        if( this.onBeforeDrawContent )\r\n        {\r\n            this.onBeforeDrawContent( ctx );\r\n        }\r\n\r\n        if( this.animationClip )\r\n        {\r\n            ctx.translate( 0, treeOffset );\r\n            this.drawContent( ctx );\r\n            ctx.translate( 0, -treeOffset );\r\n        }\r\n\r\n        //scrollbar\r\n        if( ( h - this.topMargin ) < scrollableHeight )\r\n        {\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillRect( w - 10, 0, 10, h );\r\n\r\n            ctx.fillStyle = this.grabbingScroll ? Timeline.FONT_COLOR_TERTIARY : Timeline.FONT_COLOR_QUATERNARY;\r\n\r\n            let scrollBarHeight = Math.max( 10, (h-this.topMargin )* (h-this.topMargin )/ this.trackTreesPanel.root.scrollHeight );\r\n            let scrollLoc = this.currentScroll * ( h - this.topMargin - scrollBarHeight ) + this.topMargin;\r\n            drawRoundRect( ctx, w - 10, scrollLoc, 10, scrollBarHeight, 5, true );\r\n        }\r\n\r\n        this.drawTimeInfo( w );\r\n\r\n        // Current time marker vertical line\r\n        let posx = Math.round( this.timeToX( this.currentTime ) );\r\n        let posy = this.topMargin * 0.4;\r\n\r\n        if( posx >= 0 )\r\n        {\r\n            ctx.strokeStyle = ctx.fillStyle = Timeline.TIME_MARKER_COLOR;\r\n            ctx.globalAlpha = 1;\r\n            ctx.beginPath();\r\n            ctx.moveTo( posx, posy * 0.6 ); ctx.lineTo( posx, this.canvas.height );//line\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n            ctx.shadowBlur = 8;\r\n            ctx.shadowColor = Timeline.TIME_MARKER_COLOR;\r\n            ctx.shadowOffsetX = 1;\r\n            ctx.shadowOffsetY = 1;\r\n\r\n            drawRoundRect( ctx, posx - 10, posy * 0.6, 20, posy, 5, true );\r\n            ctx.fill();\r\n            ctx.shadowBlur = 0;\r\n            ctx.shadowOffsetX = 0;\r\n            ctx.shadowOffsetY = 0;\r\n        }\r\n\r\n        // Current time seconds in text\r\n        ctx.font = \"11px \" + Timeline.FONT;//\"11px Calibri\";\r\n        ctx.textAlign = \"center\";\r\n        //ctx.textBaseline = \"middle\";\r\n        ctx.fillStyle = Timeline.TIME_MARKER_COLOR_TEXT;\r\n        ctx.fillText( ( Math.floor( this.currentTime * 10 ) * 0.1 ).toFixed( 1 ), posx, this.topMargin * 0.6 );\r\n\r\n        // Selections\r\n        ctx.strokeStyle = ctx.fillStyle = Timeline.FONT_COLOR_PRIMARY;\r\n        if( this.boxSelection )\r\n        {\r\n            ctx.globalAlpha = 0.15;\r\n            ctx.fillStyle = Timeline.BOX_SELECTION_COLOR;\r\n            ctx.strokeRect( this.boxSelectionStart[ 0 ], this.boxSelectionStart[ 1 ], this.boxSelectionEnd[ 0 ] - this.boxSelectionStart[ 0 ], this.boxSelectionEnd[ 1 ] - this.boxSelectionStart[ 1 ] );\r\n            ctx.fillRect( this.boxSelectionStart[ 0 ], this.boxSelectionStart[ 1 ], this.boxSelectionEnd[ 0 ] - this.boxSelectionStart[ 0 ], this.boxSelectionEnd[ 1 ] - this.boxSelectionStart[ 1 ] );\r\n            ctx.stroke();\r\n            ctx.globalAlpha = 1;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @method clearState\r\n     */\r\n\r\n    clearState()\r\n    {\r\n        this.historyUndo = [];\r\n        this.historyRedo = [];\r\n    }\r\n\r\n    /**\r\n     * @method setDuration\r\n     * @param {Number} t\r\n     * @param {Boolean} skipCallback\r\n     * @param {Boolean} updateHeader\r\n     */\r\n    setDuration( t: number, skipCallback: boolean = false, updateHeader: boolean = true )\r\n    {\r\n        let v = Math.max( 0, t );\r\n        this.duration = this.animationClip.duration = v;\r\n\r\n        if( updateHeader )\r\n        {\r\n            this.header.components[\"Duration\"].set( +this.duration.toFixed(2 ), true ); // skipcallback = true\r\n        }\r\n\r\n        if( this.onSetDuration && !skipCallback )\r\n        {\r\n            this.onSetDuration( this.duration );\r\n        }\r\n    }\r\n\r\n    setTime( time: number, skipCallback: boolean = false )\r\n    {\r\n        this.currentTime = Math.max( 0, Math.min( time, this.duration ) );\r\n        this.header.components[\"Current Time\"].set( +this.currentTime.toFixed( 2 ), true ); // skipcallback = true\r\n\r\n        if( this.onSetTime && !skipCallback )\r\n        {\r\n            this.onSetTime( this.currentTime );\r\n        }\r\n    }\r\n\r\n    // Converts distance in pixels to time\r\n    xToTime( x: number )\r\n    {\r\n        return x * this.secondsPerPixel + this.visualOriginTime;\r\n    }\r\n\r\n    // Converts time to disance in pixels\r\n    timeToX( t: number )\r\n    {\r\n        return ( t - this.visualOriginTime ) * this.pixelsPerSecond;\r\n    }\r\n\r\n    /**\r\n     * @method setScale\r\n     * @param {*} pixelsPerSecond >0.  totalVisiblePixels / totalVisibleSeconds.\r\n     */\r\n\r\n    setScale( pixelsPerSecond: number )\r\n    {\r\n        const xCurrentTime = this.timeToX( this.currentTime );\r\n        this.pixelsPerSecond = pixelsPerSecond;\r\n        this.pixelsPerSecond = Math.max( 0.00001, this.pixelsPerSecond );\r\n\r\n        this.secondsPerPixel = 1 / this.pixelsPerSecond;\r\n        this.visualOriginTime += this.currentTime - this.xToTime( xCurrentTime );\r\n    }\r\n\r\n    /**\r\n     * @method setScroll\r\n     * not delta from last state, but full scroll amount.\r\n     * @param {Number} scrollY either pixels or [0,1 ]\r\n     * @param {Boolean} normalized if true, scrollY is in range[0,1 ] being 1 fully scrolled. Otherwised scrollY represents pixels\r\n     * @returns\r\n     */\r\n\r\n    setScroll( scrollY: number, normalized: boolean = true )\r\n    {\r\n        if( !this.trackTreesPanel )\r\n        {\r\n            this.currentScroll = 0;\r\n            this.currentScrollInPixels = 0;\r\n            return;\r\n        }\r\n\r\n        const r = this.trackTreesPanel.root;\r\n        if( r.scrollHeight > r.clientHeight )\r\n        {\r\n            if( normalized )\r\n            {\r\n                this.currentScroll = scrollY;\r\n                this.currentScrollInPixels = scrollY * ( r.scrollHeight - r.clientHeight );\r\n            }\r\n            else\r\n            {\r\n                this.currentScroll = scrollY / ( r.scrollHeight - r.clientHeight );\r\n                this.currentScrollInPixels = scrollY;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.currentScroll = 0;\r\n            this.currentScrollInPixels = 0;\r\n        }\r\n\r\n        // automatically calls event.\r\n        this.trackTreesPanel.root.scrollTop = this.currentScrollInPixels;\r\n\r\n    }\r\n\r\n    /**\r\n     * @method processMouse\r\n     * @param {*} e\r\n     */\r\n\r\n    processMouse( e: any /*MouseEvent*/ )\r\n    {\r\n        if( !this.canvas )\r\n        {\r\n            return;\r\n        }\r\n\r\n        let h = this.canvas.height;\r\n        let w = this.canvas.width;\r\n\r\n        // Process mouse\r\n        let x = e.offsetX;\r\n        let y = e.offsetY;\r\n        e.deltax = x - this.lastMouse[ 0 ];\r\n        e.deltay = y - this.lastMouse[ 1 ];\r\n        let localX = e.offsetX;\r\n        let localY = e.offsetY;\r\n\r\n        let timeX = this.timeToX( this.currentTime );\r\n        let isHoveringTimeBar = localY < this.topMargin &&\r\n                                localX > ( timeX - 6) && localX < ( timeX + 6);\r\n\r\n        const time = this.xToTime(x );\r\n\r\n        if( isHoveringTimeBar )\r\n        {\r\n            this.canvas.style.cursor = \"col-resize\";\r\n        }\r\n        else if( this.movingKeys )\r\n        {\r\n            this.canvas.style.cursor = \"grabbing\";\r\n        }\r\n        else if( e.shiftKey )\r\n        {\r\n            this.canvas.style.cursor = \"crosshair\";\r\n        }\r\n        else\r\n        {\r\n            this.canvas.style.cursor = \"default\";\r\n        }\r\n\r\n        if( e.type == \"wheel\" )\r\n        {\r\n            if( e.shiftKey )\r\n            {\r\n                if( e.wheelDelta )\r\n                {\r\n                    let mouseTime = this.xToTime( localX );\r\n                    this.setScale( this.pixelsPerSecond * ( e.wheelDelta < 0 ? 0.95 : 1.05) );\r\n                    this.visualOriginTime = mouseTime - localX * this.secondsPerPixel;\r\n                }\r\n\r\n            }\r\n            else if( ( h - this.topMargin ) < this.trackTreesComponent.root.scrollHeight )\r\n            {\r\n                this.trackTreesPanel.root.scrollTop += e.deltaY; // wheel deltaY\r\n            }\r\n\r\n            if( this.onMouse )\r\n            {\r\n                this.onMouse( e, time );\r\n            }\r\n            return;\r\n        }\r\n\r\n        const is_inside = x >= 0 && x <= this.size[ 0 ] &&\r\n                        y >= 0 && y <= this.size[ 1 ];\r\n\r\n        let track = this.getTracksInRange( localY, localY );\r\n        track = track.length ? track[ 0 ] : null;\r\n\r\n        e.track = track;\r\n        e.localX = localX;\r\n        e.localY = localY;\r\n\r\n        if( e.type == \"mouseup\" )\r\n        {\r\n            if( !this.active )\r\n            {\r\n                this.grabbing = false;\r\n                this.grabbingTimeBar = false;\r\n                this.grabbingScroll = false;\r\n                this.movingKeys = false;\r\n                this.timeBeforeMove = 0;\r\n                this.boxSelection = false;\r\n                return;\r\n            }\r\n\r\n            // this.canvas.style.cursor = \"default\";\r\n            const discard = this.movingKeys || ( LX.getTime() - this.clickTime ) > this.clickDiscardTimeout; // ms\r\n\r\n            e.discard = discard;\r\n\r\n            if( !this.grabbingScroll && !this.grabbingTimeBar && e.button == 0 && this.onMouseUp )\r\n            {\r\n                this.onMouseUp( e, time );\r\n            }\r\n\r\n            this.grabbing = false;\r\n            this.grabbingTimeBar = false;\r\n            this.grabbingScroll = false;\r\n            this.movingKeys = false;\r\n            this.timeBeforeMove = 0;\r\n            this.boxSelection = false; // after mouseup\r\n        }\r\n\r\n        if( e.type == \"mousedown\" )\r\n        {\r\n            window.getSelection()?.empty(); // if canvas DOM is selected, dragging does not work properly. Deselect it\r\n\r\n            // e.preventDefault();\r\n\r\n            this.clickTime = LX.getTime();\r\n\r\n            if( e.shiftKey && this.active )\r\n            {\r\n                this.boxSelection = true;\r\n                this.boxSelectionEnd[ 0 ] = this.boxSelectionStart[ 0 ] = localX;\r\n                this.boxSelectionEnd[ 1 ] = this.boxSelectionStart[ 1 ] = localY;\r\n                return; // Handled\r\n            }\r\n            else if( e.localY < this.topMargin )\r\n            {\r\n                this.grabbing = true;\r\n                this.grabbingTimeBar = true;\r\n                this.setTime( time );\r\n            }\r\n            else if( ( h - this.topMargin ) < this.trackTreesComponent.root.scrollHeight && x > w - 10 ) // grabbing scroll bar\r\n            {\r\n                this.grabbing = true;\r\n                this.grabbingScroll = true;\r\n            }\r\n            else // grabbing canvas\r\n            {\r\n                this.grabbing = true;\r\n                this.grabTime = time;\r\n                this.grabbingTimeBar = isHoveringTimeBar;\r\n                if( this.onMouseDown && this.active )\r\n                {\r\n                    this.onMouseDown( e, time );\r\n                }\r\n            }\r\n        }\r\n        else if( e.type == \"mousemove\" )\r\n        {\r\n            if( e.shiftKey && this.active && this.boxSelection )\r\n            {\r\n                this.boxSelectionEnd[ 0 ] = localX;\r\n                this.boxSelectionEnd[ 1 ] = localY;\r\n                return; // Handled\r\n            }\r\n            else if( this.grabbing && e.button !=2 && !this.movingKeys ) // e.buttons != 2 on mousemove needs to be plural\r\n            {\r\n                this.canvas.style.cursor = \"grabbing\";\r\n                if( this.grabbingTimeBar && this.active )\r\n                {\r\n                    this.setTime( time );\r\n                }\r\n                else if( this.grabbingScroll )\r\n                {\r\n                    // will automatically call scroll event\r\n                    if( y < this.topMargin )\r\n                    {\r\n                        this.trackTreesPanel.root.scrollTop = 0;\r\n                    }\r\n                    else\r\n                    {\r\n                        this.trackTreesPanel.root.scrollTop += this.trackTreesPanel.root.scrollHeight * e.deltay / ( h - this.topMargin );\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    // Move timeline in X ( independent of current time )\r\n                    var old = this.xToTime( this.lastMouse[ 0 ] );\r\n                    var now = this.xToTime( e.offsetX );\r\n                    this.visualOriginTime += ( old - now );\r\n                    this.trackTreesPanel.root.scrollTop -= e.deltay; // will automatically call scroll event\r\n                }\r\n            }\r\n\r\n            if( this.onMouseMove )\r\n            {\r\n                this.onMouseMove( e, time );\r\n            }\r\n        }\r\n        else if( e.type == \"dblclick\" && this.onDblClick )\r\n        {\r\n            this.onDblClick( e );\r\n        }\r\n        else if( e.type == \"contextmenu\" && this.onShowContextMenu && this.active )\r\n        {\r\n            this.onShowContextMenu( e );\r\n        }\r\n\r\n        this.lastMouse[ 0 ] = x;\r\n        this.lastMouse[ 1 ] = y;\r\n\r\n        if( !is_inside && !this.grabbing && !( e.metaKey || e.altKey ) )\r\n        {\r\n            return true;\r\n        }\r\n\r\n        if( this.onMouse )\r\n        {\r\n            this.onMouse( e, time );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * keydown\r\n     * @method processKeys\r\n     * @param {*} e\r\n     */\r\n    processKeys( e: KeyboardEvent )\r\n    {\r\n        switch( e.key )\r\n        {\r\n            case 'Delete':\r\n            case 'Backspace':\r\n                this.deleteSelectedContent( false );\r\n                break;\r\n            case 'c':\r\n            case 'C':\r\n                if( e.ctrlKey ) { this.copySelectedContent(); }\r\n                break;\r\n            case 'v':\r\n            case 'V':\r\n                if( e.ctrlKey ) { this.pasteContent( this.currentTime ); }\r\n                break;\r\n            case ' ':\r\n                e.preventDefault();\r\n                e.stopImmediatePropagation();\r\n                this.changeState();\r\n                break;\r\n\r\n            case \"Shift\":\r\n                this.canvas.style.cursor = \"crosshair\";\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method changeState\r\n     * @param {Boolean} skipCallback defaults false\r\n     * @description change play/pause state\r\n     **/\r\n    changeState( skipCallback = false )\r\n    {\r\n        this.setState( !this.playing, skipCallback );\r\n    }\r\n    /**\r\n     * @method setState\r\n     * @param {Boolean} state\r\n     * @param {Boolean} skipCallback defaults false\r\n     * @description change play/pause state\r\n     **/\r\n    setState( state: boolean, skipCallback: boolean = false )\r\n    {\r\n        this.playing = state;\r\n\r\n        this.header.components.playBtn.setState( this.playing, true );\r\n\r\n        if( this.onStateChange && !skipCallback )\r\n        {\r\n            this.onStateChange( this.playing );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method setLoopMode\r\n     * @param {Boolean} loopState\r\n     * @param {Boolean} skipCallback defaults false\r\n     * @description change loop mode of the timeline\r\n     */\r\n    setLoopMode( loopState: boolean, skipCallback: boolean = false )\r\n    {\r\n        this.loop = loopState;\r\n\r\n        if( this.loop )\r\n        {\r\n            this.header.components.loopBtn.root.children[ 0 ].classList.add(\"selected\");\r\n        }\r\n        else\r\n        {\r\n            this.header.components.loopBtn.root.children[ 0 ].classList.remove(\"selected\")\r\n        }\r\n\r\n        if( this.onChangeLoopMode && !skipCallback )\r\n        {\r\n            this.onChangeLoopMode( this.loop );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the tree elements ( tracks and grouops ) shown in the timeline.\r\n     *  Each item has { treeData: { trackData: track } }, where track is the actual track information of the animationClip.\r\n     *  If not a track, trackData will be undefined\r\n     */\r\n    getVisibleItems()\r\n    {\r\n        return this.trackTreesComponent.innerTree.domEl.children[ 0 ].children; // children of 'ul'\r\n    }\r\n\r\n    /**\r\n     * [ trackIdx ]\r\n     * @param {Array} itemsName array of numbers identifying tracks\r\n     */\r\n    setSelectedItems( items: any[], skipCallback: boolean = false )\r\n    {\r\n        this.selectedItems = [];\r\n        this.changeSelectedItems( items, null, skipCallback );\r\n    }\r\n\r\n    /**\r\n     * @param {Array} itemsToAdd [ trackIdx ], array of numbers identifying tracks by their index\r\n     * @param {Array} itemsToRemove [ trackIdx ], array of numbers identifying tracks by their index\r\n     */\r\n    changeSelectedItems( itemsToAdd: Nullable< any[] > = null, itemsToRemove: Nullable< any[] > = null, skipCallback: boolean = false )\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left panel. It is going to be rebuilt anyways\r\n\r\n        const tracks = this.animationClip.tracks;\r\n\r\n        if( itemsToRemove )\r\n        {\r\n            for( let i = 0; i < itemsToRemove.length; ++i )\r\n            {\r\n                const compareObj = itemsToRemove[ i ];\r\n                for( let s = 0; s < this.selectedItems.length; ++s )\r\n                {\r\n                    if( this.selectedItems[ s ] === compareObj )\r\n                    {\r\n                        this.selectedItems.splice( s, 1 );\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if( itemsToAdd )\r\n        {\r\n            for( let i = 0; i < itemsToAdd.length; ++i )\r\n            {\r\n                const v = itemsToAdd[ i ];\r\n                if( tracks[ v ] )\r\n                {\r\n                    this.selectedItems.push( tracks[ v ] );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateLeftPanel();\r\n\r\n        if( this.onItemSelected && !skipCallback )\r\n        {\r\n            this.onItemSelected( this.selectedItems, itemsToAdd, itemsToRemove );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * It will find the first occurrence of trackId in animationClip.tracks\r\n     * @param {String} trackId\r\n     * @returns\r\n     */\r\n    getTrack( trackId: string )\r\n    {\r\n        const tracks = this.animationClip.tracks;\r\n\r\n        for( let i = 0; i < tracks.length; ++i )\r\n        {\r\n            if( tracks[ i ].id == trackId )\r\n            {\r\n                return tracks[ i ];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @param {Boolean} updateTrackTree whether the track tree needs a refresh\r\n     * @returns\r\n     */\r\n    deselectAllTracks( updateTrackTree: boolean = true )\r\n    {\r\n        if( !this.animationClip )\r\n        {\r\n            return;\r\n        }\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        for( let i = 0; i < tracks.length; i++ )\r\n        {\r\n            tracks[ i ].isSelected = false;\r\n        }\r\n\r\n        this.selectedTracks.length = 0;\r\n\r\n        if( updateTrackTree )\r\n        {\r\n            this._updateTrackTreeSelection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Int} trackIdx\r\n     * @param {Boolean} isSelected new \"selected\" state of the track\r\n     * @param {Boolean} skipCallback whether to call onSetTrackSelection\r\n     * @param {Boolean} updateTrackTree whether track tree panel needs a refresh\r\n     * @returns\r\n     */\r\n    setTrackSelection( trackIdx: number, isSelected: boolean, skipCallback: boolean = false, updateTrackTree: boolean = true )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        const oldValue = track.isSelected;\r\n        track.isSelected = isSelected;\r\n\r\n        const idx = this.selectedTracks.indexOf( track );\r\n        if( ( idx == -1 && !isSelected ) || ( idx > -1 && isSelected ) )\r\n        {\r\n            return;\r\n        }\r\n\r\n        if( idx == -1 )\r\n        {\r\n            this.selectedTracks.push( track );\r\n        }\r\n        else\r\n        {\r\n            this.selectedTracks.splice( idx, 1 );\r\n        }\r\n\r\n        if( this.onSetTrackSelection && !skipCallback )\r\n        {\r\n            this.onSetTrackSelection( track, oldValue );\r\n        }\r\n\r\n        if( updateTrackTree )\r\n        {\r\n            this._updateTrackTreeSelection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * updates trackTreesComponent's nodes, to match the selectedTracks\r\n     */\r\n    _updateTrackTreeSelection()\r\n    {\r\n        const data = this.trackTreesComponent.innerTree.data;\r\n        const selected = this.trackTreesComponent.innerTree.selected;\r\n        selected.length = 0;\r\n\r\n        const addToSelection = ( nodes: any[] ) =>\r\n        {\r\n            for( let i = 0; i < nodes.length; ++i )\r\n            {\r\n                if( nodes[ i ].trackData && nodes[ i ].trackData.isSelected )\r\n                {\r\n                    selected.push( nodes[ i ] );\r\n                }\r\n\r\n                if( nodes[ i ].children )\r\n                {\r\n                    addToSelection( nodes[ i ].children );\r\n                }\r\n            }\r\n        }\r\n\r\n        // update innerTree ( visible ) selected nodes\r\n        if( this.selectedTracks.length )\r\n        {\r\n            addToSelection( data );\r\n        }\r\n\r\n        this.trackTreesComponent.innerTree.refresh();\r\n    }\r\n\r\n    deselectAllElements()\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n    * @method setTrackState\r\n    * @param {Int} trackIdx\r\n    * @param {Boolean} isEnbaled\r\n    * @param {Boolean} skipCallback onSetTrackState\r\n    * @param {Boolean} updateTrackTree updates eye icon of the track, if it is visible in the timeline\r\n    */\r\n    setTrackState( trackIdx: number, isEnbaled: boolean = true, skipCallback: boolean = false, updateTrackTree: boolean = true )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        const oldState = track.active;\r\n        track.active = isEnbaled;\r\n\r\n        if( this.onSetTrackState && !skipCallback )\r\n        {\r\n            this.onSetTrackState( track, oldState );\r\n        }\r\n\r\n        if( updateTrackTree && !this.skipVisibility )\r\n        {\r\n            // TODO: a bit of an overkill. Maybe searching the node in the tree is less expensive\r\n            this.updateLeftPanel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Int} trackIdx\r\n     * @param {Boolean} isLocked\r\n     * @param {Boolean} skipCallback onSetTrackLock\r\n     * @param {Boolean} updateTrackTree updates lock icon of the track, if it is visible in the timeline\r\n     */\r\n    setTrackLock( trackIdx: number, isLocked: boolean = false, skipCallback: boolean = false, updateTrackTree: boolean = true )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n        const oldState = track.locked;\r\n        track.locked = isLocked;\r\n\r\n        if( this.onSetTrackLock && !skipCallback )\r\n        {\r\n            this.onSetTrackLock( track, oldState );\r\n        }\r\n\r\n        if( updateTrackTree && !this.skipLock )\r\n        {\r\n            // TODO: a bit of an overkill. Maybe searching the node in the tree is less expensive\r\n            this.updateLeftPanel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Int} trackIdx index of track in the animation ( not local index )\r\n     * @param {Boolean} combineWithPrevious whether to create a new entry or unify changes into a single undo entry\r\n     */\r\n    saveState( trackIdx: number, combineWithPrevious: boolean = false )\r\n    {\r\n        if( !this.historySaveEnabler ) return;\r\n\r\n        const undoStep = this.historyGenerateTrackStep( trackIdx );\r\n        undoStep.trackIdx = trackIdx;\r\n\r\n        if( combineWithPrevious && this.historyUndo.length ) {\r\n            this.historyUndo[ this.historyUndo.length - 1 ].push( undoStep );\r\n        }\r\n        else\r\n        {\r\n            this.historyUndo.push( [ undoStep ] );\r\n        }\r\n\r\n        if( this.historyUndo.length > this.historyMaxSteps ) { this.historyUndo.shift(); } // remove first ( oldest ) element\r\n        this.historyRedo = [];\r\n    }\r\n\r\n    #undoRedo( isUndo = true )\r\n    {\r\n        let toBeShown = isUndo ? this.historyUndo : this.historyRedo;\r\n        let toBeStored = isUndo ? this.historyRedo : this.historyUndo;\r\n\r\n        if( !toBeShown.length ) return false;\r\n\r\n        this.deselectAllElements();\r\n\r\n        const combinedState = toBeShown.pop();\r\n        const combinedStateToStore: any = [];\r\n\r\n        for( let i = 0; i < combinedState.length; ++i )\r\n        {\r\n            const state = combinedState[ i ];\r\n            const trackIdx = state.trackIdx;\r\n\r\n            const stateToStore: any = this.historyApplyTrackStep( state, isUndo );\r\n            stateToStore.trackIdx = trackIdx;\r\n            combinedStateToStore.push( stateToStore );\r\n\r\n            // Update animation action interpolation info\r\n            if( this.onUpdateTrack )\r\n            {\r\n                this.onUpdateTrack( [ state.trackIdx ] );\r\n            }\r\n        }\r\n\r\n        toBeStored.push( combinedStateToStore );\r\n\r\n        return true;\r\n    }\r\n\r\n    undo() { return this.#undoRedo( true ); }\r\n    redo() { return this.#undoRedo( false ); }\r\n    // historyApplyTrackStep( state, isUndo ) MUST BE IMPLEMENTED BY CHILD CLASS\r\n    // historyGenerateTrackStep( trackIdx ) MUST BE IMPLEMENTED BY CHILD CLASS\r\n\r\n    /**\r\n     * @method resize\r\n     * @param {*} size\r\n     */\r\n    resize( size: Nullable< [ number, number ] > = null )\r\n    {\r\n        if( size )\r\n        {\r\n            this.size[ 0 ] = size[ 0 ];\r\n            this.size[ 1 ] = size[ 1 ];\r\n        }\r\n        else if( this.root.parentElement )\r\n        {\r\n            this.size[ 0 ] = this.root.parentElement.clientWidth;\r\n            this.size[ 1 ] = this.root.parentElement.clientHeight;\r\n        }\r\n\r\n        //this.content_area.setSize([ size[ 0 ], size[ 1 ] - this.header_offset] );\r\n        this.mainArea.sections[ 1 ].root.style.height = \"calc(100% - \"+ this.header_offset + \"px )\";\r\n\r\n        let w = this.size[ 0 ] - this.leftPanel.root.clientWidth - 8;\r\n        this.mainArea.sections[ 1 ]._update(); // update area's this.size attribute\r\n\r\n        this.resizeCanvas();\r\n    }\r\n\r\n    resizeCanvas()\r\n    {\r\n        this.canvas.width = this.canvasArea.root.clientWidth;\r\n        this.canvas.height = this.canvasArea.root.clientHeight;\r\n    }\r\n\r\n    /**\r\n    * @method hide\r\n    * Hide timeline area\r\n    */\r\n    hide()\r\n    {\r\n        this.mainArea.hide();\r\n    }\r\n\r\n    /**\r\n    * @method show\r\n    * Show timeline area if it is hidden\r\n    */\r\n    show()\r\n    {\r\n        this.mainArea.show();\r\n        this.resize();\r\n        this.updateLeftPanel();\r\n    }\r\n\r\n    // ----- BASE FUNCTIONS -----\r\n    /**\r\n        These functions might be overriden by child classes. Nonetheless, they must have the same attributes, at least.\r\n        Usually call a super.whateverFunction to generate its base form, and expand it with extra attributes\r\n    */\r\n\r\n    /**\r\n     * This functions uses the selectedItems and generates the data that will feed the LX.Tree Component.\r\n     * This function is used by updateLeftPanel. Some timelines might allow grouping of tracks. Such timelines may override this function\r\n     * WARNING: track entries MUST have an attribute of 'trackData' with the track info\r\n     * @returns lexgui tree data as expected for the creation of a LX.Tree\r\n     */\r\n    generateSelectedItemsTreeData(): any\r\n    {\r\n        const treeTracks: any[] = [];\r\n\r\n        for( let i = 0; i < this.selectedItems.length; i++ )\r\n        {\r\n            const track = this.selectedItems[ i ];\r\n            treeTracks.push({ trackData: track, id: track.id, skipVisibility: this.skipVisibility, visible: track.active, children: [], actions : this.skipLock ? null : [{\r\n                'name':'Lock edition',\r\n                'icon': ( track.locked ? 'TimelineLock' : 'TimelineLockOpen'),\r\n                'swap': ( track.locked ? 'TimelineLockOpen' : 'TimelineLock'),\r\n                'callback': ( node: any, swapValue: boolean, event: Event ) => {\r\n                    this.setTrackLock( node.trackData.trackIdx, !node.trackData.locked, false, false ); // do not update left panel\r\n                }\r\n            }] } );\r\n        }\r\n\r\n        return treeTracks;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Object} options set some values for the track instance ( groups and trackIdx not included )\r\n     * @returns\r\n     */\r\n    instantiateTrack( options: any = {}, clone: boolean = false )\r\n    {\r\n        return {\r\n            isTrack: true,\r\n            id: options.id ?? ( Math.floor( performance.now() ) + \"_\" + Math.floor( Math.random() * 0xffff ) ), //must be unique, at least inside a group\r\n            active: options.active ?? true,\r\n            locked: options.locked ?? false,\r\n            isSelected: false, // render and lexgui tree\r\n            trackIdx: -1,\r\n            data: options.data ?? null // user defined data\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates an animationClip using either the parameters set in the animation argument or using default values\r\n     * @param {Object} options data with which to generate an animationClip\r\n     * @param {Boolean} clone whether to clone clips or make a shallow copy\r\n     * @returns\r\n     */\r\n    instantiateAnimationClip( options : any = {}, clone: boolean = false )\r\n    {\r\n        const animationClip: any = {\r\n            id: options.id ?? ( options.name ?? \"animationClip\"),\r\n            duration: options.duration ?? 0,\r\n            tracks: [],\r\n            data: options.data ?? null, // user defined data\r\n        };\r\n\r\n        return animationClip;\r\n    }\r\n    // ----- END OF BASE FUNCTIONS -----\r\n};\r\n\r\nTimeline.BACKGROUND_COLOR = LX.getThemeColor(\"global-blur-background\");\r\nTimeline.TRACK_COLOR_PRIMARY = LX.getThemeColor(\"global-color-primary\");\r\nTimeline.TRACK_COLOR_SECONDARY = LX.getThemeColor(\"global-color-secondary\");\r\nTimeline.TRACK_COLOR_TERCIARY = LX.getThemeColor(\"global-color-terciary\");\r\nTimeline.TRACK_COLOR_QUATERNARY = LX.getThemeColor(\"global-color-quaternary\");\r\nTimeline.TRACK_SELECTED = LX.getThemeColor(\"global-color-accent\");\r\nTimeline.TRACK_SELECTED_LIGHT = LX.getThemeColor(\"global-color-accent-light\");\r\nTimeline.FONT = LX.getThemeColor(\"global-font\");\r\nTimeline.FONT_COLOR_PRIMARY = LX.getThemeColor(\"global-text-primary\");\r\nTimeline.FONT_COLOR_TERTIARY = LX.getThemeColor(\"global-text-tertiary\");\r\nTimeline.FONT_COLOR_QUATERNARY = LX.getThemeColor(\"global-text-quaternary\");\r\nTimeline.TIME_MARKER_COLOR = LX.getThemeColor(\"global-color-accent\");\r\nTimeline.TIME_MARKER_COLOR_TEXT = \"#ffffff\";\r\n\r\nLX.setThemeColor(\"lxTimeline-keyframe\", \"light-dark(#2d69da,#2d69da )\");\r\nLX.setThemeColor(\"lxTimeline-keyframe-selected\", \"light-dark(#f5c700,#fafa14)\");\r\nLX.setThemeColor(\"lxTimeline-keyframe-hovered\", \"light-dark(#f5c700,#fafa14)\");\r\nLX.setThemeColor(\"lxTimeline-keyframe-locked\", \"light-dark(#c62e2e,#ff7d7d )\");\r\nLX.setThemeColor(\"lxTimeline-keyframe-edited\", \"light-dark(#00d000,#00d000 )\");\r\nLX.setThemeColor(\"lxTimeline-keyframe-inactive\", \"light-dark(#706b6b,#706b6b)\");\r\nTimeline.KEYFRAME_COLOR = LX.getThemeColor(\"lxTimeline-keyframe\");\r\nTimeline.KEYFRAME_COLOR_SELECTED = Timeline.KEYFRAME_COLOR_HOVERED = LX.getThemeColor(\"lxTimeline-keyframe-selected\");\r\nTimeline.KEYFRAME_COLOR_LOCK = LX.getThemeColor(\"lxTimeline-keyframe-locked\");\r\nTimeline.KEYFRAME_COLOR_EDITED = LX.getThemeColor(\"lxTimeline-keyframe-edited\");\r\nTimeline.KEYFRAME_COLOR_INACTIVE =LX.getThemeColor(\"lxTimeline-keyframe-inactive\");\r\nTimeline.BOX_SELECTION_COLOR = \"#AAA\";\r\nLX.Timeline = Timeline;\r\n\r\n/**\r\n * @class KeyFramesTimeline\r\n */\r\n\r\nexport class KeyFramesTimeline extends Timeline\r\n{\r\n    static ADDKEY_VALUESINARRAYS = 0x01; // addkeyframes as [ [ k0v0, k0v1...], [ k1v0, k1v1...] ] instead of [ k0v0,k0v1,k1v0,k1v1 ]\r\n\r\n    lastKeyFramesSelected: any[];\r\n    keyValuePerPixel: number;\r\n    defaultCurves: boolean;\r\n    defaultCurvesRange: [ number, number];\r\n\r\n    keyframeSize: number;\r\n    keyframeSizeHovered: number;\r\n\r\n    lastHovered: Nullable< [ number, number] >= null;\r\n    moveKeyMinTime: number = 0;\r\n\r\n    onContentMoved: Nullable< ( trackIdx: number, keyIdx: number ) => void > = null;\r\n    onOptimizeTracks: Nullable< ( trackIdx: number ) => void > = null;\r\n    onDeleteKeyFrames: Nullable< ( trackIdx: number, indices: number[] ) => void > = null;\r\n    onSelectKeyFrame: Nullable< ( selection: [ number,number,number][] ) => void > = null;\r\n    onDeselectKeyFrames: Nullable< ( lastSelected: any[] )=> void > = null;\r\n\r\n    /**\r\n     * @param {String} name unique string\r\n     * @param {Object} options = {animationClip, selectedItems, x, y, width, height, canvas, trackHeight}\r\n     */\r\n    constructor( name: string, options: any = {} )\r\n    {\r\n        super( name, options );\r\n\r\n        this.lastKeyFramesSelected = [];\r\n\r\n        // curves --- track.dim == 1\r\n        this.keyValuePerPixel = 1/this.trackHeight; // used onMouseMove, vertical move only for dim==1. Normalized value movement / pixels\r\n        this.defaultCurves = true; // whn a track with dim == 1 has no curves attribute, defaultCurves will be used instead. If true, track is rendered using curves\r\n        this.defaultCurvesRange = [0,1 ]; // whn a track with dim == 1 has no curves attribute, defaultCurves will be used instead. If true, track is rendered using curves\r\n\r\n        this.keyframeSize = this.trackHeight * 0.5; // height of keyframe\r\n        this.keyframeSizeHovered = this.trackHeight * 0.5 + 5;\r\n\r\n        if( options.onShowOptimizeMenu && typeof options.onShowOptimizeMenu == \"boolean\" )\r\n        {\r\n            this.onShowOptimizeMenu = ( e: any ): void =>\r\n            {\r\n                if( this.selectedItems.length == 0 )\r\n                {\r\n                    return;\r\n                }\r\n\r\n                LX.addContextMenu(\"Optimize\", e, ( m: any ) =>\r\n                {\r\n                    this.selectedItems.forEach( item => {\r\n                        if( item.isTrack )\r\n                        {\r\n                            m.add( ( item.groupId ? item.groupId : \"\" ) + \"@\" + item.id, () => {\r\n                                this.optimizeTrack( item.trackIdx, false );\r\n                            } );\r\n                        }\r\n                        else\r\n                        {\r\n                            const tracks = this.animationClip.tracksPerGroup[ item ];\r\n                            for( let i = 0; i < tracks.length; ++i )\r\n                            {\r\n                                const t = tracks[ i ];\r\n                                m.add( ( t.groupId ? t.groupId : \"\" ) + \"@\" + t.id, () => {\r\n                                    this.optimizeTrack( t.trackIdx, false );\r\n                                } );\r\n                            }\r\n                        }\r\n                    } );\r\n                } );\r\n            }\r\n        }\r\n\r\n        this.onShowContextMenu = ( e: any ) =>\r\n        {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n\r\n            let actions: any = [];\r\n            if( this.lastKeyFramesSelected && this.lastKeyFramesSelected.length )\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: \"Copy\",\r\n                        callback: () => {\r\n                            this.copySelectedContent();\r\n                        }\r\n                    }\r\n                );\r\n                actions.push(\r\n                    {\r\n                        title: \"Delete\",\r\n                        callback: () => {\r\n                            this.deleteSelectedContent();\r\n                        }\r\n                    }\r\n                );\r\n\r\n                if( this.lastKeyFramesSelected.length == 1 && this.clipboard && this.clipboard.value )\r\n                {\r\n                    actions.push(\r\n                        {\r\n                            title: \"Paste Value\",\r\n                            callback: () => {\r\n                                this.pasteContentValue();\r\n                            }\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: \"Add Here\",\r\n                        callback: () => {\r\n                            if( !e.track ) return;\r\n                            const values: any = new Float32Array( e.track.dim );\r\n                            values.fill( 0 );\r\n                            this.addKeyFrames( e.track.trackIdx, values, [ this.xToTime( e.localX )] );\r\n                        }\r\n                    }\r\n                );\r\n                actions.push(\r\n                    {\r\n                        title: \"Add\",\r\n                        callback: () => {\r\n                            if( !e.track ) return;\r\n                            const values: any = new Float32Array( e.track.dim );\r\n                            values.fill( 0 );\r\n                            this.addKeyFrames( e.track.trackIdx, values, [ this.currentTime ] );\r\n                        }\r\n                    }\r\n                );\r\n\r\n            }\r\n\r\n            if( this.clipboard && this.clipboard.keyframes )\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: \"Paste Here\",\r\n                        callback: () => {\r\n                            this.pasteContent( this.xToTime( e.localX ) );\r\n                        }\r\n                    }\r\n                );\r\n                actions.push(\r\n                    {\r\n                        title: \"Paste\",\r\n                        callback: () => {\r\n                            this.pasteContent( this.currentTime );\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n\r\n            LX.addContextMenu(\"Options\", e, ( m: any ) => {\r\n                for( let i = 0; i < actions.length; i++ )  {\r\n                    m.add( actions[ i ].title,  actions[ i ].callback );\r\n                }\r\n            } );\r\n        } // end of onShowContextMenu\r\n\r\n        if( this.animationClip )\r\n        {\r\n            this.setAnimationClip( this.animationClip );\r\n        }\r\n    }\r\n\r\n    // OVERRIDE\r\n    generateSelectedItemsTreeData(): any\r\n    {\r\n        const treeTracks: any[] = [];\r\n        const tracksPerGroup = this.animationClip.tracksPerGroup;\r\n\r\n        for( let i = 0; i < this.selectedItems.length; i++ )\r\n        {\r\n            const item = this.selectedItems[ i ];\r\n            const isGroup = !item.isTrack;\r\n            const itemTracks = isGroup ? tracksPerGroup[ item ] : [ item ];\r\n            const nodes: any[] = [];\r\n\r\n            for( let j = 0; j < itemTracks.length; j++ )\r\n            {\r\n                const track = itemTracks[ j ];\r\n                nodes.push({'trackData': track, 'id': track.id, 'skipVisibility': this.skipVisibility, visible: track.active, 'children': [], actions : this.skipLock ? null : [{\r\n                    'name':'Lock edition',\r\n                    'icon': ( track.locked ? 'TimelineLock' : 'TimelineLockOpen'),\r\n                    'swap': ( track.locked ? 'TimelineLockOpen' : 'TimelineLock'),\r\n                    'callback': ( node: any, swapValue: boolean, event: Event ) => {\r\n                        this.setTrackLock( node.trackData.trackIdx, !node.trackData.locked, false, false ); // do not update left panel\r\n                    }\r\n                }] } );\r\n            }\r\n\r\n            if( isGroup )\r\n            {\r\n                const t = {\r\n                    'id': item,\r\n                    'skipVisibility': true,\r\n                    'children': nodes\r\n                };\r\n\r\n                treeTracks.push( t );\r\n            }\r\n            else\r\n            {\r\n                treeTracks.push( nodes[ 0 ] );\r\n            }\r\n        }\r\n\r\n        return treeTracks;\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE\r\n     * @param {Object} options track information that wants to be set to the new track\r\n     *  id, dim, values, times, selected, edited, hovered\r\n     * @returns\r\n     */\r\n    instantiateTrack( options: any = {}, clone: boolean = false )\r\n    {\r\n        const track : any = super.instantiateTrack( options );\r\n        track.dim = Math.max( 1, options.dim ?? 1 ); // >= 1\r\n        track.groupId = null,\r\n        track.groupTrackIdx = -1, // track Idx inside group only if in group\r\n\r\n        track.values = new Float32Array( 0 );\r\n        track.times = new Float32Array( 0 );\r\n        track.selected = [];\r\n        track.edited = [];\r\n        track.hovered = [];\r\n\r\n        if( options.values && options.times )\r\n        {\r\n            track.values = clone ? options.values.slice() : options.values;\r\n            track.times = clone ? options.times.slice() : options.times;\r\n\r\n            const numFrames = track.times.length;\r\n            if( options.selected && options.selected.length == numFrames )\r\n            {\r\n                track.selected = clone ? options.selected.slice() : options.selected;\r\n            }\r\n            else\r\n            {\r\n                track.selected = ( new Array( numFrames ) ).fill( false );\r\n            }\r\n\r\n            if( options.edited && options.edited.length == numFrames )\r\n            {\r\n                track.edited = clone ? options.edited.slice() : options.edited;\r\n            }\r\n            else\r\n            {\r\n                track.edited = ( new Array( numFrames ) ).fill( false );\r\n            }\r\n\r\n            if( options.hovered && options.hovered.length == numFrames )\r\n            {\r\n                track.hovered = clone ? options.hovered.slice() : options.hovered;\r\n            }\r\n            else\r\n            {\r\n                track.hovered = ( new Array( numFrames ) ).fill( false );\r\n            }\r\n        }\r\n\r\n        track.curves = options.curves ?? this.defaultCurves; // only works if dim == 1\r\n        track.curvesRange = ( options.curvesRange ?? this.defaultCurvesRange ).slice();\r\n\r\n        return track;\r\n    }\r\n\r\n    /**\r\n     * Generates an animationClip using either the parameters set in the animation argument or using default values\r\n     * @param {Object} animation data with which to generate an animationClip\r\n     * @returns\r\n     */\r\n    instantiateAnimationClip( animation: Nullable< any >, clone: boolean = false )\r\n    {\r\n        const animationClip: any = super.instantiateAnimationClip( animation, clone );\r\n\r\n        animationClip.tracksPerGroup = {};\r\n\r\n        if( animation && animation.tracks )\r\n        {\r\n            const tracksPerGroup: any = {};\r\n            let duration = 0;\r\n            for( let i = 0; i < animation.tracks.length; ++i ) {\r\n\r\n                let track = animation.tracks[ i ];\r\n                let times = track.times ?? [];\r\n                let values = track.values ?? [];\r\n\r\n                let valueDim = track.dim;\r\n                if( !valueDim || valueDim < 0 ) {\r\n                    if( times.length && values.length ) { valueDim = Math.round( values.length/times.length ); }\r\n                    else\r\n                    { valueDim = 1; }\r\n                }\r\n\r\n                let baseName = track.id ?? track.name;\r\n                const [groupId, trackId] = baseName ? this._getValidTrackName(baseName ) : [ null, null];\r\n\r\n                const toInstantiate = Object.assign({}, track );\r\n                toInstantiate.id = trackId;\r\n                toInstantiate.dim = valueDim;\r\n                const trackInfo = this.instantiateTrack( toInstantiate, clone );\r\n\r\n                // manual group insertion\r\n                if( groupId )\r\n                {\r\n                    if( !tracksPerGroup[ groupId ] )\r\n                    {\r\n                        tracksPerGroup[ groupId ] = [ trackInfo ];\r\n                    }\r\n                    else\r\n                    {\r\n                        tracksPerGroup[ groupId ].push( trackInfo );\r\n                    }\r\n\r\n                    trackInfo.groupId = groupId;\r\n                    trackInfo.groupTrackIdx = tracksPerGroup[ groupId ].length - 1; // index of track in group\r\n                }\r\n\r\n                trackInfo.trackIdx = i; // index of track in the entire animation\r\n\r\n                animationClip.tracks.push( trackInfo );\r\n\r\n                if( trackInfo.times.length ) { duration = Math.max( duration, trackInfo.times[ trackInfo.times.length - 1 ] ); }\r\n            }\r\n\r\n            animationClip.tracksPerGroup = tracksPerGroup;\r\n            if( !animation || !animation.duration )\r\n            {\r\n                animationClip.duration = duration;\r\n            }\r\n\r\n            // overwrite trackspergroup\r\n            if( animation.tracksPerGroup )\r\n            {\r\n                // ungroup all tracks (just in case )\r\n                animationClip.tracks.forEach( ( v: any,i: number ) =>{ v.groupId = null; v.groupTrackIdx = -1; } );\r\n\r\n                animationClip.tracksPerGroup = {};\r\n                let tpg = animation.tracksPerGroup;\r\n                for( let groupId in tpg )\r\n                {\r\n                    const source = tpg[ groupId ];\r\n                    const target: any[] = [];\r\n                    for( let ti = 0; ti < source.length; ++ti )\r\n                    {\r\n                        const trackInfo = animationClip.tracks[ source[ ti ].trackIdx ]; // redo references\r\n                        target[ ti ] = trackInfo;\r\n                        trackInfo.groupId = groupId;\r\n                        trackInfo.groupTrackIdx = ti; // index of track in group\r\n                    }\r\n                    animationClip.tracksPerGroup[ groupId ] = target;\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationClip;\r\n    }\r\n\r\n    // OVERRIDE\r\n    deselectAllElements()\r\n    {\r\n        this.deselectAllKeyFrames();\r\n        this.unHoverAll();\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE\r\n     * @param {Array} itemsToAdd [ trackIdx, \"groupId\" ], array of strings and/or number identifying groups and/or tracks\r\n     * @param {Array} itemsToRemove [ trackIdx, \"groupId\" ], array of strings and/or number identifying groups and/or tracks\r\n     */\r\n    changeSelectedItems( itemsToAdd: Nullable<any[]> = null, itemsToRemove: Nullable<any[]> = null, skipCallback: boolean = false )\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left panel. It is going to be rebuilt anyways\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        const tracksPerGroup = this.animationClip.tracksPerGroup;\r\n\r\n        if( itemsToRemove )\r\n        {\r\n            for( let i = 0; i < itemsToRemove.length; ++i )\r\n            {\r\n                const isGroup: boolean = !!itemsToRemove[ i ].substr;\r\n                let compareObj = isGroup ? itemsToRemove[ i ] : tracks[ itemsToRemove[ i ]]; // trackData or groupId\r\n                for( let s = 0; s < this.selectedItems.length; ++s )\r\n                {\r\n                    if( this.selectedItems[ s ] === compareObj )\r\n                    {\r\n                        const size = isGroup ? tracksPerGroup[ compareObj ].length : 1;\r\n                        this.selectedItems.splice( s, size );\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if( itemsToAdd )\r\n        {\r\n            for( let i = 0; i < itemsToAdd.length; ++i )\r\n            {\r\n                const v = itemsToAdd[ i ];\r\n                if( isNaN( v) ) // assuming it is a string\r\n                {\r\n                    if( tracksPerGroup[ v ] )\r\n                    {\r\n                        this.selectedItems.push( v );\r\n                    }\r\n                }\r\n                else if( tracks[ v ] )\r\n                {\r\n                    this.selectedItems.push( tracks[ v ] );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateLeftPanel();\r\n\r\n        if( this.onItemSelected && !skipCallback )\r\n        {\r\n            this.onItemSelected( this.selectedItems, itemsToAdd, itemsToRemove );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {String} groupId unique identifier\r\n     * @param {Array} groupTracks [ \"trackID\", trackIdx ] array of strings and/or numbers of the existing tracks to include in this group. A track can only be part of 1 group\r\n     *  if groupTracks == null, groupId is removed from the list\r\n     */\r\n    setTracksGroup( groupId: string, groupTracks: Nullable< ( string | number )[] > = null )\r\n    {\r\n        const tracks = this.animationClip.tracks;\r\n        const tracksPerGroup = this.animationClip.tracksPerGroup;\r\n        const result: any = [];\r\n\r\n        let selectedItemsCounter = -1;\r\n\r\n        if( tracksPerGroup[ groupId ] )\r\n        {\r\n            // if group exists, ungroup tracks.\r\n            tracksPerGroup[ groupId ].forEach( ( t: any )=> {\r\n                t.groupId = null;\r\n                t.groupTrackIdx = -1;\r\n            } );\r\n\r\n            // modify groups cannot appear more than once\r\n            for( let i = 0; i < this.selectedItems.length; ++i ) {\r\n                if( this.selectedItems[ i ] === groupId ) {\r\n                    selectedItemsCounter = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if( !groupTracks )\r\n        {\r\n            delete tracksPerGroup.groupId;\r\n            // remove entry from selectedItems\r\n            if( selectedItemsCounter > -1 ) {\r\n                this.selectedItems.splice( selectedItemsCounter, 1 );\r\n            }\r\n            return;\r\n        }\r\n\r\n        // find tracks and group them\r\n        for ( let i = 0; i < groupTracks.length; ++i )\r\n        {\r\n            const v = groupTracks[ i ];\r\n            let track: any = null;\r\n            if( typeof v == \"string\" )\r\n            {\r\n                // v is an id  ( string)\r\n                for( let t = 0; t < tracks.length; ++t )\r\n                {\r\n                    if( tracks[ t ].id == v)\r\n                    {\r\n                        track = tracks[ t ];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else if( tracks[ v ] )\r\n            {\r\n                track = tracks[ v ];\r\n            }\r\n\r\n            if( track )\r\n            {\r\n                track.groupId = groupId;\r\n                track.groupTrackIdx = result.length;\r\n                result.push( track );\r\n            }\r\n        }\r\n\r\n        tracksPerGroup[ groupId ] = result;\r\n\r\n        // if group is currently visible\r\n        if( selectedItemsCounter > -1 )\r\n        {\r\n            this.updateLeftPanel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {String} groupId\r\n     * @returns array of tracks or null\r\n     */\r\n    getTracksGroup( groupId: string ): any[] | null\r\n    {\r\n        return this.animationClip.tracksPerGroup[ groupId ] ?? null;\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE\r\n     * @param {String} trackId\r\n     * @param {String} groupId optionl. If not set, it will find the first occurrence of trackId in animationClip.tracks\r\n     * @returns\r\n     */\r\n    getTrack( trackId: string, groupId: Nullable< string > = null )\r\n    {\r\n        let tracks = this.animationClip.tracks;\r\n        if( groupId )\r\n        {\r\n            tracks = this.animationClip.tracksPerGroup[ groupId ] ?? [];\r\n        }\r\n\r\n        for( let i = 0; i < tracks.length; ++i )\r\n        {\r\n            if( tracks[ i ].id == trackId )\r\n            {\r\n                return tracks[ i ];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Number} size pixels, height of keyframe\r\n     * @param {Number} sizeHovered optional, size in pixels when hovered\r\n     */\r\n    setKeyframeSize( size: number, sizeHovered: Nullable< number > = null )\r\n    {\r\n        this.keyframeSizeHovered = sizeHovered ?? size;\r\n        this.keyframeSize = size;\r\n    }\r\n\r\n    onMouseUp( e: any, time: number )\r\n    {\r\n        let track = e.track;\r\n        let localX = e.localX;\r\n        let discard = e.discard; // true when too much time has passed between Down and Up\r\n\r\n        if( e.shiftKey )\r\n        {\r\n            // Manual multiple selection\r\n            if( !discard && track )\r\n            {\r\n                const thresholdPixels = this.keyframeSize * 0.5; // radius of circle ( curves ) or rotated square (keyframes )\r\n                const keyFrameIdx = this.getCurrentKeyFrame( track, this.xToTime( localX ), this.secondsPerPixel * thresholdPixels );\r\n                if( keyFrameIdx > -1 ) {\r\n                    track.selected[ keyFrameIdx ] ?\r\n                        this.deselectKeyFrame( track.trackIdx, keyFrameIdx ) :\r\n                        this.processSelectionKeyFrame( track.trackIdx, keyFrameIdx, true );\r\n                }\r\n            }\r\n            // Box selection\r\n            else if( this.boxSelection )\r\n            {\r\n                let tracks = this.getTracksInRange( this.boxSelectionStart[ 1 ], this.boxSelectionEnd[ 1 ] );\r\n\r\n                for( let t of tracks )\r\n                {\r\n                    let keyFrameIndices = this.getKeyFramesInRange( t,\r\n                        this.xToTime( this.boxSelectionStart[ 0 ] ),\r\n                        this.xToTime( this.boxSelectionEnd[ 0 ] ),\r\n                        this.secondsPerPixel * 5 );\r\n\r\n                    if( keyFrameIndices )\r\n                    {\r\n                        for( let index = keyFrameIndices[ 0 ]; index <= keyFrameIndices[ 1 ]; ++index )\r\n                        {\r\n                            this.processSelectionKeyFrame( t.trackIdx, index, true );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if( !this.movingKeys && !discard ) // if not moving timeline and not adding keyframes through e.shiftkey (just a click )\r\n        {\r\n            if( this.lastKeyFramesSelected.length )\r\n            {\r\n                if( this.onDeselectKeyFrames )\r\n                {\r\n                    this.onDeselectKeyFrames( this.lastKeyFramesSelected );\r\n                }\r\n\r\n                this.deselectAllKeyFrames();\r\n            }\r\n\r\n            if( track )\r\n            {\r\n                const thresholdPixels = this.keyframeSize * 0.5; // radius of circle ( curves ) or rotated square (keyframes )\r\n                const keyFrameIndex = this.getCurrentKeyFrame( track, this.xToTime( localX ), this.secondsPerPixel * thresholdPixels );\r\n                if( keyFrameIndex > -1 )\r\n                {\r\n                    this.processSelectionKeyFrame( track.trackIdx, keyFrameIndex, false ); // Settings this as multiple so time is not being set\r\n                }\r\n            }\r\n        }\r\n\r\n        this.canvas.classList.remove( 'grabbing' );\r\n    }\r\n\r\n    onMouseDown( e: any, time: number )\r\n    {\r\n        // function not called if shift is pressed (boxselection )\r\n\r\n        let localX = e.localX;\r\n        let localY = e.localY;\r\n        let track = e.track;\r\n\r\n        if( ( e.ctrlKey || e.altKey ) && this.lastKeyFramesSelected.length ) // move keyframes\r\n        {\r\n            this.movingKeys = true;\r\n            this.canvas.style.cursor = \"grab\";\r\n            this.canvas.classList.add('grabbing');\r\n\r\n            // Set pre-move state\r\n            this.moveKeyMinTime = Infinity;\r\n            const tracks = this.animationClip.tracks;\r\n            let lastTrackIdx = -1;\r\n            for( let selectedKey of this.lastKeyFramesSelected ) // WARNING assumes lasKeyFramesSelected is sorted, so all keyframes of the same track are grouped\r\n            {\r\n                let [ trackIdx, keyIndex, keyTime ] = selectedKey;\r\n                const track = tracks[ trackIdx ];\r\n\r\n                selectedKey[ 2 ] = track.times[ keyIndex ]; // update original time just in case\r\n\r\n                if( lastTrackIdx != trackIdx )\r\n                {\r\n                    // save track states only once\r\n                    if( this.moveKeyMinTime < Infinity )\r\n                    {\r\n                        this.saveState( track.trackIdx, true );\r\n                    }\r\n                    else\r\n                    {\r\n                        this.saveState( track.trackIdx, false );\r\n                    }\r\n\r\n                    this.moveKeyMinTime = Math.min( this.moveKeyMinTime, selectedKey[ 2 ] );\r\n                    lastTrackIdx = trackIdx;\r\n                }\r\n            }\r\n\r\n            this.timeBeforeMove = this.xToTime( localX );\r\n\r\n            this.grabbing = false;\r\n            this.grabbingTimeBar = false;\r\n        }\r\n    }\r\n\r\n    onMouseMove( e: any, time: number )\r\n    {\r\n        // function not called if shift is pressed (boxselection )\r\n\r\n        let localX = e.localX;\r\n        let localY = e.localY;\r\n        let track = e.track;\r\n\r\n        if( this.movingKeys ) // move keyframes\r\n        {\r\n            let newTime = this.xToTime( localX );\r\n            let deltaTime = newTime - this.timeBeforeMove;\r\n\r\n            if( deltaTime + this.moveKeyMinTime < 0 )\r\n            {\r\n                deltaTime = -this.moveKeyMinTime;\r\n            }\r\n\r\n            this.timeBeforeMove = this.timeBeforeMove + deltaTime;\r\n\r\n            if( e.ctrlKey )\r\n            {\r\n                this.moveKeyMinTime += deltaTime;\r\n                const tracks = this.animationClip.tracks;\r\n                for( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n                {\r\n                    let idx = i;\r\n                    if( deltaTime > 0 ) {\r\n                        idx = this.lastKeyFramesSelected.length - 1 - i;\r\n                    }\r\n\r\n                    const [ trackIdx, keyIndex, originalKeyTime ] = this.lastKeyFramesSelected[ idx ];\r\n                    track = tracks[ trackIdx ];\r\n\r\n                    if( track && track.locked )\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    this.canvas.style.cursor = \"grabbing\";\r\n\r\n                    const times = this.animationClip.tracks[ track.trackIdx ].times;\r\n                    times[ keyIndex ] = Math.max( 0, times[ keyIndex ] + deltaTime );\r\n\r\n                    if( times[ keyIndex ] > this.duration )\r\n                    {\r\n                        this.setDuration( times[ keyIndex ] );\r\n                    }\r\n\r\n                    // sort keyframe\r\n                    let k = keyIndex;\r\n                    if( deltaTime > 0 )\r\n                    {\r\n                        for( ; k < times.length - 1; ++k )\r\n                        {\r\n                            if( times[ k ] < times[ k + 1 ] )\r\n                            {\r\n                                break;\r\n                            }\r\n\r\n                            this.swapKeyFrames( track, k + 1, k );\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        for( ; k > 0; --k )\r\n                        {\r\n                            if( times[ k - 1 ] < times[ k ] ) {\r\n                                break;\r\n                            }\r\n                            this.swapKeyFrames( track, k-1, k );\r\n                        }\r\n                    }\r\n                    this.lastKeyFramesSelected[ idx ][ 1 ] = k; // update keyframe index\r\n                    this.lastKeyFramesSelected[ idx ][ 2 ] = times[ k ]; // update keyframe time\r\n                }\r\n\r\n                if( this.onContentMoved )\r\n                {\r\n                    for( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n                    {\r\n                        const [ trackIdx, keyIndex, originalKeyTime ] = this.lastKeyFramesSelected[ i ];\r\n                        track = this.animationClip.tracks[ trackIdx ];\r\n                        if( track && track.locked )\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        this.onContentMoved( trackIdx, keyIndex );\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Track.dim == 1:  move keyframes vertically ( change values instead of time )\r\n            // RELIES ON SORTED ARRAY OF lastKeyFramesSelected\r\n            if( e.altKey && e.buttons & 0x01 )\r\n            {\r\n                const tracks = this.animationClip.tracks;\r\n                let lastTrackChanged = -1;\r\n                for( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n                {\r\n                    const [ trackIdx, keyIndex, originalKeyTime ] = this.lastKeyFramesSelected[ i ];\r\n                    track = tracks[ trackIdx ];\r\n                    if( track.locked || track.dim != 1 || !track.curves )\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    let value = track.values[ keyIndex ];\r\n                    let delta = e.deltay * this.keyValuePerPixel * ( track.curvesRange[ 1 ]-track.curvesRange[ 0 ] );\r\n                    track.values[ keyIndex ] = Math.max( track.curvesRange[ 0 ], Math.min( track.curvesRange[ 1 ], value - delta )); // invert delta because of screen y\r\n                    track.edited[ keyIndex ] = true;\r\n\r\n                    if( this.onUpdateTrack && track.trackIdx != lastTrackChanged && lastTrackChanged > -1 ) { // do it only once all keyframes of the same track have been modified\r\n                        this.onUpdateTrack( [ track.trackIdx ] );\r\n                    }\r\n                    lastTrackChanged = track.trackIdx;\r\n                }\r\n                if( this.onUpdateTrack && lastTrackChanged > -1 ) // do the last update, once the last track has been processed\r\n                {\r\n                    this.onUpdateTrack( [ track.trackIdx ] );\r\n                }\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        if( this.grabbing && e.button != 2 )\r\n        {\r\n\r\n        }\r\n        else if( track )\r\n        {\r\n            this.unHoverAll();\r\n            const thresholdPixels = this.keyframeSize * 0.5; // radius of circle ( curves ) or rotated square (keyframes )\r\n            let keyFrameIndex = this.getCurrentKeyFrame( track, this.xToTime( localX ), this.secondsPerPixel * thresholdPixels );\r\n\r\n            if( keyFrameIndex > -1 )\r\n            {\r\n                if( track && track.locked )\r\n                {\r\n                    return;\r\n                }\r\n\r\n                this.lastHovered = [ track.trackIdx, keyFrameIndex ];\r\n                track.hovered[ keyFrameIndex ] = true;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.unHoverAll();\r\n        }\r\n    }\r\n\r\n    drawContent( ctx: CanvasRenderingContext2D )\r\n    {\r\n        if( !this.animationClip )\r\n        {\r\n            return;\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        const trackHeight = this.trackHeight;\r\n        const scrollY = - this.currentScrollInPixels;\r\n\r\n        // elements from \"ul\" should match the visible tracks ( and groups ) as if this.selectedItems was flattened\r\n        const visibleElements = this.getVisibleItems();\r\n\r\n        let offset = scrollY;\r\n\r\n        // compute track from which to start rendering ( avoid rendering unseen tracks )\r\n        let startElIdx = 0;\r\n        if( offset < -this.lastTrackTreesComponentOffset ) // offset 0 = ( 0 of canvas ) + track-Tree-Offset. This renders tracks under the time zone\r\n        {\r\n            startElIdx = Math.floor( -( offset + this.lastTrackTreesComponentOffset ) / this.trackHeight ); // how many tracks to skip\r\n            offset += startElIdx * this.trackHeight;\r\n        }\r\n\r\n        ctx.translate( 0, offset );\r\n\r\n        // compute track to end rendering ( avoid rendering unseen tracks )\r\n        let endElIdx = startElIdx + Math.ceil( ( ctx.canvas.height - this.lastTrackTreesComponentOffset - offset ) / this.trackHeight );\r\n        endElIdx = endElIdx > visibleElements.length ? visibleElements.length : endElIdx;\r\n\r\n        for( let t = startElIdx; t < endElIdx; t++ )\r\n        {\r\n            const track = visibleElements[ t ].treeData.trackData;\r\n            if( track )\r\n            {\r\n                if( track.dim == 1 && track.curves )\r\n                {\r\n                    this.drawTrackWithCurves( ctx, trackHeight, track );\r\n                }\r\n                else\r\n                {\r\n                    this.drawTrackWithKeyframes( ctx, trackHeight, track );\r\n                }\r\n            }\r\n\r\n            ctx.translate( 0, trackHeight );\r\n        }\r\n\r\n        ctx.restore();\r\n    };\r\n\r\n    /**\r\n     * @method drawTrackWithKeyframes\r\n     * @param {*} ctx\r\n     * ...\r\n     * @description helper function, you can call it from drawContent to render all the keyframes\r\n    */\r\n    drawTrackWithKeyframes( ctx: CanvasRenderingContext2D, trackHeight: number, track: any ) {\r\n\r\n        if( track.isSelected ) {\r\n            ctx.globalAlpha = 0.2;\r\n            ctx.fillStyle = Timeline.TRACK_SELECTED;\r\n            ctx.fillRect( 0, 0, ctx.canvas.width, trackHeight );\r\n        }\r\n\r\n        ctx.fillStyle = Timeline.KEYFRAME_COLOR;\r\n        ctx.globalAlpha = 1;\r\n\r\n        const keyframes = track.times;\r\n        const startTime = this.visualTimeRange[ 0 ];\r\n        const endTime = this.visualTimeRange[ 1 ] + 0.0000001;\r\n        const defaultPointSize = this.keyframeSize / Math.SQRT2; // pythagoras with equal sides h2 = c2 + c2 = 2 * c2\r\n        const hoverPointSize = this.keyframeSizeHovered / Math.SQRT2;\r\n\r\n        for( let j = 0; j < keyframes.length; ++j )\r\n        {\r\n            let time = keyframes[ j ];\r\n            if( time < startTime || time > endTime ) {\r\n                continue;\r\n            }\r\n\r\n            let keyframePosX = this.timeToX( time );\r\n            let size = defaultPointSize;\r\n\r\n            if( !this.active || track.active == false ) {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_INACTIVE;\r\n            }\r\n            else if( track.locked ) {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_LOCK;\r\n            }\r\n            else if( track.hovered[ j ] ) {\r\n                size = hoverPointSize;\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_HOVERED;\r\n            }\r\n            else if( track.selected[ j ] ) {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_SELECTED;\r\n            }\r\n            else if( track.edited[ j ] ) {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_EDITED;\r\n            }\r\n            else {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR;\r\n            }\r\n\r\n            ctx.save();\r\n            ctx.translate(keyframePosX, trackHeight * 0.5);\r\n            ctx.rotate(45 * Math.PI / 180 );\r\n            ctx.fillRect( -size*0.5, -size*0.5, size, size );\r\n            ctx.restore();\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n    }\r\n\r\n    drawTrackWithCurves ( ctx: CanvasRenderingContext2D, trackHeight: number, track: any ) {\r\n        if( track.isSelected ) {\r\n            ctx.globalAlpha = 0.2;\r\n            ctx.fillStyle = Timeline.TRACK_SELECTED_LIGHT;\r\n            ctx.fillRect( 0, 0, ctx.canvas.width, trackHeight );\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n        const keyframes = track.times;\r\n        const values = track.values;\r\n        const defaultPointSize = this.keyframeSize * 0.5; // radius\r\n        const hoverPointSize = this.keyframeSizeHovered * 0.5; // radius\r\n        const valueRange = track.curvesRange; //[ min, max ]\r\n        const displayRange = trackHeight - defaultPointSize * 2;\r\n        const startTime = this.visualTimeRange[ 0 ];\r\n        const endTime = this.visualTimeRange[ 1 ] + 0.0000001;\r\n        //draw lines\r\n        ctx.strokeStyle = KeyFramesTimeline.FONT_COLOR_PRIMARY;\r\n        ctx.beginPath();\r\n\r\n        if( keyframes.length > 1 ) {\r\n            let startPosX = this.timeToX( keyframes[ 0 ] );\r\n            let startValue = values[ 0 ];\r\n            startValue = LX.clamp( ( startValue - valueRange[ 0 ] ) / ( valueRange[ 1 ] - valueRange[ 0 ] ), 0,1 ) * (-displayRange ) + ( trackHeight - defaultPointSize ); // normalize and offset\r\n            ctx.moveTo( startPosX, startValue );\r\n\r\n            for( let j = 1; j < keyframes.length; ++j ) {\r\n\r\n                let time = keyframes[ j ];\r\n                let keyframePosX = this.timeToX( time );\r\n                let value = values[ j ];\r\n                value = LX.clamp( ( value - valueRange[ 0 ] ) / ( valueRange[ 1 ] - valueRange[ 0 ] ), 0,1 ) * (-displayRange ) + ( trackHeight - defaultPointSize ); // normalize and offset\r\n\r\n                if( time < startTime ) {\r\n                    ctx.moveTo( keyframePosX, value );\r\n                    continue;\r\n                }\r\n\r\n                if( time > endTime ) {\r\n                    let lastKeyframePosX = this.timeToX( keyframes[j-1 ] );\r\n                    let dt = keyframePosX - lastKeyframePosX;\r\n                    if( dt > 0 ) {\r\n                        let lastValue = values[j-1 ];\r\n                        lastValue = LX.clamp( ( lastValue - valueRange[ 0 ] ) / ( valueRange[ 1 ] - valueRange[ 0 ] ), 0,1 ) * (-displayRange ) + ( trackHeight - defaultPointSize ); // normalize and offset\r\n                        let f = ( this.timeToX( endTime ) - lastKeyframePosX ) / dt;\r\n                        ctx.lineTo( lastKeyframePosX + dt * f, lastValue * (1-f ) + value * f );\r\n                    }\r\n                    break; //end loop, but print line\r\n                }\r\n\r\n                //convert to timeline track range\r\n                ctx.lineTo( keyframePosX, value );\r\n            }\r\n            ctx.stroke();\r\n        }\r\n\r\n        //draw points\r\n        ctx.fillStyle = Timeline.KEYFRAME_COLOR;\r\n        for( let j = 0; j < keyframes.length; ++j )\r\n        {\r\n            let time = keyframes[ j ];\r\n            if( time < startTime || time > endTime )\r\n                continue;\r\n\r\n            let size = defaultPointSize;\r\n            let keyframePosX = this.timeToX( time );\r\n\r\n            if( !this.active || !track.active )\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_INACTIVE;\r\n            else if( track.locked )\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_LOCK;\r\n            else if( track.hovered[ j ] ) {\r\n                size = hoverPointSize;\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_HOVERED;\r\n            }\r\n            else if( track.selected[ j ] )\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_SELECTED;\r\n            else if( track.edited[ j ] )\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_EDITED;\r\n            else\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR\r\n\r\n            let value = values[ j ];\r\n            value = LX.clamp( ( value - valueRange[ 0 ] ) / ( valueRange[ 1 ] - valueRange[ 0 ] ), 0,1 ) *(-displayRange ) + ( trackHeight - defaultPointSize ); // normalize, clamp and offset\r\n\r\n            ctx.beginPath();\r\n            ctx.arc( keyframePosX, value, size, 0, Math.PI * 2 );\r\n            ctx.fill();\r\n            ctx.closePath();\r\n        }\r\n    }\r\n\r\n    _getValidTrackName( uglyName: string ) {\r\n\r\n        let groupId = null;\r\n        let trackId = null;\r\n        let trackNameInfo;\r\n        // Support other versions\r\n        if(uglyName.includes(\"[\")) {\r\n            const nameIndex = uglyName.indexOf('[');\r\n            trackNameInfo = uglyName.substring( nameIndex+1 ).split(\"].\");\r\n        }else {\r\n            trackNameInfo = uglyName.split(\".\");\r\n        }\r\n\r\n        if( trackNameInfo.length > 1 ) {\r\n            groupId = trackNameInfo[ 0 ];\r\n            trackId = trackNameInfo[ 1 ];\r\n        }\r\n        else\r\n        {\r\n            trackId = trackNameInfo[ 0 ];\r\n        }\r\n\r\n        return [groupId, trackId];\r\n    }\r\n\r\n    /**\r\n     * updates an existing track with new values and times.\r\n     * @param {Int} trackIdx index of track in the animationClip\r\n     * @param {*} newTrack object with two arrays: values and times. These will be set to the selected track\r\n     * @returns\r\n     */\r\n    updateTrack( trackIdx: number, newTrack: any ) {\r\n        if( !this.animationClip )\r\n            return false;\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        track.values = newTrack.values;\r\n        track.times = newTrack.times;\r\n\r\n        track.selected = newTrack.selected ?? ( new Array( track.times.length )).fill( false );\r\n        track.hovered = newTrack.hovered ?? ( new Array( track.times.length )).fill( false );\r\n        track.edited = newTrack.edited ?? ( new Array( track.times.length )).fill( false );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * removes equivalent sequential keys either because of equal times or values\r\n     * ( 0,0,0,0,1,1,1,0,0,0,0,0,0,0 ) --> ( 0, 0,1,1,0, 0 )\r\n     * @param {Int} trackIdx index of track in the animation\r\n     * @param {Boolean} onlyEqualTime if true, removes only keyframes with equal times. Otherwise, values are ALSO compared through the class threshold\r\n     * @param {Boolean} skipCallback if false, triggers \"onOptimizeTracks\" after optimizing\r\n     */\r\n    optimizeTrack( trackIdx: number, onlyEqualTime: boolean = false, skipCallback: boolean = false )\r\n    {\r\n        if( !this.animationClip ) return;\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ],\r\n            times = track.times,\r\n            values = track.values,\r\n            stride = track.dim,\r\n            threshold = this.optimizeThreshold;\r\n\r\n        if( track.locked )\r\n        {\r\n            return;\r\n        }\r\n\r\n        let cmpFunction = ( v: number, p: number, n: number, t: number ) => { return Math.abs( v - p ) >= t || Math.abs( v - n ) >= t };\r\n        let lastSavedIndex = 0;\r\n        const lastIndex = times.length - 1;\r\n\r\n        this.saveState( track.trackIdx );\r\n\r\n        for ( let i = 1; i < lastIndex; ++ i )\r\n        {\r\n            let keep = false;\r\n            const time = times[ i ];\r\n            const timePrev = times[ lastSavedIndex ];\r\n\r\n            // remove adjacent keyframes scheduled at the same time\r\n            if( time !== timePrev )\r\n            {\r\n                if( !onlyEqualTime )\r\n                {\r\n                    // remove unnecessary keyframes same as their neighbors\r\n                    const offset = i * stride,\r\n                        offsetP = lastSavedIndex * stride,\r\n                        offsetN = offset + stride;\r\n\r\n                    for ( let j = 0; j !== stride; ++ j ) {\r\n                        if( cmpFunction(\r\n                            values[ offset + j ],\r\n                            values[ offsetP + j ],\r\n                            values[ offsetN + j ],\r\n                            threshold ))\r\n                        {\r\n                            keep = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    keep = true;\r\n                }\r\n            }\r\n\r\n            // in-place compaction\r\n            if( keep )\r\n            {\r\n                ++lastSavedIndex;\r\n\r\n                if( i !== lastSavedIndex )\r\n                {\r\n                    times[ lastSavedIndex ] = times[ i ];\r\n                    const readOffset = i * stride,\r\n                        writeOffset = lastSavedIndex * stride;\r\n                    for ( let j = 0; j !== stride; ++ j )\r\n                    {\r\n                        values[ writeOffset + j ] = values[ readOffset + j ];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // add last frame. first and last keyframes should be always kept\r\n        if( times.length > 1 )\r\n        {\r\n            ++lastSavedIndex;\r\n\r\n            times[ lastSavedIndex ] = times[ times.length - 1 ];\r\n            const readOffset = values.length - stride,\r\n                writeOffset = lastSavedIndex * stride;\r\n            for ( let j = 0; j !== stride; ++j )\r\n            {\r\n                values[ writeOffset + j ] = values[ readOffset + j ];\r\n            }\r\n        }\r\n\r\n        // commit changes\r\n        if( lastSavedIndex < times.length - 1 )\r\n        {\r\n            track.times = times.slice( 0, lastSavedIndex + 1 );\r\n            track.values = values.slice( 0, ( lastSavedIndex + 1 ) * stride );\r\n            this.updateTrack( track.trackIdx, track ); // update control variables (hover, edited, selected )\r\n        }\r\n\r\n        if( this.onOptimizeTracks && !skipCallback )\r\n        {\r\n            this.onOptimizeTracks( trackIdx );\r\n        }\r\n    }\r\n\r\n    optimizeTracks( onlyEqualTime: boolean = false ) {\r\n\r\n        if( !this.animationClip ) return;\r\n\r\n        // save all states into a single entry\r\n        if( this.historySaveEnabler )\r\n        {\r\n            for( let i = 0; i < this.animationClip.tracks.length; ++i )\r\n            {\r\n                this.saveState( i, i != 0 );\r\n            }\r\n        }\r\n\r\n        // disable state saving\r\n        const oldStateEnabler = this.historySaveEnabler;\r\n        this.historySaveEnabler = false;\r\n\r\n        // optimize\r\n        for( let i = 0; i < this.animationClip.tracks.length; ++i ) {\r\n            const track = this.animationClip.tracks[ i ];\r\n            this.optimizeTrack( track.trackIdx, onlyEqualTime, true );\r\n        }\r\n\r\n        // restore old enabler status\r\n        this.historySaveEnabler = oldStateEnabler;\r\n\r\n        // callback\r\n        if( this.onOptimizeTracks )\r\n        {\r\n            this.onOptimizeTracks( -1 ); // signal as \"all tracks\"\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saveState function uses this to generate a \"copy\" of the track.\r\n     * @param {Number} trackIdx\r\n     * @returns All necessary information to reconstruct the track state\r\n     */\r\n    historyGenerateTrackStep( trackIdx: number )\r\n    {\r\n        const trackInfo = this.animationClip.tracks[ trackIdx ];\r\n\r\n        const undoStep = {\r\n            trackIdx: trackIdx, // already done by saveState\r\n            t: trackInfo.times.slice(),\r\n            v: trackInfo.values.slice(),\r\n            edited: trackInfo.edited.slice( 0, trackInfo.times.length )\r\n        };\r\n\r\n        return undoStep;\r\n    }\r\n\r\n    /**\r\n     * It should swap the previous state with the incoming state of the track. It must return the previous state.\r\n     * historyGenerateTrackStep could be used to copy the previous state. However, as it is a swap, it suffices to just copy the references.\r\n     * @param {Object} state object with a trackIdx:Number and whatever information was saved in historyGenerateTrackStep\r\n     * @param {Boolean} isUndo\r\n     * @returns previous state object\r\n     */\r\n    historyApplyTrackStep( state: any, isUndo: boolean )\r\n    {\r\n        const track = this.animationClip.tracks[ state.trackIdx ];\r\n\r\n        const stateToReturn = {\r\n            trackIdx: state.trackIdx,\r\n            t: track.times,\r\n            v: track.values,\r\n            edited: track.edited\r\n        };\r\n\r\n        track.times = state.t;\r\n        track.values = state.v;\r\n        track.edited = state.edited;\r\n        if( track.selected.length != track.times.length ) { track.selected.length = track.times.length; }\r\n        if( track.hovered.length != track.times.length ) { track.hovered.length = track.times.length; }\r\n        track.selected.fill( false );\r\n        track.hovered.fill( false );\r\n\r\n        return stateToReturn;\r\n    }\r\n\r\n    /**\r\n    *\r\n    * @param {*} track\r\n    * @param {Number} srcIdx keyFrame index\r\n    * @param {Number} trgIdx keyFrame index\r\n    */\r\n    swapKeyFrames( track: any, srcIdx: number, trgIdx: number )\r\n    {\r\n        const times = track.times;\r\n        const values = track.values;\r\n\r\n        let tmp = times[ srcIdx ];\r\n        times[ srcIdx ] = times[ trgIdx ];\r\n        times[ trgIdx ] = tmp;\r\n\r\n        tmp = track.hovered[ srcIdx ];\r\n        track.hovered[ srcIdx ] = track.hovered[ trgIdx ];\r\n        track.hovered[ trgIdx ] = tmp;\r\n\r\n        tmp = track.edited[ srcIdx ];\r\n        track.edited[ srcIdx ] = track.edited[ trgIdx ];\r\n        track.edited[ trgIdx ] = tmp;\r\n\r\n        tmp = track.selected[ srcIdx ];\r\n        track.selected[ srcIdx ] = track.selected[ trgIdx ];\r\n        track.selected[ trgIdx ] = tmp;\r\n\r\n        let src = srcIdx * track.dim;\r\n        let end = src + track.dim;\r\n        let trg = trgIdx * track.dim;\r\n        for( ; src < end; ++src )\r\n        {\r\n            tmp = values[ src ];\r\n            values[ src ] = values[ trg ];\r\n            values[ trg ] = tmp;\r\n            ++trg;\r\n        }\r\n    }\r\n\r\n    copySelectedContent()\r\n    {\r\n        if( !this.lastKeyFramesSelected.length )\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.clipboard = this.clipboard ?? {};\r\n        this.clipboard.keyframes = {}; // reset clipboard\r\n\r\n        // sort keyframes selected by track\r\n        let toCopy: any = {};\r\n        const tracks = this.animationClip.tracks;\r\n        for( let i = 0; i < this.lastKeyFramesSelected.length; i++ )\r\n        {\r\n            let [ trackIdx, keyIdx ] = this.lastKeyFramesSelected[ i ];\r\n            const track = tracks[ trackIdx ];\r\n\r\n            if( toCopy[ trackIdx ] )\r\n            {\r\n                toCopy[ trackIdx ].idxs.push(keyIdx );\r\n            }\r\n            else\r\n            {\r\n                toCopy[ trackIdx ] = { track: track, idxs : [ keyIdx ] };\r\n            }\r\n\r\n            if( i == 0 )\r\n            {\r\n                this.copyKeyFrameValue( track, keyIdx );\r\n            }\r\n        }\r\n\r\n        // for each track selected, copy its values\r\n        for( let trackIdx in toCopy )\r\n        {\r\n            this.copyKeyFrames( toCopy[ trackIdx ].track, toCopy[ trackIdx ].idxs );\r\n        }\r\n    }\r\n\r\n    // copies the current value of the keyframe. This value can be pasted across any track ( as long as they are of the same type )\r\n    copyKeyFrameValue( track: any, index: number )\r\n    {\r\n        // 1 element clipboard by now\r\n        const start = index * track.dim;\r\n        const values = this.animationClip.tracks[ track.trackIdx ].values.slice( start, start + track.dim );\r\n\r\n        this.clipboard = this.clipboard ?? {};\r\n        this.clipboard.value = {\r\n            type: track.type,\r\n            values: values\r\n        };\r\n    }\r\n\r\n    // each track will have its own entry of copied keyframes. When pasting, only the apropiate track's keyframes are pasted\r\n    copyKeyFrames( track: any, indices: number[] )\r\n    {\r\n\r\n        let trackIdx = track.trackIdx;\r\n        this.clipboard = this.clipboard ?? {};\r\n\r\n        indices.sort( ( a,b ) => a < b ? -1 : 1 ); // just in case\r\n\r\n        let obj: any = { track: track, values: [], times: [] };\r\n\r\n        for( let i = 0; i < indices.length; i++ )\r\n        {\r\n            let keyIdx = indices[ i ];\r\n            let start = keyIdx * track.dim;\r\n            let keyValues = track.values.slice( start, start + track.dim ); // copy values into a new array\r\n            obj.values.push(keyValues ); // save to clipboard\r\n            obj.times.push( track.times[ keyIdx ] ); // save to clipboard\r\n        };\r\n\r\n        this.clipboard.keyframes[ trackIdx ] = obj;\r\n    }\r\n\r\n    canPasteKeyFrame ()\r\n    {\r\n        return this.clipboard != null;\r\n    }\r\n\r\n    // raw paste of values\r\n    #paste( track: any, index: number, values: number[] )\r\n    {\r\n        const start = index * track.dim;\r\n        let j = 0;\r\n        for( let i = start; i < start + track.dim; ++i )\r\n        {\r\n            track.values[ i ] = values[ j ];\r\n            ++j;\r\n        }\r\n\r\n        track.edited[ index ] = true;\r\n    }\r\n\r\n    // paste value on selected content ( only one keyframe can be selected )\r\n    pasteContentValue()\r\n    {\r\n        if( !this.clipboard )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        // copy the value into the only selected keyframe\r\n        if( this.clipboard.value && this.lastKeyFramesSelected.length == 1 )\r\n        {\r\n\r\n            let [ trackIdx, keyIdx ] = this.lastKeyFramesSelected[ 0 ];\r\n            this.pasteKeyFrameValue( this.animationClip.tracks[ trackIdx ], keyIdx );\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // paste copied keyframes. New keyframes are created and overlapping ones are overwritten\r\n    pasteContent( time = this.currentTime )\r\n    {\r\n        if( !this.clipboard )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        // create new keyframes from the ones copied\r\n        if( this.clipboard.keyframes )\r\n        {\r\n            for( let trackIdx in this.clipboard.keyframes )\r\n            {\r\n                const clipboardItem = this.animationClip.tracks[ trackIdx ];\r\n\r\n                // ensure all tracks are visible\r\n                const idx = this.selectedItems.findIndex( ( item ) =>\r\n                    {\r\n                        if( item.isTrack ) { return ( item === clipboardItem ) }\r\n                        return item === clipboardItem.groupId;\r\n                    } );\r\n\r\n                if( idx == -1 )\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            this.pasteKeyFrames( time );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    pasteKeyFrameValue( track: any, index: number )\r\n    {\r\n        if( track.locked || ( this.clipboard.value.type != track.type ) )\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.saveState( track.trackIdx );\r\n\r\n        // Copy to current key\r\n        this.#paste( track, index, this.clipboard.value.values );\r\n\r\n        if( this.onUpdateTrack )\r\n        {\r\n            this.onUpdateTrack( [ track.trackIdx ] );\r\n        }\r\n    }\r\n\r\n    pasteKeyFrames( pasteTime: number = this.currentTime )\r\n    {\r\n        if( !this.clipboard.keyframes ) return false;\r\n\r\n        this.unHoverAll();\r\n        this.deselectAllKeyFrames();\r\n\r\n        let clipboardTracks = this.clipboard.keyframes;\r\n        let globalStart = Infinity;\r\n        for( let trackIdx in clipboardTracks ) {\r\n            if( globalStart > clipboardTracks[ trackIdx ].times[ 0 ] ) {\r\n                globalStart = clipboardTracks[ trackIdx ].times[ 0 ];\r\n            }\r\n        }\r\n\r\n        if( globalStart == Infinity ) return false;\r\n\r\n        // disable callback. It will be done once at the end\r\n        const onUpdateTrack = this.onUpdateTrack;\r\n        this.onUpdateTrack = null;\r\n\r\n        // disable history. It will be done with all changes combined into a single entry\r\n        const oldSaveEnabler = this.historySaveEnabler;\r\n        let trackCount: number = 0; // to detect when to create an entry or\r\n\r\n        for( let trackIdx in clipboardTracks )\r\n        {\r\n            const clipboardInfo = this.clipboard.keyframes[ trackIdx ];\r\n            const times = clipboardInfo.times;\r\n            const values = clipboardInfo.values;\r\n            const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n            if( track.locked )\r\n            {\r\n                continue;\r\n            }\r\n\r\n            this.saveState( track.trackIdx, Boolean( trackCount++ ) );\r\n            this.historySaveEnabler = false;\r\n            this.addKeyFrames( track.trackIdx, values, times, -globalStart + pasteTime, KeyFramesTimeline.ADDKEY_VALUESINARRAYS  );\r\n            this.historySaveEnabler = oldSaveEnabler;\r\n        }\r\n\r\n        // do only one update\r\n        if( onUpdateTrack )\r\n        {\r\n            this.onUpdateTrack = onUpdateTrack;\r\n            this.onUpdateTrack( Object.keys( clipboardTracks ) );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Int} trackIdx\r\n     * @param {Array} newValues array of values for each keyframe. It should be a flat array of size track.dim*numKeyframes. Check ADDKEY_VALUESINARRAYS flag\r\n     * @param {Array of numbers } newTimes must be ordered ascendently\r\n     * @param {Number} timeOffset\r\n     * @param {Int} flags\r\n     *      KeyFramesTimeline.ADDKEY_VALUESINARRAYS: if set, newValues is an array of arrays, one for each entry [ [1,2,3], [5,6,7] ]. Times is still a flat array of values [ 0, 0.2 ]\r\n\r\n     * @returns\r\n     */\r\n    addKeyFrames( trackIdx: number, newValues: any[], newTimes: number[], timeOffset: number = 0, flags: number = 0x00 )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n        if( !newTimes.length || track.locked ) return null;\r\n\r\n        const valueDim = track.dim;\r\n        const trackTimes = track.times;\r\n        const trackValues = track.values;\r\n        const times = new Float32Array( trackTimes.length + newTimes.length );\r\n        const values = new Float32Array( trackValues.length + newTimes.length * valueDim );\r\n\r\n        // let newIdx = this.getNearestKeyFrame( track, newTimes[ newTimes.length - 1 ], -1 );\r\n        this.saveState( trackIdx );\r\n\r\n        let newIdx = newTimes.length - 1;\r\n        let oldIdx = trackTimes.length - 1;\r\n        let resultIndices: number[] = [];\r\n\r\n        if( KeyFramesTimeline.ADDKEY_VALUESINARRAYS & flags )\r\n        {\r\n            for( let i: number = times.length - 1; i > -1; --i )\r\n            {\r\n                // copy new value in this place if needed\r\n                if( oldIdx<0 || ( newIdx>-1 && trackTimes[ oldIdx ] < ( newTimes[ newIdx ]+timeOffset )) ) {\r\n                    const vals : any = newValues[ newIdx ];\r\n                    for( let v = 0; v < valueDim; ++v )\r\n                    {\r\n                        values[ i * valueDim + v ] = vals[ v ];\r\n                    }\r\n                    times[ i ] = newTimes[ newIdx--] + timeOffset;\r\n                    // Add new entry into each control array\r\n                    track.hovered.splice( oldIdx+1, 0, false );\r\n                    track.selected.splice( oldIdx+1, 0, false );\r\n                    track.edited.splice( oldIdx+1, 0, true );\r\n\r\n                    resultIndices.push( i );\r\n                    continue;\r\n                }\r\n\r\n                // copy old values instead\r\n                for( let v = 0; v < valueDim; ++v )\r\n                {\r\n                    values[ i * valueDim + v ] = trackValues[ oldIdx * valueDim + v ];\r\n                }\r\n                times[ i ] = trackTimes[ oldIdx--];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for( let i = times.length - 1; i > -1; --i )\r\n            {\r\n                // copy new value in this place if needed\r\n                if( oldIdx<0 || ( newIdx>-1 && trackTimes[ oldIdx ] < ( newTimes[ newIdx ] + timeOffset )) )\r\n                {\r\n                    // ----------- this is different from the 'if' -----------\r\n                    for( let v = 0; v < valueDim; ++v )\r\n                    {\r\n                        values[ i * valueDim + v ] = newValues[ newIdx * valueDim + v ];\r\n                    }\r\n                    times[ i ] = newTimes[ newIdx--] + timeOffset;\r\n                    // Add new entry into each control array\r\n                    track.hovered.splice( oldIdx+1, 0, false );\r\n                    track.selected.splice( oldIdx+1, 0, false );\r\n                    track.edited.splice( oldIdx+1, 0, true );\r\n\r\n                    resultIndices.push( i );\r\n                    continue;\r\n                }\r\n\r\n                // copy old values instead\r\n                for( let v = 0; v < valueDim; ++v )\r\n                {\r\n                    values[ i * valueDim + v ] = trackValues[ oldIdx * valueDim + v ];\r\n                }\r\n                times[ i ] = trackTimes[ oldIdx--];\r\n            }\r\n\r\n        }\r\n\r\n        // update track pointers\r\n        track.times = times;\r\n        track.values = values;\r\n\r\n        if( ( newTimes[ newTimes.length - 1 ] + timeOffset ) > this.duration )\r\n        {\r\n            this.setDuration( newTimes[ newTimes.length - 1 ] + timeOffset );\r\n        }\r\n\r\n        if( this.onUpdateTrack )\r\n        {\r\n            this.onUpdateTrack( [ trackIdx ] );\r\n        }\r\n\r\n        return resultIndices;\r\n    }\r\n\r\n    deleteSelectedContent( skipCallback = false )\r\n    {\r\n        //*********** WARNING: RELIES ON SORTED lastKeyFramesSelected ***********\r\n\r\n        if( !this.lastKeyFramesSelected.length ) return;\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        const firstTrack = this.lastKeyFramesSelected[ 0 ][ 0 ];\r\n        let trackToRemove = firstTrack;\r\n        let toDelete: number[] = []; // indices to delete of the same track\r\n\r\n        const oldSaveEnabler = this.historySaveEnabler;\r\n\r\n        const numSelected = this.lastKeyFramesSelected.length;\r\n        for( let i = 0; i < numSelected; ++i )\r\n        {\r\n            const [ trackIdx, frameIdx ] = this.lastKeyFramesSelected[ i ];\r\n\r\n            if( tracks[ trackIdx ].locked )\r\n            {\r\n                tracks[ trackIdx ].selected[ frameIdx ] = false; // unselect\r\n                continue;\r\n            }\r\n\r\n            if( trackToRemove != trackIdx )\r\n            {\r\n                this.saveState( trackToRemove, trackToRemove != firstTrack );\r\n\r\n                this.historySaveEnabler = false;\r\n                this.deleteKeyFrames( trackToRemove, toDelete, skipCallback );\r\n                this.historySaveEnabler = oldSaveEnabler;\r\n\r\n                trackToRemove = trackIdx;\r\n                toDelete.length = 0;\r\n            }\r\n\r\n            toDelete.push( frameIdx );\r\n        }\r\n\r\n        this.saveState( trackToRemove, trackToRemove != firstTrack );\r\n        this.historySaveEnabler = false;\r\n        this.deleteKeyFrames( trackToRemove, toDelete, skipCallback );\r\n        this.historySaveEnabler = oldSaveEnabler;\r\n\r\n        this.lastKeyFramesSelected = [];\r\n    }\r\n\r\n    // for typed arrays. Does not update lastSelectedKeyframes\r\n    deleteKeyFrames( trackIdx: number, indices: number[], skipCallback: boolean = false )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n        if( !indices.length || track.locked )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        this.saveState( trackIdx );\r\n\r\n        const oldNumFrames = track.times.length;\r\n        const newNumFrames = track.times.length - indices.length;\r\n        const newTimes = track.times.slice( 0, newNumFrames );\r\n        const newValues = track.values.slice( 0, newNumFrames * track.dim );\r\n\r\n        let resultIdx = indices[ 0 ];\r\n        let resultValIdx = indices[ 0 ] * track.dim;\r\n\r\n        for( let i = 0; i < indices.length; ++i )\r\n        {\r\n            track.edited.splice(resultIdx, 1 );\r\n            track.selected.splice(resultIdx, 1 );\r\n            track.hovered.splice(resultIdx, 1 );\r\n\r\n            const idx = indices[ i ];\r\n            const endIdx = ( i < ( indices.length - 1 )) ? indices[ i+1 ] : oldNumFrames;\r\n            const endValIdx = endIdx * track.dim;\r\n            for( let v = ( idx+1 )*track.dim; v < endValIdx; ++v )\r\n            {\r\n                newValues[resultValIdx++] = track.values[ v ];\r\n            }\r\n            for( let f = idx+1; f < endIdx; ++f )\r\n            {\r\n                newTimes[resultIdx++] = track.times[ f ];\r\n            }\r\n        }\r\n\r\n        track.times = newTimes;\r\n        track.values = newValues;\r\n\r\n        // Update animation action interpolation info\r\n        if( this.onDeleteKeyFrames && !skipCallback )\r\n            this.onDeleteKeyFrames( trackIdx, indices );\r\n\r\n        if( ( newTimes[ newTimes.length - 1 ] ) > this.duration )\r\n        {\r\n            this.setDuration( newTimes[ newTimes.length - 1 ] );\r\n        }\r\n\r\n        // if( this.onUpdateTrack )\r\n        //     this.onUpdateTrack( [ trackIdx ] );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binary search. Relies on track.times being a sorted array\r\n     * @param {Object} track\r\n     * @param {Number} time\r\n     * @param {Number} mode on of the possible values\r\n     *  - -1 = nearest frame with t[ f ] <= time\r\n     *  - 0 = nearest frame\r\n     *  - 1 = nearest frame with t[ f ] >= time\r\n     * @returns a zero/positive value if successful. On failure returnes -1 meaning either there are no frames ( 0 ), no frame-time is lower ( -1 ) or no frame-time is higher (1 )\r\n     */\r\n    getNearestKeyFrame( track: any, time: number, mode: number = 0 )\r\n    {\r\n        if( !track || !track.times || !track.times.length )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        //binary search\r\n        const times = track.times;\r\n        let min = 0, max = times.length - 1;\r\n\r\n        // edge cases\r\n        if( times[ min] > time )\r\n        {\r\n            return mode == -1 ? -1 : 0;\r\n        }\r\n        if( times[ max ] < time )\r\n        {\r\n            return mode == 1 ? -1 : max;\r\n        }\r\n\r\n        // time is between first and last frame\r\n        let half = Math.floor( ( min + max ) / 2 );\r\n        while ( min < half && half < max )\r\n        {\r\n            if( time < times[half] ) { max = half; }\r\n            else { min = half; }\r\n            half = Math.floor( ( min + max ) / 2 );\r\n        }\r\n\r\n        if( mode == 0 ) {\r\n            return Math.abs( time - times[ min] ) < Math.abs( time - times[ max ] ) ? min : max;\r\n        }\r\n        else if( mode == -1 ) {\r\n            return times[ max ] == time ? max : min;\r\n        }\r\n        return times[ min] == time ? min : max;\r\n    }\r\n\r\n    /**\r\n     * get the nearest keyframe to \"time\" given a maximum threshold.\r\n     * @param {Object} track\r\n     * @param {Number} time\r\n     * @param {Number} threshold must be positive value\r\n     * @returns returns a postive/zero value if there is a frame inside the threshold range. Otherwise, -1\r\n     */\r\n    getCurrentKeyFrame( track: any, time: number, threshold: number = 0.0 )\r\n    {\r\n        if( !track || !track.times.length )\r\n            return -1;\r\n\r\n        let frame = this.getNearestKeyFrame( track, time );\r\n        if( frame > -1 )\r\n        {\r\n            frame = Math.abs( track.times[ frame ] - time ) > threshold ? -1 : frame;\r\n        }\r\n\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Returns the interval of frames between minTime and maxTime (both included )\r\n     * @param {Object} track\r\n     * @param {Number} minTime\r\n     * @param {Number} maxTime\r\n     * @param {Number} threshold must be positive value\r\n     * @returns an array with two values [ minFrame, maxFrame ]. Otherwise null\r\n     */\r\n    getKeyFramesInRange( track: any, minTime: number, maxTime: number, threshold: number = 0.0 )\r\n    {\r\n        if( !track || !track.times.length ) return null;\r\n\r\n        // Manage negative selection\r\n        if( minTime > maxTime )\r\n        {\r\n            let aux = minTime;\r\n            minTime = maxTime;\r\n            maxTime = aux;\r\n        }\r\n\r\n        const minFrame = this.getNearestKeyFrame( track, minTime - threshold, 1 );\r\n        const maxFrame = this.getNearestKeyFrame( track, maxTime + threshold, -1 );\r\n\r\n        if( maxFrame == -1 || minFrame == -1 ) return null;\r\n\r\n        return [ minFrame, maxFrame ];\r\n    }\r\n\r\n    unHoverAll()\r\n    {\r\n        if( this.lastHovered )\r\n        {\r\n            this.animationClip.tracks[ this.lastHovered[ 0 ] ].hovered[ this.lastHovered[ 1 ] ] = false;\r\n        }\r\n\r\n        let h = this.lastHovered;\r\n        this.lastHovered = null;\r\n        return h;\r\n    }\r\n\r\n    deselectAllKeyFrames()\r\n    {\r\n        for( let [ trackIdx, keyIndex ] of this.lastKeyFramesSelected )\r\n        {\r\n            this.animationClip.tracks[ trackIdx ].selected[ keyIndex ] = false;\r\n        }\r\n\r\n        // Something has been deselected\r\n        const deselected = this.lastKeyFramesSelected.length > 0;\r\n        this.lastKeyFramesSelected.length = 0;\r\n        return deselected;\r\n    }\r\n\r\n    isKeyFrameSelected( track: any, index: number )\r\n    {\r\n        return track.selected[ index ];\r\n    }\r\n\r\n    /**\r\n     * @param {Int} trackIdx track index of animation clip\r\n     * @param {Int} frameIdx frame ( index ) to select inside the track\r\n     * @param {Boolean} skipCallback\r\n     * @returns\r\n     */\r\n    selectKeyFrame( trackIdx: number, frameIdx: number, skipCallback: boolean = false )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        if( track.locked || !track.active || track.selected[ frameIdx ] )\r\n            return null;\r\n\r\n        // [ track idx, keyframe, keyframe time ]\r\n        const selection = [ track.trackIdx, frameIdx, track.times[ frameIdx ]];\r\n\r\n        // sort lastkeyframeselected ascending order ( track and frame )\r\n        let i = 0;\r\n        for( ; i < this.lastKeyFramesSelected.length; ++i )  {\r\n            let s = this.lastKeyFramesSelected[ i ];\r\n            if( s[ 0 ] > trackIdx || ( s[ 0 ] == trackIdx && s[ 1 ] > frameIdx )) {\r\n                break;\r\n            }\r\n        }\r\n        this.lastKeyFramesSelected.splice( i, 0, selection );\r\n        track.selected[ frameIdx ] = true;\r\n\r\n        if( this.onSelectKeyFrame && !skipCallback )\r\n        {\r\n            this.onSelectKeyFrame( selection );\r\n        }\r\n\r\n        return selection;\r\n    }\r\n\r\n    deselectKeyFrame( trackIdx: number, frameIdx: number )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        if( track.locked || !track.active || !track.selected[ frameIdx ] )\r\n            return false;\r\n\r\n        track.selected[ frameIdx ] = false;\r\n\r\n        for( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n        {\r\n            const sk = this.lastKeyFramesSelected[ i ];\r\n            if( sk[ 0 ] === trackIdx && sk[ 1 ] === frameIdx )\r\n            {\r\n                this.lastKeyFramesSelected.splice( i, 1 );\r\n                break;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    getNumKeyFramesSelected()\r\n    {\r\n        return this.lastKeyFramesSelected.length;\r\n    }\r\n\r\n    /**\r\n     * helper function to process a selection with multiple keyframes. Sets the time of the timeline to the first selected keyframe\r\n     * @param {Number} trackIdx\r\n     * @param {Number} keyFrameIndex\r\n     * @param {Boolean} multipleSelection whether to append to selection or reset it and make this keyframe the only current selection\r\n     * @returns\r\n     */\r\n    processSelectionKeyFrame( trackIdx: number, keyFrameIndex: number, multipleSelection: boolean = false )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        if( track.locked )\r\n            return;\r\n\r\n        if( !multipleSelection )\r\n        {\r\n            this.deselectAllKeyFrames();\r\n        }\r\n\r\n        this.selectKeyFrame( trackIdx, keyFrameIndex );\r\n\r\n        if( !multipleSelection )\r\n        {\r\n            this.setTime( track.times[ keyFrameIndex ] );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method clearTrack\r\n     */\r\n    clearTrack( trackIdx: number )\r\n    {\r\n        const track =  this.animationClip.tracks[ trackIdx ];\r\n\r\n        this.unHoverAll();\r\n        this.deselectAllKeyFrames();\r\n\r\n        if( track.locked )\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.saveState( track.trackIdx );\r\n\r\n        track.times = track.times.slice( 0, 0 );\r\n        track.values = track.values.slice( 0, 0 );\r\n        track.edited.length = 0;\r\n        track.hovered.length = 0;\r\n        track.selected.length = 0;\r\n\r\n        return trackIdx;\r\n    }\r\n}\r\n\r\nLX.KeyFramesTimeline = KeyFramesTimeline;\r\n/**\r\n * @class ClipsTimeline\r\n */\r\n\r\nexport class ClipsTimeline extends Timeline\r\n{\r\n    static CLONEREASON_COPY = 1;\r\n    static CLONEREASON_PASTE = 2;\r\n    static CLONEREASON_HISTORY = 3;\r\n    static CLONEREASON_TRACKCLONE = 4;\r\n\r\n    lastClipsSelected: any = [];\r\n    lastTrackClipsMove: number = 0; // vertical movement of clips, onMouseMove onMousedown\r\n    dragClipMode: Nullable< string > = \"\";\r\n    lastHovered: Nullable< [ number, number] > = null;\r\n\r\n    onSelectClip: Nullable< ( clip: Nullable<any>) => void > = null;\r\n    onContentMoved: Nullable< ( clip: Nullable<any>, delta: number ) => void > = null;\r\n    onDeleteSelectedClips: Nullable< ( selected: any[] ) => void > = null;\r\n    onDeleteClip: Nullable< ( trackIdx: number, clipIdx: number, clip: any ) => void > = null;\r\n\r\n    /**\r\n     * @param {String} name\r\n     * @param {Object} options = {animationClip, selectedItems, x, y, width, height, canvas, trackHeight}\r\n     */\r\n    constructor( name: string, options: any = {} )\r\n    {\r\n        super( name, options );\r\n\r\n        this.lastClipsSelected = [];\r\n        this.lastTrackClipsMove = 0; // vertical movement of clips, onMouseMove onMousedown\r\n        this.dragClipMode = \"\";\r\n\r\n        this.setAnimationClip( this.animationClip );\r\n\r\n        this.onDblClick = ( e: any ) => {\r\n            const track = e.track;\r\n            const localX = e.localX;\r\n\r\n            if( track ) {\r\n                const clipIdx = this.getClipOnTime( track, this.xToTime( localX ), 0.001 );\r\n                this.selectClip( track.trackIdx, clipIdx ); // deselect and try to select clip in localX, if any\r\n            }\r\n        }\r\n\r\n        this.onShowContextMenu = ( e: any ) => {\r\n\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n\r\n            let actions: any[] = [];\r\n            if( this.lastClipsSelected.length )\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: \"Copy\",\r\n                        callback: () => { this.copySelectedContent();}\r\n                    }\r\n                )\r\n                actions.push(\r\n                    {\r\n                        title: \"Delete\",\r\n                        callback: () => {\r\n                            this.deleteSelectedContent();\r\n                        }\r\n                    }\r\n                )\r\n            }\r\n            else\r\n            {\r\n                if( this.clipboard )\r\n                {\r\n                    actions.push(\r\n                        {\r\n                            title: \"Paste\",\r\n                            callback: () => {\r\n                                this.pasteContent();\r\n                            }\r\n                        }\r\n                    );\r\n                    actions.push(\r\n                        {\r\n                            title: \"Paste Here\",\r\n                            callback: () => {\r\n                                this.pasteContent( this.xToTime( e.localX ) );\r\n                            }\r\n                        }\r\n                    )\r\n                }\r\n            }\r\n\r\n            LX.addContextMenu(\"Options\", e, ( m: any ) => {\r\n                for( let i = 0; i < actions.length; i++ )  {\r\n                    m.add( actions[ i ].title,  actions[ i ].callback )\r\n                }\r\n            } );\r\n\r\n        } // end of onShowContextMenu\r\n    }\r\n\r\n    /**\r\n     * Generates an animationClip using either the parameters set in the animation argument or using default values\r\n     * @param {Object} animation data with which to generate an animationClip\r\n     * @returns\r\n     */\r\n    instantiateAnimationClip( animation: any, clone: boolean = false )\r\n    {\r\n        const animationClip = super.instantiateAnimationClip( animation );\r\n\r\n        if( animation && animation.tracks )\r\n        {\r\n            for( let i = 0; i < animation.tracks.length; ++i )\r\n            {\r\n                const trackInfo: any = this.instantiateTrack( animation.tracks[ i ], clone );\r\n                trackInfo.trackIdx = animationClip.tracks.length;\r\n                animationClip.tracks.push( trackInfo );\r\n            }\r\n        }\r\n\r\n        return animationClip;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Object} options set some values for the track instance ( groups and trackIdx not included )\r\n     * @returns\r\n    */\r\n    instantiateTrack( options: any = {}, clone: boolean = false )\r\n    {\r\n        const track: any = super.instantiateTrack( options );\r\n\r\n        track.trackIdx = this.animationClip.tracks.length;\r\n\r\n        track.selected = [];\r\n        track.edited = [];\r\n        track.hovered = [];\r\n\r\n        if( options.clips )\r\n        {\r\n            track.clips = clone ? this.cloneClips( options.clips, 0, ClipsTimeline.CLONEREASON_TRACKCLONE ) : options.clips;\r\n        }\r\n        else\r\n        {\r\n            track.clips = [];\r\n        }\r\n\r\n        const numClips = track.clips.length;\r\n\r\n        if( options.selected && options.selected.length == numClips )\r\n        {\r\n            track.selected = clone ? options.selected.slice() : options.selected;\r\n        }\r\n        else\r\n        {\r\n            track.selected = ( new Array( numClips )).fill( false );\r\n        }\r\n\r\n        if( options.edited && options.edited.length == numClips )\r\n        {\r\n            track.edited = clone ? options.edited.slice() : options.edited;\r\n        }\r\n        else\r\n        {\r\n            track.edited = ( new Array( numClips )).fill( false );\r\n        }\r\n\r\n        if( options.hovered && options.hovered.length == numClips )\r\n        {\r\n            track.hovered = clone ? options.hovered.slice() : options.hovered;\r\n        }\r\n        else\r\n        {\r\n            track.hovered = ( new Array( numClips )).fill( false );\r\n        }\r\n\r\n        // sanity check. Also done in addClip\r\n        for( let i = 0; i < track.clips.length; ++i ) {\r\n            track.clips[ i ].active = track.clips[ i ].active ?? true;\r\n        }\r\n        return track;\r\n    }\r\n\r\n    // provides an base example of a proper clip\r\n    instantiateClip( options: any = {} )\r\n    {\r\n        return {\r\n            id: options.id ?? ( options.name ?? \"clip\"),\r\n\r\n            start: options.start ?? 0,\r\n            duration: options.duration ?? 1,\r\n            fadein: options.fadein ?? undefined,\r\n            fadeout: options.fadeout ?? undefined,\r\n\r\n            clipColor: options.clipColor ?? LX.getThemeColor(\"global-color-accent\"),\r\n            fadeColor: options.fadeColor ?? null,\r\n            active: options.active ?? true,\r\n            trackIdx: -1, // filled by addClip\r\n        }\r\n\r\n    }\r\n    // use default updateleftpanel\r\n    // generateSelectedItemsTreeData() {}\r\n\r\n    addNewTrack( options: any = {}, updateLeftPanel: boolean = true, skipCallback: boolean = false )\r\n    {\r\n        const trackInfo = this.instantiateTrack( options ?? {} );\r\n        trackInfo.trackIdx = this.animationClip.tracks.length;\r\n        this.animationClip.tracks.push( trackInfo );\r\n\r\n        if( this.onAddNewTrack && !skipCallback )\r\n        {\r\n            this.onAddNewTrack( trackInfo, options );\r\n        }\r\n\r\n        this.selectedItems.push( trackInfo );\r\n        if( updateLeftPanel )\r\n        {\r\n            this.updateLeftPanel();\r\n        }\r\n\r\n        return trackInfo.trackIdx;\r\n    }\r\n\r\n    // OVERRIDE ITEM SELECTION - ClipsTimeline will not offer any selection. Alltracks are visible\r\n    setAnimationClip( animation: any, needsToProcess: boolean = true  )\r\n    {\r\n        super.setAnimationClip( animation, needsToProcess );\r\n        this.changeSelectedItems();\r\n        return this.animationClip;\r\n    }\r\n\r\n    // OVERRIDE\r\n    deselectAllElements()\r\n    {\r\n        this.deselectAllClips();\r\n        this.unHoverAll();\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE ITEM SELECTION.\r\n     * CLIPS WILL OFFER NO SELECTION. All tracks are visible\r\n     */\r\n    changeSelectedItems()\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left\r\n\r\n        this.selectedItems = this.animationClip.tracks.slice();\r\n\r\n        this.updateLeftPanel();\r\n    }\r\n\r\n    unHoverAll()\r\n    {\r\n        if( this.lastHovered )\r\n        {\r\n            this.animationClip.tracks[ this.lastHovered[ 0 ] ].hovered[ this.lastHovered[ 1 ] ] = false;\r\n        }\r\n\r\n        let h = this.lastHovered;\r\n        this.lastHovered = null;\r\n        return h;\r\n    }\r\n\r\n    onMouseUp( e: any )\r\n    {\r\n        let track = e.track;\r\n        let localX = e.localX;\r\n        let discard = e.discard; // true when too much time has passed between Down and Up\r\n\r\n        if( e.shiftKey )\r\n        {\r\n            // Manual Multiple selection\r\n            if( !discard ) {\r\n                if( track ) {\r\n                    let clipIndex = this.getClipOnTime( track, this.xToTime( localX ), this.secondsPerPixel * 5 );\r\n                    if( clipIndex > -1 ) {\r\n                        track.selected[ clipIndex ] ?\r\n                            this.deselectClip( track.trackIdx, clipIndex ) :\r\n                            this.selectClip( track.trackIdx, clipIndex, false );\r\n                    }\r\n                }\r\n            }\r\n            // Box selection\r\n            else if( this.boxSelection )\r\n            {\r\n                let tracks = this.getTracksInRange( this.boxSelectionStart[ 1 ], this.boxSelectionEnd[ 1 ] );\r\n\r\n                for( let t of tracks ) {\r\n                    let clipsIndices = this.getClipsInRange( t,\r\n                        this.xToTime( this.boxSelectionStart[ 0 ] ),\r\n                        this.xToTime( this.boxSelectionEnd[ 0 ] ),\r\n                        0.000001 );\r\n\r\n                    if( clipsIndices ) {\r\n                        for( let index of clipsIndices )\r\n                            this.selectClip( t.trackIdx, index, false );\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        else\r\n        {\r\n            let boundingBox = this.canvas.getBoundingClientRect()\r\n            if( e.y < boundingBox.top || e.y > boundingBox.bottom )\r\n                return;\r\n\r\n            // Check exact track clip\r\n            if( !discard && track )\r\n            {\r\n                if( e.button != 2 )\r\n                {\r\n                    const clipIdx = this.getClipOnTime( track, this.xToTime( localX ), 0.001 );\r\n                    this.selectClip( track.trackIdx, clipIdx );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.movingKeys = false;\r\n    }\r\n\r\n    onMouseDown( e: any, time: number )\r\n    {\r\n        // function not called if shift is pressed (boxselection )\r\n        let localX = e.localX;\r\n        let localY = e.localY;\r\n        let track = e.track;\r\n\r\n        if( e.button > 0 )\r\n        {\r\n            return;\r\n        }\r\n\r\n        if( e.ctrlKey && track ) // move clips\r\n        {\r\n            let x = e.offsetX;\r\n            // clip selection is done on MouseUP\r\n            const selectedClips = this.lastClipsSelected;\r\n\r\n            this.canvas.style.cursor = \"grab\";\r\n            let curTrackIdx = -1;\r\n\r\n            this.lastTrackClipsMove = Math.floor( ( e.localY - this.topMargin + this.trackTreesPanel.root.scrollTop ) / this.trackHeight );\r\n\r\n            for( let i = 0; i < selectedClips.length; i++ )\r\n            {\r\n                let [ trackIndex, clipIndex ] = selectedClips[ i ];\r\n                const clip = this.animationClip.tracks[ trackIndex ].clips[ clipIndex ];\r\n\r\n                let endingX = this.timeToX( clip.start + clip.duration );\r\n\r\n                if( Math.abs( endingX - x ) < 5 ) {\r\n                    this.dragClipMode = \"duration\";\r\n                    this.canvas.style.cursor = \"column-resize\";\r\n                }\r\n                else {\r\n                    this.dragClipMode = \"move\";\r\n                }\r\n\r\n                //*********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n                if( curTrackIdx != trackIndex )\r\n                {\r\n                    this.saveState( trackIndex, curTrackIdx != -1 );\r\n                    curTrackIdx = trackIndex;\r\n                }\r\n            }\r\n\r\n            this.movingKeys = true;\r\n        }\r\n        else if( !track || track && this.getClipOnTime( track, time, 0.001 ) == -1 ) // clicked on empty space\r\n        {\r\n            if( this.lastClipsSelected.length )\r\n            {\r\n                this.deselectAllClips();\r\n\r\n                if( this.onSelectClip )\r\n                {\r\n                    this.onSelectClip( null );\r\n                }\r\n            }\r\n        }\r\n        else if( track && ( this.dragClipMode == \"duration\" || this.dragClipMode == \"fadein\" || this.dragClipMode == \"fadeout\" )) // clicked while mouse was over fadeIn, fadeOut, duration\r\n        {\r\n            const clipIdx = this.getClipOnTime( track, this.xToTime( localX ), 0.001 );\r\n            this.selectClip( track.trackIdx, clipIdx ); // select current clip if any ( deselect others )\r\n            if( this.lastClipsSelected.length )\r\n            {\r\n                this.saveState( track.trackIdx );\r\n            }\r\n            this.movingKeys = true;\r\n        }\r\n    }\r\n\r\n    onMouseMove( e: any, time: number )\r\n    {\r\n        // function not called if shift is pressed (boxselection )\r\n\r\n        if( this.grabbingTimeBar || this.grabbingScroll )\r\n        {\r\n            return;\r\n        }\r\n        else if( this.grabbing && e.buttons != 2 )\r\n        {\r\n            this.unHoverAll();\r\n\r\n            let delta = time - this.grabTime;\r\n            this.grabTime = time;\r\n            if( time < 0 && delta > 0 ) { delta = 0; }\r\n\r\n            if( this.dragClipMode != \"move\" && this.lastClipsSelected.length == 1 ) // change fade and duration of clips\r\n            {\r\n                const track = this.animationClip.tracks[ this.lastClipsSelected[ 0 ][ 0 ]];\r\n                let clip = track.clips[ this.lastClipsSelected[ 0 ][ 1 ]];\r\n                if( this.dragClipMode == \"fadein\" )\r\n                {\r\n                    clip.fadein = Math.min( Math.max( clip.fadein + delta, clip.start ), clip.fadeout ?? ( clip.start+clip.duration ) );\r\n                }\r\n                else if( this.dragClipMode == \"fadeout\" )\r\n                {\r\n                    clip.fadeout = Math.max( Math.min( clip.fadeout + delta, clip.start+clip.duration ), clip.fadein ?? clip.start );\r\n                }\r\n                else if( this.dragClipMode == \"duration\" )\r\n                {\r\n                    let duration = Math.max( 0, clip.duration + delta );\r\n                    if( this.lastClipsSelected[ 0 ][ 1 ] < track.clips.length - 1 ) // max next clip's start\r\n                    {\r\n                        duration = Math.min( track.clips[ this.lastClipsSelected[ 0 ][ 1 ] + 1 ].start - clip.start - 0.0001, duration );\r\n                    }\r\n                    clip.duration = duration;\r\n                    if( clip.fadeout != undefined ) clip.fadeout = Math.max( Math.min( ( clip.fadeout ?? ( clip.start+clip.duration )) + delta, clip.start+clip.duration ), clip.start );\r\n                    if( clip.fadein != undefined ) clip.fadein = Math.max( Math.min( ( clip.fadein ?? ( clip.start+clip.duration )), ( clip.fadeout ?? ( clip.start+clip.duration ))), clip.start );\r\n                    if( this.duration < clip.start + clip.duration ) this.setDuration( clip.start + clip.duration );\r\n                }\r\n\r\n                if( this.onContentMoved ) { // content changed\r\n                    this.onContentMoved( clip, 0 );\r\n                }\r\n            }\r\n            else if( this.dragClipMode == \"move\" && this.lastClipsSelected.length ) // move clips\r\n            {\r\n                //*********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n\r\n                const treeOffset = this.lastTrackTreesComponentOffset;\r\n                let newTrackClipsMove = Math.floor( ( e.localY - treeOffset ) / this.trackHeight );\r\n\r\n                // move clips vertically\r\n                if( e.altKey )\r\n                {\r\n                    let deltaTracks = newTrackClipsMove - this.lastTrackClipsMove;\r\n\r\n                    if( this.lastClipsSelected[ 0 ][ 0 ] + deltaTracks < 0 )\r\n                    {\r\n                        deltaTracks = -this.lastClipsSelected[ 0 ][ 0 ];\r\n                    }\r\n\r\n                    // if no movement of tracks, do not check\r\n                    if( deltaTracks != 0 )\r\n                    {\r\n                        // check if ALL selected clips can move track\r\n                        for( let i = 0; i < this.lastClipsSelected.length; ++i )\r\n                        {\r\n                            const track = this.animationClip.tracks[ this.lastClipsSelected[ i ][ 0 ] ];\r\n                            const newTrack = this.animationClip.tracks[ this.lastClipsSelected[ i ][ 0 ] + deltaTracks ];\r\n                            const clip = track.clips[ this.lastClipsSelected[ i ][ 1 ] ];\r\n\r\n                            const clipsInRange = this.getClipsInRange( newTrack, clip.start, clip.start+clip.duration, 0.0001 )\r\n                            if( !clipsInRange )\r\n                            {\r\n                                continue;\r\n                            }\r\n\r\n                            for( let c = 0; c < clipsInRange.length; ++c )\r\n                            {\r\n                                if( !newTrack.selected[ clipsInRange[ c ]] )\r\n                                {\r\n                                    // at least one clip cannot move, abort\r\n                                    c = clipsInRange.length;\r\n                                    i = this.lastClipsSelected.length;\r\n                                    deltaTracks = 0;\r\n                                    newTrackClipsMove = this.lastTrackClipsMove;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // if movement was not canceled\r\n                        if( deltaTracks != 0 ) {\r\n                            let oldStateEnabler = this.historySaveEnabler;\r\n                            this.historySaveEnabler = false;\r\n\r\n                            const selectedClips = this.lastClipsSelected;\r\n                            this.lastClipsSelected = []; // avoid delete and addclips index reassignment loop ( not necessary because of order of operations in for )\r\n\r\n                            for( let i = selectedClips[ selectedClips.length - 1 ][ 0 ] + deltaTracks - this.animationClip.tracks.length + 1; i > 0; --i ) {\r\n                                this.addNewTrack( null, i == 1 );\r\n                                if( i == 1 ) {\r\n                                    this.updateLeftPanel();\r\n                                }\r\n                            }\r\n\r\n                            // selected clips MUST be ordered ( ascendently )\r\n                            let startSel = deltaTracks > 0 ? selectedClips.length - 1 : 0;\r\n                            let endSel = startSel;\r\n                            let currTrack = selectedClips[ startSel][ 0 ];\r\n\r\n                            // i <= length; to update last track. Otherwise a check outside of for would be needed\r\n                            for( let i = 1; i <= selectedClips.length; ++i )\r\n                            {\r\n\r\n                                let idx = deltaTracks > 0 ? ( selectedClips.length -1 - i ) : i;\r\n                                if( i == selectedClips.length || selectedClips[ idx ][ 0 ] != currTrack )\r\n                                {\r\n\r\n                                    const newTrackIdx = currTrack + deltaTracks;\r\n                                    const newTrack = this.animationClip.tracks[ newTrackIdx ];\r\n                                    const track = this.animationClip.tracks[ currTrack ];\r\n\r\n                                    // save track state if necessary\r\n                                    const undoState = this.historyUndo[ this.historyUndo.length - 1 ];\r\n                                    let state = 0;\r\n                                    for( ; state < undoState.length; ++state )\r\n                                    {\r\n                                        if( newTrackIdx == undoState[ state ].trackIdx ) { break; }\r\n                                    }\r\n\r\n                                    if( state == undoState.length )\r\n                                    {\r\n                                        this.historySaveEnabler = true;\r\n                                        this.saveState( newTrackIdx, true );\r\n                                        this.historySaveEnabler = false;\r\n                                    }\r\n\r\n                                    // add clips of a track, from first to last\r\n                                    for( let c = startSel; c <= endSel; ++c )\r\n                                    {\r\n                                        let newClipIdx = this.addClip( track.clips[ selectedClips[ c ][ 1 ] ], newTrackIdx, 0 );\r\n                                        selectedClips[ c ][ 0 ] = newClipIdx; // temporarily store new clip index in trackIndex (HACK START )\r\n                                        newTrack.selected[ newClipIdx ] = true;\r\n                                    }\r\n\r\n                                    // delete clips of a track, from last to first\r\n                                    for( let c = endSel; c >=startSel ; --c )\r\n                                    {\r\n                                        this.#delete( currTrack, selectedClips[ c ][ 1 ] );\r\n                                        selectedClips[ c ][ 1 ] = selectedClips[ c ][ 0 ]; // put new clip index (HACK )\r\n                                        selectedClips[ c ][ 0 ] = newTrackIdx; // put new track index (HACK FIX )\r\n                                    }\r\n\r\n                                    currTrack = i < selectedClips.length ? selectedClips[ idx ][ 0 ] : -1;\r\n                                    startSel = idx;\r\n                                    endSel = idx;\r\n                                    continue;\r\n                                }\r\n\r\n                                deltaTracks > 0 ? startSel = idx : endSel = idx;\r\n                            }\r\n\r\n                            this.lastClipsSelected = selectedClips;\r\n                            this.historySaveEnabler = oldStateEnabler;\r\n                        }\r\n                    }\r\n                }\r\n                this.lastTrackClipsMove = newTrackClipsMove;\r\n\r\n                // move clips horizontally\r\n\r\n                let leastDelta = delta;\r\n                let moveAccepted = true;\r\n\r\n                // find if all clips can move and/or how much they can move\r\n                for( let i = 0; i < this.lastClipsSelected.length; ++i )\r\n                {\r\n                    let trackIdx = this.lastClipsSelected[ i ][ 0 ];\r\n                    let clipIdx = this.lastClipsSelected[ i ][ 1 ];\r\n                    const track = this.animationClip.tracks[ trackIdx ];\r\n                    const trackClips = track.clips;\r\n                    const clip = track.clips[ clipIdx ];\r\n\r\n                    if( delta >= 0 )\r\n                    {\r\n                        if( trackClips.length - 1 == clipIdx ) { continue; } // all alowed\r\n                        if( !track.selected[ clipIdx+1 ] ) { // if next is selected, force AllOrNothing and let next clip manage the leastDelta\r\n                            if( trackClips[ clipIdx + 1 ].start >= ( clip.start+clip.duration+delta ) ) { continue; } //has not reached next clip. Enough space. All allowed\r\n                            const nextClip = trackClips[ clipIdx + 1 ];\r\n                            leastDelta = Math.max( 0, Math.min( leastDelta,  nextClip.start - clip.start - clip.duration ) );\r\n                        }\r\n                    }\r\n                    else if( delta < 0 ) {\r\n                        if( clipIdx > 0 && ( trackClips[ clipIdx - 1 ].start + trackClips[ clipIdx - 1 ].duration ) <= ( clip.start+delta ) ) { continue; } // has not reached previous clip. Enough space\r\n                        if( clipIdx > 0 ) {\r\n                            const prevClip = trackClips[ clipIdx - 1 ];\r\n                            leastDelta = Math.min( 0, Math.max( leastDelta,  prevClip.start + prevClip.duration - clip.start ) ); // delta is a negative value, that is why the leastDelta is the max\r\n                        }\r\n                        if( clip.start + delta < 0 ) {\r\n                            leastDelta = Math.max( leastDelta, -clip.start );\r\n                            moveAccepted = false; // force it to be a leastDelta move only. No jumps\r\n                        }\r\n                    }\r\n\r\n                    if( !moveAccepted ) continue;\r\n                    let clipsInRange = this.getClipsInRange( track, clip.start + delta, clip.start + clip.duration + delta, 0.01 );\r\n                    if( clipsInRange && ( clipsInRange[ 0 ] != clipIdx || clipsInRange[ clipsInRange.length - 1 ] != clipIdx ))\r\n                    {\r\n                        for( let c = 0; c < clipsInRange.length; ++c )\r\n                        {\r\n                            if( !track.selected[ clipsInRange[ c ]] ) { moveAccepted = false; break; }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // if moveAccepted -> use full delta\r\n                // if !moveAccepted -> use leastDelta\r\n                if( moveAccepted ) { leastDelta = delta; }\r\n                this.grabTime = time - delta + leastDelta;\r\n\r\n                //*********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n                // move all selected clips using the computed delta.\r\n                for( let i = 0; i < this.lastClipsSelected.length; ++i )\r\n                {\r\n                    const lcs = this.lastClipsSelected[ delta > 0 ? ( this.lastClipsSelected.length - 1 - i ) : i]; //delta > 0, move last-to-first; delta < 0, move first-to-last\r\n                    const track = this.animationClip.tracks[lcs[ 0 ]];\r\n                    const trackClips = track.clips;\r\n                    let clipIdx = lcs[ 1 ];\r\n                    const clip = track.clips[ clipIdx ];\r\n                    clip.start += leastDelta;\r\n                    if( clip.fadein != undefined ) { clip.fadein += leastDelta; }\r\n                    if( clip.fadeout != undefined ) { clip.fadeout += leastDelta; }\r\n\r\n                    // prepare swap\r\n                    const editedFlag = track.edited[ clipIdx ];\r\n                    const selectedFlag = track.selected[ clipIdx ];\r\n                    const hoveredFlag = track.hovered[ clipIdx ];\r\n\r\n                    // move other clips\r\n                    if( delta > 0 )\r\n                    {\r\n                        while( clipIdx < trackClips.length - 1 )\r\n                        {\r\n                            if( trackClips[ clipIdx+1 ].start >= clip.start ) {\r\n                                break;\r\n                            }\r\n                            trackClips[ clipIdx ] = trackClips[ clipIdx+1 ];\r\n                            track.selected[ clipIdx ] = track.selected[ clipIdx+1 ];\r\n                            track.edited[ clipIdx ] = track.edited[ clipIdx+1 ];\r\n                            track.hovered[ clipIdx ] = track.hovered[ clipIdx+1 ];\r\n                            clipIdx++;\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        while( clipIdx > 0 )\r\n                        {\r\n                            if( trackClips[ clipIdx-1 ].start <= clip.start )\r\n                            {\r\n                                break;\r\n                            }\r\n\r\n                            trackClips[ clipIdx ] = trackClips[ clipIdx-1 ];\r\n                            track.selected[ clipIdx ] = track.selected[ clipIdx-1 ];\r\n                            track.edited[ clipIdx ] = track.edited[ clipIdx-1 ];\r\n                            track.hovered[ clipIdx ] = track.hovered[ clipIdx-1 ];\r\n                            clipIdx--;\r\n                        }\r\n                    }\r\n                    // commit swap\r\n                    trackClips[ clipIdx ] = clip;\r\n                    track.edited[ clipIdx ] = editedFlag;\r\n                    track.selected[ clipIdx ] = selectedFlag;\r\n                    track.hovered[ clipIdx ] = hoveredFlag;\r\n\r\n                    // update selected clip index\r\n                    lcs[ 1 ] = clipIdx;\r\n\r\n                    if( clip.start + clip.duration > this.duration )\r\n                    {\r\n                        this.setDuration( clip.start + clip.duration );\r\n                    }\r\n\r\n                    if( this.onContentMoved )\r\n                    {\r\n                        this.onContentMoved( clip, leastDelta );\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n        else if( e.track && e.buttons == 0 ) // mouse not dragging, just hovering\r\n        {\r\n            this.unHoverAll();\r\n            let clips = this.getClipsInRange( e.track, time, time, 0.00001 );\r\n            if( !e.track.locked && clips )\r\n            {\r\n                this.lastHovered = [ e.track.trackIdx, clips[ 0 ] ];\r\n                e.track.hovered[ clips[ 0 ] ] = true;\r\n\r\n                let clip = e.track.clips[ clips[ 0 ] ];\r\n                if( !clip )\r\n                {\r\n                    return;\r\n                }\r\n\r\n                if( Math.abs( e.localX - this.timeToX( clip.start + clip.duration )) < 8 ) // duration\r\n                {\r\n                    this.canvas.style.cursor = \"col-resize\";\r\n                    this.dragClipMode = \"duration\";\r\n                }\r\n                else if( clip.fadein != undefined && Math.abs( e.localX - this.timeToX( clip.fadein )) < 8 ) // fadein\r\n                {\r\n                    this.canvas.style.cursor = \"e-resize\";\r\n                    this.dragClipMode = \"fadein\";\r\n                }\r\n                else if( clip.fadeout != undefined && Math.abs( e.localX - this.timeToX( clip.fadeout )) < 8 ) // fadeout\r\n                {\r\n                    this.canvas.style.cursor = \"e-resize\";\r\n                    this.dragClipMode = \"fadeout\";\r\n                }\r\n                else\r\n                {\r\n                    this.dragClipMode = \"\";\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.unHoverAll();\r\n        }\r\n    }\r\n\r\n    drawContent( ctx: CanvasRenderingContext2D )\r\n    {\r\n        if( !this.animationClip ) return;\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        const trackHeight = this.trackHeight;\r\n        const scrollY = - this.currentScrollInPixels;\r\n\r\n        ctx.save();\r\n\r\n        for( let i = 0; i < tracks.length; i++ )\r\n        {\r\n            let track = tracks[ i ];\r\n            this.drawTrackWithBoxes( ctx, i * trackHeight + scrollY, trackHeight, track );\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * @method drawTrackWithBoxes\r\n     * @param {*} ctx\r\n     */\r\n    drawTrackWithBoxes( ctx: CanvasRenderingContext2D, y: number, trackHeight: number, track: any )\r\n    {\r\n        // Fill track background if it's selected\r\n        ctx.globalAlpha = 0.2;\r\n        ctx.fillStyle = Timeline.TRACK_SELECTED_LIGHT;\r\n        if( track.isSelected )\r\n        {\r\n            ctx.fillRect( 0, y, ctx.canvas.width, trackHeight );\r\n        }\r\n\r\n        const clips = track.clips;\r\n\r\n        // set clip box size\r\n        const offset = ( trackHeight * 0.4 ) * 0.5;\r\n        trackHeight *= 0.6;\r\n\r\n        let selectedClipArea: any = null;\r\n\r\n        ctx.font = Math.floor( trackHeight * 0.8 ) + \"px\" + Timeline.FONT;\r\n        ctx.textAlign = \"left\";\r\n        ctx.textBaseline = \"middle\";\r\n\r\n        for( var j = 0; j < clips.length; ++j )\r\n        {\r\n            selectedClipArea = null;\r\n            const clip = clips[ j ];\r\n            //let selected = track.selected[ j ];\r\n            var x = Math.floor( this.timeToX( clip.start ) ) + 0.5;\r\n            var x2 = Math.floor( this.timeToX( clip.start + clip.duration ) ) + 0.5;\r\n            var w = x2-x;\r\n\r\n            if( x2 < 0 || x > this.canvas.width )\r\n            {\r\n                continue;\r\n            }\r\n\r\n            // Overwrite clip color state depending on its state\r\n            ctx.globalAlpha = 1;\r\n            ctx.fillStyle = clip.clipColor || ( track.hovered[ j ] ? Timeline.KEYFRAME_COLOR_HOVERED : ( track.selected[ j ] ? Timeline.TRACK_SELECTED : Timeline.KEYFRAME_COLOR ));\r\n            if( !this.active || !track.active || !clip.active ) {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_INACTIVE;\r\n            }\r\n\r\n            // Draw clip background\r\n            drawRoundRect( ctx, x, y + offset, w, trackHeight, 5, true );\r\n\r\n            if( this.active && track.active && clip.active )\r\n            {\r\n                ctx.fillStyle = clip.fadeColor ?? \"#0004\";\r\n\r\n                if( clip.fadein != undefined ) {\r\n                    const fadeinX = this.pixelsPerSecond * ( clip.fadein - clip.start );\r\n                    drawRoundRect( ctx, x, y + offset, fadeinX, trackHeight, { tl: 5, bl: 5, tr:0, br:0 }, true );\r\n                }\r\n                if( clip.fadeout != undefined ) {\r\n                    const fadeoutX = this.pixelsPerSecond * ( clip.start + clip.duration - ( clip.fadeout ));\r\n                    drawRoundRect( ctx, x + w - fadeoutX, y + offset, fadeoutX, trackHeight, { tl: 0, bl: 0, tr:5, br:5}, true );\r\n                }\r\n            }\r\n\r\n            ctx.fillStyle = Timeline.TRACK_COLOR_PRIMARY;\r\n\r\n            if( track.selected[ j ] || track.hovered[ j ] )\r\n            {\r\n                ctx.strokeStyle = ctx.shadowColor = clip.clipColor || Timeline.TRACK_SELECTED;\r\n                ctx.shadowBlur = 10;\r\n                ctx.shadowOffsetX = 1.5;\r\n                ctx.shadowOffsetY = 1.5;\r\n\r\n                selectedClipArea = [ x - 1, y + offset -1, x2 - x + 2, trackHeight + 2 ];\r\n                drawRoundRect( ctx, selectedClipArea[ 0 ], selectedClipArea[ 1 ], selectedClipArea[ 2 ], selectedClipArea[3], 5, false, true );\r\n\r\n                ctx.shadowBlur = 0;\r\n                ctx.shadowOffsetX = 0;\r\n                ctx.shadowOffsetY = 0;\r\n\r\n                ctx.font = \"bold\" + Math.floor( trackHeight ) + \"px \" + Timeline.FONT;\r\n                ctx.fillStyle = Timeline.FONT_COLOR_PRIMARY;\r\n            }\r\n\r\n            let text = clip.id ?? \"\"; //clip.id.replaceAll(\"_\", \" \").replaceAll(\"-\", \" \");\r\n            const textInfo = ctx.measureText( text );\r\n\r\n            let textWidth = textInfo.width;\r\n            if( textWidth > w && textWidth > 0 )\r\n            {\r\n                let amount = Math.floor( w * text.length / textWidth );\r\n                text = text.substr( 0, amount );\r\n                textWidth = w;\r\n            }\r\n\r\n            ctx.fillText( text, x + ( w - textWidth )*0.5,  y + offset + trackHeight * 0.5);\r\n\r\n            ctx.fillStyle = track.hovered[ j ] ? \"white\" : \"#f5f5f5\"//track.hovered[ j ] ? \"white\" : Timeline.FONT_COLOR_QUATERNARY;\r\n            ctx.strokeStyle = \"rgba(125,125,125,0.4)\";\r\n\r\n            // Draw resize bounding\r\n            drawRoundRect( ctx, x + w - 8 , y + offset , 8, trackHeight, { tl: 4, bl: 4, tr: 4, br: 4 }, true, true );\r\n        }\r\n\r\n        ctx.font = \"12px\" + Timeline.FONT;\r\n    }\r\n\r\n    /**\r\n     * @method optimizeTrack\r\n     */\r\n    optimizeTrack( trackIdx: number )\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * @method optimizeTracks\r\n     */\r\n    optimizeTracks()\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n    *\r\n    * @param {Object} clip  clip to be added\r\n    * @param {Int} trackIdx ( optional ) track where to put the clip. -1 will find the first free slot. ***WARNING*** Must call getClipsInRange, before calling this function with a valid trackdIdx\r\n    * @param {Number} offsetTime ( optional ) offset time of current time\r\n    * @param {Number} searchStartTrackIdx ( optional ) if trackIdx is set to -1, this idx will be used as the starting point to find a valid track\r\n    * @returns  a zero/positive value if successful. Otherwise, -1\r\n    */\r\n    addClip( clip: any, trackIdx: number = -1, offsetTime: number = 0, searchStartTrackIdx: number = 0 )\r\n    {\r\n        if( !this.animationClip ) { return -1; }\r\n\r\n        this.deselectAllElements(); // TODO: consider adjusting values of hovered and selected instead of deselecting everything\r\n\r\n        // Update clip information\r\n        let newStart = clip.start + offsetTime;\r\n        if( clip.fadein != undefined ) clip.fadein += ( newStart - clip.start );\r\n        if( clip.fadeout != undefined ) clip.fadeout += ( newStart - clip.start );\r\n        clip.start = newStart;\r\n\r\n        // sanity check\r\n        clip.active = clip.active ?? true;\r\n\r\n        // find appropriate track\r\n        if( trackIdx >= this.animationClip.tracks.length ) // new track ad the end\r\n        {\r\n            trackIdx = this.addNewTrack();\r\n        }\r\n        else if( trackIdx < 0 ) // find first free track slot\r\n        {\r\n            for( let i = searchStartTrackIdx; i < this.animationClip.tracks.length; i++ )\r\n            {\r\n                let clipInCurrentSlot = this.animationClip.tracks[ i ].clips.find( ( t: any ) => {\r\n                    return LX.compareThresholdRange( newStart, clip.start + clip.duration, t.start, t.start+t.duration );\r\n                } );\r\n\r\n                if( !clipInCurrentSlot )\r\n                {\r\n                    trackIdx = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if( trackIdx < 0 )\r\n            {\r\n                trackIdx = this.addNewTrack();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // check specific track slot\r\n            // commented to avoid double checks with \"addclips\" fn\r\n            // let clipsInRange = this.getClipsInRange( this.animationClip.tracks[ trackIdx ], clip.start, clip.start+clip.duration, 0.0001 );\r\n            // if( clipsInRange ) {\r\n            //     return -1;\r\n            // }\r\n        }\r\n\r\n        clip.trackIdx = trackIdx;\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n        // Find new index\r\n        let newIdx = track.clips.findIndex( ( t: any ) => t.start > newStart );\r\n\r\n        // Add as last index\r\n        if( newIdx < 0 )\r\n        {\r\n            newIdx = track.clips.length;\r\n        }\r\n\r\n        //Save track state before add the new clip\r\n        this.saveState( trackIdx );\r\n\r\n        // Add clip\r\n        track.clips.splice( newIdx, 0, clip ); //insert clip into newIdx ( or push at the end )\r\n\r\n        // Reset this clip's properties\r\n        track.hovered.splice( newIdx, 0, false );\r\n        track.selected.splice( newIdx, 0, false );\r\n        track.edited.splice( newIdx, 0, false );\r\n\r\n        if( !this.animationClip || ( clip.start + clip.duration ) > this.duration )\r\n        {\r\n            this.setDuration( clip.start + clip.duration );\r\n        }\r\n\r\n        // Update animation action interpolation info\r\n        if( this.onUpdateTrack )\r\n        {\r\n            this.onUpdateTrack( [ trackIdx ] );\r\n        }\r\n\r\n        return newIdx;\r\n    }\r\n\r\n    /**\r\n     *  Add an array of clips to the timeline in the first suitable tracks. It tries to put clips in the same track if possible. All clips will be in adjacent tracks to each other\r\n     * @param {Object[] } clips\r\n     * @param {Number} offsetTime\r\n     * @param {Int} searchStartTrackIdx\r\n     * @returns\r\n     */\r\n    addClips( clips: any[], offsetTime: number = 0, searchStartTrackIdx: number = 0 )\r\n    {\r\n        if( !this.animationClip || !clips.length ) return false;\r\n\r\n        let clipTrackIdxs = new Int16Array( clips.length );\r\n        let baseTrackIdx = searchStartTrackIdx -1; // every time the algorithm fails, it increments the starting track Idx\r\n        let currTrackIdx = -1;\r\n        const tracks = this.animationClip.tracks;\r\n        const lastTrackLength = tracks.length;\r\n        let c = 0;\r\n        for( ; c < clips.length; ++c )\r\n        {\r\n            const clip = clips[ c ];\r\n            const clipStart = clip.start + offsetTime;\r\n            const clipEnd = clipStart + clip.duration;\r\n\r\n            if( c == 0 ) { // last search failed, move one track down and check again\r\n                ++baseTrackIdx;\r\n                currTrackIdx = baseTrackIdx;\r\n\r\n                while ( currTrackIdx >= tracks.length ) { this.addNewTrack( null, false ); }\r\n                let clipsInCurrentSlot = tracks[baseTrackIdx ].clips.find( ( t: any ) => { return LX.compareThresholdRange( clipStart, clipEnd, t.start, t.start+t.duration ); } );\r\n\r\n                // reset search\r\n                if( clipsInCurrentSlot )\r\n                {\r\n                    c = -1;\r\n                    continue;\r\n                }\r\n\r\n                // success\r\n                clipTrackIdxs[ c ] = baseTrackIdx;\r\n            }\r\n            else\r\n            {\r\n                // check if it fits in current track\r\n                let clipsInCurrentSlot = tracks[ currTrackIdx ].clips.find( ( t: any ) => { return LX.compareThresholdRange( clipStart, clipEnd, t.start, t.start+t.duration ); } );\r\n\r\n                // check no previous added clips are in the way\r\n                for( let i = c-1; i > -1; --i )\r\n                {\r\n                    if( clipTrackIdxs[ i ] != currTrackIdx || clipsInCurrentSlot ) { break; }\r\n                    clipsInCurrentSlot = LX.compareThresholdRange( clipStart, clipEnd, clips[ i ].start + offsetTime, clips[ i ].start + offsetTime + clips[ i ].duration );\r\n                }\r\n\r\n                // check if it fits in the next track\r\n                if( clipsInCurrentSlot )\r\n                {\r\n                    ++currTrackIdx;\r\n                    if( currTrackIdx >= tracks.length ) { this.addNewTrack( null, false ); }\r\n                    clipsInCurrentSlot = tracks[ currTrackIdx ].clips.find( ( t:any ) => { return LX.compareThresholdRange( clipStart, clipEnd, t.start, t.start+t.duration ); } );\r\n                }\r\n\r\n                // reset search\r\n                if( clipsInCurrentSlot )\r\n                {\r\n                    c = -1;\r\n                    continue;\r\n                }\r\n\r\n                // success\r\n                clipTrackIdxs[ c ] = currTrackIdx;\r\n            }\r\n        }\r\n\r\n        // avoid updating panel on each new track. Instead just once at the end\r\n        if( lastTrackLength != tracks.length )\r\n        {\r\n            this.updateLeftPanel();\r\n        }\r\n\r\n        // save state for all to-be-modified tracks. Do it once for all tracks\r\n        for( let i = baseTrackIdx; i <= currTrackIdx; ++i )\r\n        {\r\n            this.saveState( i, i != baseTrackIdx );\r\n        }\r\n\r\n        // disable history saving\r\n        let oldStateEnabler = this.historySaveEnabler;\r\n        this.historySaveEnabler = false;\r\n\r\n        for( c = 0; c < clips.length; ++c )\r\n        {\r\n            this.addClip( clips[ c ], clipTrackIdxs[ c ], offsetTime );\r\n        }\r\n\r\n        // recover old state of enabler\r\n        this.historySaveEnabler = oldStateEnabler;\r\n\r\n        return true;\r\n    }\r\n\r\n    deleteSelectedContent( skipCallback: boolean = false )\r\n    {\r\n        //*********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n        if( !this.lastClipsSelected.length )\r\n        {\r\n            return;\r\n        }\r\n\r\n        // delete selected clips from last to first. lastClipsSelected is sorted\r\n        const selected = this.lastClipsSelected;\r\n        this.lastClipsSelected = []; // so this.#delete does not check clipsselected on each loop ( all will be destroyed )\r\n        let prevTrack = -1;\r\n        for( let i = selected.length - 1; i > -1; --i )\r\n        {\r\n            let s = selected[ i ];\r\n            if( s[ 0 ] != prevTrack )\r\n            {\r\n                this.saveState( s[ 0 ], prevTrack != -1 );\r\n                prevTrack = s[ 0 ];\r\n            }\r\n\r\n           this.#delete( s[ 0 ], s[ 1 ] );\r\n        }\r\n\r\n        if( this.onDeleteSelectedClips && !skipCallback )\r\n        {\r\n            this.onDeleteSelectedClips( selected );\r\n        }\r\n\r\n    }\r\n\r\n    /** Delete clip from the timeline\r\n     * @param {Number} trackIdx\r\n     * @param {Number} clipIdx clip to be deleted\r\n    */\r\n    deleteClip( trackIdx: number, clipIdx: number, skipCallback: boolean = false )\r\n    {\r\n        this.saveState( trackIdx );\r\n        const clip = this.#delete( trackIdx, clipIdx );\r\n\r\n        if( this.onDeleteClip && !skipCallback )\r\n        {\r\n            this.onDeleteClip( trackIdx, clipIdx, clip );\r\n        }\r\n    }\r\n\r\n    #delete( trackIdx: number, clipIdx: number )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n        // remove from selected clips\r\n        for( let i = 0; i < this.lastClipsSelected.length; i++ )\r\n        {\r\n            const [ selectedTrackIdx, selectedClipIdx ] = this.lastClipsSelected[ i ];\r\n            if( selectedTrackIdx == trackIdx )\r\n            {\r\n                if( selectedClipIdx == clipIdx ) { // remove self\r\n                    this.lastClipsSelected.splice( i--,1 );\r\n                }else if( selectedClipIdx > clipIdx ) { // move upper clips to the left\r\n                    this.lastClipsSelected[ i ][ 1 ]--;\r\n                }\r\n            }\r\n            else if( trackIdx < selectedTrackIdx )\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if( this.lastHovered && this.lastHovered[ 0 ] == trackIdx )\r\n        {\r\n            if( this.lastHovered[ 1 ] == clipIdx ) { this.unHoverAll(); }\r\n            else if( this.lastHovered[ 1 ] > clipIdx ) { this.lastHovered[ 1 ]--; }\r\n        }\r\n\r\n        const clip = track[ clipIdx ];\r\n        track.hovered.splice( clipIdx,1 );\r\n        track.selected.splice( clipIdx,1 );\r\n        track.edited.splice( clipIdx,1 );\r\n        track.clips.splice( clipIdx, 1 );\r\n        return clip;\r\n    }\r\n\r\n    /**\r\n     * User defined. Used when copying and pasting\r\n     * @param {Array of clips } clipsToClone array of original clips. Do not modify clips in this array\r\n     * @param {Number} timeOffset Value of time that should be added ( or subtracted ) from the timing attributes\r\n     * @param {Int} reason Flag to signal the reason of the clone\r\n     * @returns {Array of clips }\r\n     */\r\n    cloneClips( clipsToClone: any[], timeOffset: number, reason: number = 0 )\r\n    {\r\n        let clipsToReturn = JSON.parse(JSON.stringify( clipsToClone ))\r\n        for( let i = 0; i < clipsToReturn.length; ++i )\r\n        {\r\n            let clip = clipsToReturn[ i ];\r\n            clip.start += timeOffset;\r\n            if( clip.fadein == null || clip.fadein == undefined ) { clip.fadein = undefined; }\r\n            else { clip.fadein += timeOffset; }\r\n\r\n            if( clip.fadeout == null || clip.fadeout == undefined ) { clip.fadeout = undefined; }\r\n            else { clip.fadeout += timeOffset; }\r\n        }\r\n\r\n        return clipsToReturn;\r\n    }\r\n\r\n    /**\r\n     * Overwrite the \"cloneClips\" function to provide a custom cloning of clips. Otherwise, JSON serialization is used\r\n     */\r\n    copySelectedContent()\r\n    {\r\n        if( this.lastClipsSelected.length == 0 )\r\n        {\r\n            return;\r\n        }\r\n\r\n        let clipsToCopy: any = [];\r\n        const lastClipsSelected = this.lastClipsSelected;\r\n        const tracks = this.animationClip.tracks;\r\n        let globalStart = Infinity;\r\n        for( let i = 0; i < lastClipsSelected.length; ++i )\r\n        {\r\n            let clip: any = tracks[ lastClipsSelected[ i ][ 0 ] ].clips[ lastClipsSelected[ i ][ 1 ] ];\r\n            clipsToCopy.push( clip );\r\n            if( globalStart > clip.start ) { globalStart = clip.start; }\r\n        }\r\n\r\n        globalStart = Math.max( 0, globalStart );\r\n        this.clipboard = this.cloneClips( clipsToCopy, -globalStart, ClipsTimeline.CLONEREASON_COPY );\r\n    }\r\n\r\n    pasteContent( time: number = this.currentTime )\r\n    {\r\n        this.deselectAllClips();\r\n\r\n        if( !this.clipboard )\r\n        {\r\n            return;\r\n        }\r\n\r\n        time = Math.max( 0, time );\r\n\r\n        let clipsToAdd = this.cloneClips( this.clipboard, time, ClipsTimeline.CLONEREASON_PASTE );\r\n        this.addClips( clipsToAdd, 0 );\r\n    }\r\n\r\n    /**\r\n     * @method clearTrack\r\n     */\r\n\r\n    clearTrack( trackIdx: number )\r\n    {\r\n        if( !this.animationClip )\r\n        {\r\n            this.animationClip = { tracks: [] };\r\n            return;\r\n        }\r\n\r\n        this.saveState( trackIdx );\r\n\r\n        if( this.animationClip.tracks[ trackIdx ].locked ) {\r\n            return;\r\n        }\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        track.selected = [];\r\n        track.edited = [];\r\n        track.hovered = [];\r\n        track.clips = [];\r\n\r\n        // remove from selected clips\r\n        for( let i = 0; i < this.lastClipsSelected.length; i++ )\r\n        {\r\n            const [ selectedTrackIdx, selectedClipIdx ] = this.lastClipsSelected[ i ];\r\n            if( selectedTrackIdx == trackIdx )\r\n            {\r\n                this.lastClipsSelected.splice( i--,1 );\r\n            }\r\n            else if( trackIdx < selectedTrackIdx )\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if( this.lastHovered && this.lastHovered[ 0 ] == trackIdx ) { this.unHoverAll(); }\r\n\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * saveState function uses this to generate a \"copy\" of the track.\r\n     * @param {Number} trackIdx\r\n     * @returns All necessary information to reconstruct the track state\r\n     */\r\n    historyGenerateTrackStep( trackIdx: number )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        const clips = this.cloneClips( track.clips, 0, ClipsTimeline.CLONEREASON_HISTORY );\r\n\r\n        // sanity check in case cloneClips misses this\r\n        for( let i = 0; i < clips.length; ++i )\r\n        {\r\n            clips[ i ].trackIdx = trackIdx;\r\n        }\r\n\r\n        const undoStep = {\r\n            trackIdx: trackIdx, // already done by saveState\r\n            clips: clips,\r\n            edited: track.edited.slice( 0, track.clips.length )\r\n        };\r\n\r\n        return undoStep;\r\n    }\r\n\r\n    /**\r\n     * It should swap the previous state with the incoming state of the track. It must return the previous state.\r\n     * historyGenerateTrackStep could be used to copy the previous state. However, as it is a swap, it suffices to just copy the references.\r\n     * @param {Object} state object with a trackIdx:Number and whatever information was saved in historyGenerateTrackStep\r\n     * @param {Boolean} isUndo\r\n     * @returns previous state object\r\n     */\r\n    historyApplyTrackStep( state: any, isUndo: boolean )\r\n    {\r\n        const track = this.animationClip.tracks[ state.trackIdx ];\r\n\r\n        const stateToReturn = {\r\n            trackIdx: state.trackIdx, // already done by saveState\r\n            clips: track.clips,\r\n            edited: track.edited\r\n        };\r\n\r\n        track.clips = state.clips;\r\n        track.edited = state.edited;\r\n        if( track.selected.length < track.clips.length ) { track.selected.length = track.clips.length; }\r\n        if( track.hovered.length < track.clips.length ) { track.hovered.length = track.clips.length; }\r\n        track.selected.fill( false );\r\n        track.hovered.fill( false );\r\n\r\n        // sanity check. Also done in addClip\r\n        for( let i = 0; i < track.clips.length; ++i )\r\n        {\r\n            track.clips[ i ].active = track.clips[ i ].active ?? true;\r\n        }\r\n\r\n        return stateToReturn;\r\n    }\r\n\r\n    getClipOnTime( track: any, time: number, threshold: number )\r\n    {\r\n        if( !track || !track.clips.length )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        // Avoid iterating through all timestamps\r\n        if( ( time + threshold ) < track.clips[ 0 ].start )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        for( let i = 0; i < track.clips.length; ++i )\r\n        {\r\n            let t = track.clips[ i ];\r\n            if( t.start + t.duration >= ( time - threshold ) && t.start <= ( time + threshold ) )\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    };\r\n\r\n    deselectAllClips()\r\n    {\r\n        for( let [ trackIdx, clipIdx ] of this.lastClipsSelected )\r\n        {\r\n            this.animationClip.tracks[ trackIdx ].selected[ clipIdx ]= false;\r\n        }\r\n\r\n        // Something has been deselected\r\n        const deselected = this.lastClipsSelected.length > 0;\r\n        this.lastClipsSelected.length = 0;\r\n        return deselected;\r\n    }\r\n\r\n    selectAll( skipCallback = false )\r\n    {\r\n        this.deselectAllClips();\r\n\r\n        for( let trackIdx = 0; trackIdx < this.animationClip.tracks.length; trackIdx++ )\r\n        {\r\n            for( let clipIdx = 0; clipIdx < this.animationClip.tracks[ trackIdx ].clips.length; clipIdx++ )\r\n            {\r\n                this.animationClip.tracks[ trackIdx ].selected[ clipIdx ] = true;\r\n                this.lastClipsSelected.push( [ trackIdx, clipIdx ] ); // already sorted\r\n            }\r\n        }\r\n\r\n        if( this.onSelectClip && !skipCallback )\r\n        {\r\n            this.onSelectClip( null );\r\n        }\r\n    }\r\n\r\n    selectClip( trackIdx: number, clipIndex: number, deselect: boolean = true, skipCallback: boolean = false )\r\n    {\r\n        if( deselect )\r\n        {\r\n            this.deselectAllClips();\r\n        }\r\n\r\n        if( clipIndex < 0 )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        if( track.selected[ clipIndex ] )\r\n        {\r\n            return clipIndex;\r\n        }\r\n\r\n        // Select if not handled\r\n\r\n        // push selection sorted by track index and clip index\r\n        let i = 0;\r\n        for( ; i < this.lastClipsSelected.length; ++i )\r\n        {\r\n            let t = this.lastClipsSelected[ i ];\r\n            if( t[ 0 ] < track.trackIdx ) { continue; }\r\n            if( t[ 0 ] > track.trackIdx || t[ 1 ] > clipIndex ) { break;}\r\n        }\r\n        this.lastClipsSelected.splice( i,0, [ track.trackIdx, clipIndex, track.clips[ clipIndex ] ] ); //\r\n        track.selected[ clipIndex ] = true;\r\n\r\n        if( !skipCallback && this.onSelectClip )\r\n        {\r\n            this.onSelectClip( track.clips[ clipIndex ] );\r\n            // Event handled\r\n        }\r\n        return clipIndex;\r\n    }\r\n\r\n    deselectClip( trackIdx: number, clipIndex: number )\r\n    {\r\n        if( clipIndex == -1 )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        if( !track.selected[ clipIndex ] )\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        track.selected[ clipIndex ] = false;\r\n\r\n        // deselect\r\n        for( let i = 0; i < this.lastClipsSelected.length; ++i )\r\n        {\r\n            let t = this.lastClipsSelected[ i ];\r\n            if( t[ 0 ] == trackIdx && t[ 1 ] == clipIndex )\r\n            {\r\n                this.lastClipsSelected.splice( i, 1 );\r\n                break;\r\n            }\r\n        }\r\n\r\n        return clipIndex;\r\n    }\r\n\r\n    getClipsInRange( track: any, minTime: number, maxTime: number, threshold: number = 0 )\r\n    {\r\n        if( !track || !track.clips.length )\r\n        return null;\r\n\r\n        // Manage negative selection\r\n        if( minTime > maxTime ) {\r\n            let aux = minTime;\r\n            minTime = maxTime;\r\n            maxTime = aux;\r\n        }\r\n\r\n        minTime -= threshold;\r\n        maxTime += threshold;\r\n\r\n        // Avoid iterating through all timestamps\r\n        minTime -= threshold;\r\n        maxTime += threshold;\r\n\r\n        const clips = track.clips;\r\n        if( maxTime < clips[ 0 ].start || minTime > ( clips[ clips.length - 1 ].start + clips[ clips.length - 1 ].duration ) )\r\n        {\r\n            return null;\r\n        }\r\n\r\n        let indices: number[] = [];\r\n\r\n        for( let i = 0; i < clips.length; ++i )\r\n        {\r\n            const c = clips[ i ];\r\n            if( c.start+c.duration < minTime ) { continue; }\r\n            if( c.start > maxTime ) { break; }\r\n            indices.push( i );\r\n        }\r\n\r\n        return indices.length ? indices : null;\r\n    }\r\n\r\n    validateDuration( t: number )\r\n    {\r\n        for( let i = 0; i < this.animationClip.tracks.length; i++ )\r\n        {\r\n            const track = this.animationClip.tracks[ i ];\r\n            if( track.clips.length )\r\n            {\r\n                const clip = track.clips[ track.clips.length - 1 ]; // assuming they are ordered ascendently\r\n                t = Math.max( t, clip.start + clip.duration );\r\n            }\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    setDuration( t: number, skipCallback: boolean = false, updateHeader: boolean = true )\r\n    {\r\n        const oldT = t;\r\n        const newT = this.validateDuration( t );\r\n        super.setDuration( newT, skipCallback, oldT != newT || updateHeader );\r\n    }\r\n}\r\n\r\nLX.ClipsTimeline = ClipsTimeline;\r\n\r\n/**\r\n * Draws a rounded rectangle using the current state of the canvas.\r\n * If you omit the last three params, it will draw a rectangle\r\n * outline with a 5 pixel border radius\r\n * @param {Number} x The top left x coordinate\r\n * @param {Number} y The top left y coordinate\r\n * @param {Number} width The width of the rectangle\r\n * @param {Number} height The height of the rectangle\r\n * @param {Number} [radius = 5] The corner radius; It can also be an object\r\n *                 to specify different radii for corners\r\n * @param {Number} [radius.tl = 0] Top left\r\n * @param {Number} [radius.tr = 0] Top right\r\n * @param {Number} [radius.br = 0] Bottom right\r\n * @param {Number} [radius.bl = 0] Bottom left\r\n * @param {Boolean} [ fill = false ] Whether to fill the rectangle.\r\n * @param {Boolean} [ stroke = true ] Whether to stroke the rectangle.\r\n */\r\n\r\nfunction drawRoundRect( ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: any = 5, fill: boolean = false, stroke: boolean = false )\r\n{\r\n    if( typeof radius === 'number')\r\n    {\r\n        radius = { tl: radius, tr: radius, br: radius, bl: radius };\r\n    }\r\n    else\r\n    {\r\n        var defaultRadius: any = { tl: 0, tr: 0, br: 0, bl: 0 };\r\n        for ( var side in defaultRadius )\r\n        {\r\n            radius[ side ] = radius[ side ] ?? defaultRadius[ side ];\r\n        }\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(x + radius.tl, y );\r\n    ctx.lineTo(x + width - radius.tr, y );\r\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr );\r\n    ctx.lineTo(x + width, y + height - radius.br );\r\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height );\r\n    ctx.lineTo(x + radius.bl, y + height );\r\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl );\r\n    ctx.lineTo(x, y + radius.tl );\r\n    ctx.quadraticCurveTo(x, y, x + radius.tl, y );\r\n    ctx.closePath();\r\n\r\n    if( fill )\r\n    {\r\n        ctx.fill();\r\n    }\r\n\r\n    if( stroke )\r\n    {\r\n        ctx.stroke();\r\n    }\r\n}"],"names":[],"mappings":"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"}