{"version":3,"file":"Timeline.js","sources":["../../src/extensions/Timeline.ts"],"sourcesContent":["// Timeline.ts @evallsg, @japopra\r\n\r\nimport { LX } from '../core/Namespace';\r\n\r\nif( !LX )\r\n{\r\n    throw( \"Missing LX namespace!\" );\r\n}\r\n\r\nLX.extensions.push( 'Timeline' );\r\n\r\nLX.registerIcon(\"TimelineLock\", '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path fill=\"none\" d=\"M7 11V7a4 4 0 0 1 9 0v4 M5,11h13 a2 2 0 0 1 2 2 v7 a2 2 0 0 1 -2 2 h-13 a2 2 0 0 1 -2 -2 v-7 a2 2 0 0 1 2 -2 M12 16 v2\"/></svg>' );\r\nLX.registerIcon(\"TimelineLockOpen\", '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path fill=\"none\" d=\"M14 11V7a4 4 0 0 1 9 0v2 M3,11h13 a2 2 0 0 1 2 2 v7 a2 2 0 0 1 -2 2 h-13 a2 2 0 0 1 -2 -2 v-7 a2 2 0 0 1 2 -2 M8 17 h3\"/></svg>' );\r\n\r\nconst Area = LX.Area;\r\nconst Panel = LX.Panel;\r\nconst Dialog = LX.Dialog;\r\nconst TreeEvent = LX.TreeEvent;\r\n\r\ntype Nullable<T> = T | null | undefined;\r\n\r\n/**\r\n * @class Timeline\r\n * @description Agnostic timeline, do not impose any timeline content. Renders to a canvas\r\n */\r\n\r\nexport abstract class Timeline\r\n{\r\n    static BACKGROUND_COLOR: string;\r\n    static TRACK_COLOR_PRIMARY: string;\r\n    static TRACK_COLOR_SECONDARY: string;\r\n    static TRACK_COLOR_TERCIARY: string;\r\n    static TRACK_COLOR_QUATERNARY: string;\r\n    static TRACK_SELECTED: string\r\n    static TRACK_SELECTED_LIGHT: string\r\n    static FONT: string;\r\n    static FONT_COLOR_PRIMARY: string;\r\n    static FONT_COLOR_TERTIARY: string;\r\n    static FONT_COLOR_QUATERNARY: string;\r\n    static KEYFRAME_COLOR: string;\r\n    static KEYFRAME_COLOR_HOVERED: string;\r\n    static KEYFRAME_COLOR_SELECTED: string;\r\n    static KEYFRAME_COLOR_LOCK: string;\r\n    static KEYFRAME_COLOR_EDITED: string;\r\n    static KEYFRAME_COLOR_INACTIVE: string;\r\n    static TIME_MARKER_COLOR: string\r\n    static TIME_MARKER_COLOR_TEXT: string\r\n    static BOX_SELECTION_COLOR: string\r\n\r\n\r\n    uniqueID: string;\r\n    timelineTitle: string;\r\n\r\n    animationClip: any;\r\n\r\n    duration: number = 1;\r\n    currentTime: number = 0; // seconds\r\n    visualTimeRange: [number,number] = [0,0]; // [start time, end time] - visible range of time. 0 <= time <= duration\r\n    visualOriginTime: number = 0; // time visible at pixel 0. -infinity < time < infinity\r\n    pixelsPerSecond: number = 300;\r\n    secondsPerPixel: number;\r\n\r\n    clickTime: number = 0; // real world time when mouse was pressed down. Used for discard\r\n    clickDiscardTimeout: number = 200; // ms\r\n    lastMouse: [number,number] = [0,0];\r\n    boxSelection: boolean = false;\r\n    boxSelectionStart: [number, number] = [0,0];\r\n    boxSelectionEnd: [number, number] = [0,0];\r\n\r\n    historyUndo: Array<any> = [];\r\n    historyRedo: Array<any> = [];\r\n    historySaveEnabler: boolean = true; // used in saveState\r\n    historyMaxSteps: number = 100; // used in saveState\r\n    clipboard: any = null;\r\n\r\n    grabbing: boolean = false;\r\n    grabTime: number = 0;\r\n    grabbingTimeBar: boolean = false;\r\n    grabbingScroll: boolean = false;\r\n    movingKeys: boolean = false;\r\n    timeBeforeMove: number = 0;\r\n\r\n    currentScroll: number = 0; //in percentage\r\n    currentScrollInPixels: number = 0; //in pixels\r\n    trackHeight: number = 32;\r\n    timeSeparators: number[] = [0.01, 0.1, 0.5, 1, 5];\r\n\r\n    playing: boolean = false;\r\n    loop: boolean = true;\r\n    active: boolean = true;\r\n    skipVisibility: boolean;\r\n    skipLock: boolean;\r\n    disableNewTracks: boolean;\r\n\r\n    optimizeThreshold: number = 0.01;\r\n\r\n    selectedTracks: any[] = []; // [track, track] contains selected (highlighted) tracks. That is, tracks with .isSelected == true. Elements in array are not ordered. Only visible tracks should be selected\r\n    selectedItems: any[] = []; // [trackInfo, \"groupId\"], contains the visible items (tracks or groups) of the timeline\r\n    leftPanel: typeof Panel; // where tree will be placed\r\n    trackTreesPanel: any = null;\r\n    trackTreesComponent: any = null;\r\n    lastTrackTreesComponentOffset: any = 0; // this.trackTreesComponent.innerTree.domEl.offsetTop - canvas.offsetTop. Check draw()\r\n\r\n    mainArea: typeof Area;\r\n    root: HTMLBodyElement;\r\n    header: typeof Panel;\r\n    canvasArea: typeof Area; // parent of canvas\r\n    canvas: HTMLCanvasElement;\r\n    size: [number, number] = [0.000001, 0.000001];\r\n    topMargin: number = 40;\r\n    header_offset: number = 48;\r\n\r\n    updateTheme: () => void;\r\n\r\n    onCreateBeforeTopBar: Nullable< ( headerPanel : typeof Panel ) => void > = null;\r\n    onCreateAfterTopBar: Nullable< ( headerPanel : typeof Panel ) => void > = null;\r\n    onCreateControlsButtons: Nullable< ( headerPanel : typeof Panel ) => void > = null;\r\n    onCreateSettingsButtons: Nullable< ( headerPanel : typeof Panel ) => void > = null;\r\n    onShowOptimizeMenu: Nullable< ( event: any ) => void > = null;\r\n    onShowConfiguration: Nullable< ( panel: typeof Panel ) => void > = null;\r\n    onMouse: Nullable< (event: any, t: number) => void > = null;\r\n    onDblClick: Nullable< (event: any) => void > = null;\r\n    onShowContextMenu: Nullable< (event: any) => void > = null;\r\n    onAddNewTrackButton: Nullable< () => void > = null; // overrides button \"add track\" behaviour\r\n    onAddNewTrack: Nullable< (track: any, options: any) => void > = null;\r\n    onTrackTreeEvent: Nullable< (event: typeof TreeEvent ) => void > = null;\r\n    onBeforeDrawContent: Nullable< (ctx: CanvasRenderingContext2D ) => void > = null;\r\n    onStateStop: Nullable< () => void > = null;\r\n    onStateChange: Nullable< (s: boolean) => void > = null;\r\n    onChangeLoopMode: Nullable< (l: boolean) => void > = null;\r\n    onSetDuration: Nullable< (d: number) => void > = null;\r\n    onSetTime: Nullable< (t: number) => void > = null;\r\n    onItemSelected: Nullable< (selected: any[], itemsToAdd: Nullable< any[] >, itemsToRemove: Nullable< any[] >) => void > = null;\r\n    onSetTrackSelection: Nullable< (track: object, oldValue: boolean) => void > = null;\r\n    onSetTrackState: Nullable< (track: object, oldValue: boolean) => void > = null;\r\n    onSetTrackLock: Nullable< (track: object, oldValue: boolean) => void > = null;\r\n    onUpdateTrack: Nullable< (tracks: number[] | string[] ) => void > = null;\r\n\r\n    configurationDialog: Nullable< typeof Dialog > = null;\r\n\r\n    abstract onMouseUp(event: any, t: number): void;\r\n    abstract onMouseDown(event: any, t: number): void;\r\n    abstract onMouseMove(event: any, t: number): void;\r\n\r\n    abstract drawContent(ctx: CanvasRenderingContext2D): void;\r\n    abstract deleteSelectedContent(skipCallback: boolean): void;\r\n    abstract copySelectedContent(): void;\r\n    abstract pasteContent(time: number): void;\r\n    abstract historyGenerateTrackStep(trackIdx: number): any;\r\n    abstract historyApplyTrackStep(state: any, isUndo: boolean): any;\r\n\r\n    /**\r\n     * @param {String} id = string unique id\r\n     * @param {Object} options = {skipLock, skipVisibility}\r\n     */\r\n    constructor( id : string, options: any = {} )\r\n    {\r\n        this.uniqueID = id ?? ('timeline' + Math.floor(Math.random()*0xffffffff));\r\n        this.timelineTitle = options.title ?? null;\r\n\r\n        // required before updateHeader\r\n        this.onCreateBeforeTopBar = options.onCreateBeforeTopBar;\r\n        this.onCreateAfterTopBar = options.onCreateAfterTopBar;\r\n        this.onCreateControlsButtons = options.onCreateControlsButtons;\r\n        this.onCreateSettingsButtons = options.onCreateSettingsButtons;\r\n        this.onShowOptimizeMenu = options.onShowOptimizeMenu;\r\n        this.onShowConfiguration = options.onShowConfiguration;\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.style.width = \"100%\";\r\n        this.canvas.style.height = \"100%\";\r\n\r\n        this.secondsPerPixel = 1 / this.pixelsPerSecond;\r\n        this.animationClip = this.instantiateAnimationClip();\r\n\r\n        this.loop = options.loop ?? true;\r\n        this.skipVisibility = options.skipVisibility ?? false;\r\n        this.skipLock = options.skipLock ?? false;\r\n        this.disableNewTracks = options.disableNewTracks ?? false;\r\n\r\n        // main area -- root\r\n        this.mainArea = new Area({className : 'lextimeline'});\r\n        this.root = this.mainArea.root;\r\n        this.mainArea.split({ type: \"vertical\", sizes: [this.header_offset, \"auto\"],  resize: false});\r\n\r\n        // header\r\n        this.header = new Panel( { id: 'lextimelineheader'} );\r\n        this.mainArea.sections[ 0 ].attach( this.header );\r\n        this.updateHeader();\r\n\r\n        // content area\r\n        const contentArea = this.mainArea.sections[ 1 ];\r\n        contentArea.root.id = \"bottom-timeline-area\";\r\n        contentArea.split({ type: \"horizontal\", sizes: [\"15%\", \"85%\"] });\r\n        let [ left, right ] = contentArea.sections;\r\n\r\n        right.attach( this.canvas );\r\n        this.canvasArea = right;\r\n        this.canvasArea.root.classList.add(\"lextimelinearea\");\r\n\r\n        this.leftPanel = left.addPanel( { className: 'lextimelinepanel', width: \"100%\", height: \"100%\" } );\r\n        this.updateLeftPanel();\r\n\r\n        if( this.uniqueID.length )\r\n        {\r\n            this.root.id = this.uniqueID;\r\n            this.canvas.id = this.uniqueID + '-canvas';\r\n        }\r\n\r\n        // Process mouse events\r\n        this.canvas.addEventListener(\"mousedown\", this.processMouse.bind(this));\r\n        this.canvas.addEventListener(\"mouseup\", this.processMouse.bind(this));\r\n        this.canvas.addEventListener(\"mousemove\", this.processMouse.bind(this));\r\n        this.canvas.addEventListener(\"wheel\", this.processMouse.bind(this));\r\n        this.canvas.addEventListener(\"dblclick\", this.processMouse.bind(this));\r\n        this.canvas.addEventListener(\"contextmenu\", this.processMouse.bind(this));\r\n\r\n        this.canvas.tabIndex = 1;\r\n        // Process keys events\r\n        this.canvasArea.root.addEventListener(\"keydown\", (e: KeyboardEvent) =>{ this.processKeys( e ); }); // so this.processKeys can be overwritten by the user\r\n\r\n        this.canvasArea.onresize = (bounding : {width: number, height: number} ) =>\r\n        {\r\n            if( !( bounding.width && bounding.height ) )\r\n            {\r\n                return;\r\n            }\r\n            this.resizeCanvas();\r\n        }\r\n        this.resize( this.size );\r\n\r\n        /**\r\n         * updates theme (light - dark) based on LX's current theme\r\n         */\r\n        function updateTheme( )\r\n        {\r\n            Timeline.BACKGROUND_COLOR = LX.getThemeColor(\"global-blur-background\");\r\n            Timeline.TRACK_COLOR_PRIMARY = LX.getThemeColor(\"global-color-primary\");\r\n            Timeline.TRACK_COLOR_SECONDARY = LX.getThemeColor(\"global-color-secondary\");\r\n            Timeline.TRACK_COLOR_TERCIARY = LX.getThemeColor(\"global-color-terciary\");\r\n            Timeline.TRACK_COLOR_QUATERNARY = LX.getThemeColor(\"global-color-quaternary\");\r\n            Timeline.FONT = LX.getThemeColor(\"global-font\");\r\n            Timeline.FONT_COLOR_PRIMARY = LX.getThemeColor(\"global-text-primary\");\r\n            Timeline.FONT_COLOR_TERTIARY = LX.getThemeColor(\"global-text-tertiary\");\r\n            Timeline.FONT_COLOR_QUATERNARY = LX.getThemeColor(\"global-text-quaternary\");\r\n            Timeline.KEYFRAME_COLOR = LX.getThemeColor(\"lxTimeline-keyframe\");\r\n            Timeline.KEYFRAME_COLOR_SELECTED = Timeline.KEYFRAME_COLOR_HOVERED = LX.getThemeColor(\"lxTimeline-keyframe-selected\");\r\n            Timeline.KEYFRAME_COLOR_LOCK = LX.getThemeColor(\"lxTimeline-keyframe-locked\");\r\n            Timeline.KEYFRAME_COLOR_EDITED = LX.getThemeColor(\"lxTimeline-keyframe-edited\");\r\n            Timeline.KEYFRAME_COLOR_INACTIVE = LX.getThemeColor(\"lxTimeline-keyframe-inactive\");\r\n        }\r\n\r\n        this.updateTheme = updateTheme.bind( this );\r\n        LX.addSignal( \"@on_new_color_scheme\", this.updateTheme );\r\n    }\r\n\r\n    // makes it ready to be deleted\r\n    clear()\r\n    {\r\n        if( this.header )\r\n        {\r\n            this.header.clear();\r\n        }\r\n\r\n        if( this.leftPanel )\r\n        {\r\n            this.leftPanel.clear();\r\n        }\r\n\r\n        if( this.updateTheme )\r\n        {\r\n            let signals = LX.signals[ \"@on_new_color_scheme\" ] ?? [];\r\n            for( let i = 0; i < signals.length; ++i )\r\n            {\r\n                if( signals[ i ] == this.updateTheme )\r\n                {\r\n                    signals.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method updateHeader\r\n     */\r\n    updateHeader()\r\n    {\r\n        this.header.clear();\r\n\r\n        const header = this.header;\r\n        header.sameLine();\r\n\r\n        if( this.timelineTitle )\r\n        {\r\n            header.addTitle(this.timelineTitle, { style: { background: \"none\", fontSize: \"18px\", fontStyle: \"bold\", alignItems: \"center\" } } );\r\n        }\r\n\r\n        const buttonContainer = LX.makeContainer( [\"auto\", \"100%\"], \"flex flex-row gap-1\" );\r\n\r\n        header.queue( buttonContainer );\r\n\r\n        const playbtn = header.addButton(\"playBtn\", '', (value: any, event: Event) => {\r\n           this.changeState();\r\n        }, { buttonClass: \"accept\", title: \"Play\", hideName: true, icon: \"Play@solid\", swap: \"Pause@solid\" });\r\n        playbtn.setState( this.playing, true );\r\n\r\n        header.addButton(\"stopBtn\", '', (value: any, event: Event) => {\r\n            this.setState(false, true); // skip callback of set state\r\n            if( this.onStateStop ){\r\n                this.onStateStop();\r\n            }\r\n        }, { buttonClass: \"accept\", title: \"Stop\", hideName: true, icon: \"Stop@solid\" });\r\n\r\n        header.addButton(\"loopBtn\", '', ( value: any, event: Event ) => {\r\n            this.setLoopMode( !this.loop );\r\n        }, { selectable: true, selected: this.loop, title: 'Loop', hideName: true, icon: \"RefreshCw\" });\r\n\r\n        if( this.onCreateControlsButtons )\r\n        {\r\n            this.onCreateControlsButtons( header );\r\n        }\r\n\r\n        header.clearQueue( buttonContainer );\r\n        header.addContent( \"header-buttons\", buttonContainer );\r\n\r\n        // time number inputs - duration, current time, etc\r\n\r\n        if( this.onCreateBeforeTopBar )\r\n        {\r\n            this.onCreateBeforeTopBar( header );\r\n        }\r\n\r\n        header.addNumber(\"Current Time\", this.currentTime, (value: number, event: Event) => {\r\n            this.setTime(value);\r\n        }, {\r\n            units: \"s\",\r\n            step: 0.01, min: 0, precision: 3,\r\n            skipSlider: true,\r\n            skipReset: true,\r\n            nameWidth: \"auto\"\r\n        });\r\n\r\n        header.addNumber(\"Duration\", + this.duration.toFixed(3), (value: number, event: Event) => {\r\n            this.setDuration(value, false, false);\r\n        }, {\r\n            units: \"s\",\r\n            step: 0.01, min: 0,\r\n            skipReset: true,\r\n            nameWidth: \"auto\"\r\n        });\r\n\r\n        if( this.onCreateAfterTopBar )\r\n        {\r\n            this.onCreateAfterTopBar( header );\r\n        }\r\n\r\n        // settings buttons - optimize, settings, etc\r\n\r\n        const buttonContainerEnd = LX.makeContainer( [\"auto\", \"100%\"], \"flex flex-row gap-1\" );\r\n        header.queue( buttonContainerEnd );\r\n\r\n        if( this.onCreateSettingsButtons ){\r\n            this.onCreateSettingsButtons( header );\r\n        }\r\n\r\n        if( this.onShowOptimizeMenu )\r\n        {\r\n            header.addButton(null, \"\", (value: any, event: Event) => {\r\n                if( this.onShowOptimizeMenu ){\r\n                    this.onShowOptimizeMenu(event);\r\n                }\r\n            }, { tooltip: true, title: \"Optimize\", icon:\"Filter\" });\r\n        }\r\n\r\n        if( this.onShowConfiguration )\r\n        {\r\n            header.addButton(null, \"\", (value: any, event: Event) => {\r\n                if(this.configurationDialog){\r\n                    this.configurationDialog.close();\r\n                    this.configurationDialog = null;\r\n                    return;\r\n                }\r\n                this.configurationDialog = new Dialog(\"Configuration\", (p : typeof Panel) => {\r\n                    if( this.onShowConfiguration ){\r\n                        this.onShowConfiguration(p);\r\n                    }\r\n                }, {\r\n                    onBeforeClose: () => {\r\n                        this.configurationDialog.panel.clear(); // clear signals\r\n                        this.configurationDialog = null;\r\n                    }\r\n                })\r\n            }, { title: \"Settings\", icon: \"Settings\", tooltip: true })\r\n        }\r\n\r\n        header.clearQueue( buttonContainerEnd );\r\n        header.addContent( \"header-buttons-end\", buttonContainerEnd );\r\n\r\n        header.endLine( \"justify-between\" );\r\n    }\r\n\r\n    /**\r\n    * @method updateLeftPanel\r\n    *\r\n    */\r\n    updateLeftPanel()\r\n    {\r\n        this.leftPanel.clear();\r\n\r\n        const panel = this.leftPanel;\r\n\r\n        panel.sameLine();\r\n        let titleComponent = panel.addTitle( \"Tracks\", { style: { background: \"none\"}, className: \"fg-secondary text-lg px-4\"} );\r\n        let title = titleComponent.root;\r\n\r\n        if( !this.disableNewTracks )\r\n        {\r\n            panel.addButton(\"addTrackBtn\", '', (value: any, event: Event) => {\r\n                if( this.onAddNewTrackButton ){\r\n                    this.onAddNewTrackButton();\r\n                }else{\r\n                    this.addNewTrack();\r\n                }\r\n            }, { hideName: true, title: \"Add Track\", icon: \"Plus\" });\r\n        }\r\n        panel.endLine();\r\n\r\n        const styles = window.getComputedStyle( title );\r\n        const titleHeight = title.clientHeight + parseFloat(styles['marginTop']) + parseFloat(styles['marginBottom']);\r\n\r\n        let p = new LX.Panel({height: \"calc(100% - \" + titleHeight + \"px)\"});\r\n\r\n        let treeTracks: any[] = [];\r\n        if( this.animationClip && this.selectedItems.length )\r\n        {\r\n            treeTracks = this.generateSelectedItemsTreeData();\r\n        }\r\n\r\n        this.trackTreesComponent = p.addTree(null, treeTracks, {filter: false, rename: false, draggable: false, onevent: ( e: typeof TreeEvent ) => {\r\n            switch(e.type) {\r\n                case LX.TreeEvent.NODE_SELECTED:\r\n                    if( !e.event.shiftKey )\r\n                    {\r\n                        this.deselectAllTracks( false ); // no need to update left panel\r\n                    }\r\n                    if(e.node.trackData)\r\n                    {\r\n                        const flag = e.event.shiftKey? !e.node.trackData.isSelected : true;\r\n                        this.setTrackSelection( e.node.trackData.trackIdx, flag, false, false ); // do callback, do not update left panel\r\n                    }\r\n                    break;\r\n                case LX.TreeEvent.NODE_VISIBILITY:\r\n                    if(e.node.trackData){\r\n                        this.setTrackState( e.node.trackData.trackIdx, e.value, false, false ); // do not update left panel\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            if( this.onTrackTreeEvent )\r\n            {\r\n                this.onTrackTreeEvent( e );\r\n            }\r\n        }});\r\n\r\n        const that = this;\r\n        this.trackTreesComponent.innerTree._refresh = this.trackTreesComponent.innerTree.refresh;\r\n        this.trackTreesComponent.innerTree.refresh = function( newData: any, selectedId: Nullable< string > ){\r\n            this._refresh( newData, selectedId );\r\n            that.setTrackHeight( that.trackHeight );\r\n        }\r\n\r\n        if( this.selectedTracks.length )\r\n        {\r\n            this._updateTrackTreeSelection(); // select visible tracks\r\n        }\r\n\r\n        // setting a name in the addTree function adds an undesired node\r\n        this.trackTreesComponent.name = \"tracksTrees\";\r\n        p.components[this.trackTreesComponent.name] = this.trackTreesComponent;\r\n\r\n        this.trackTreesPanel = p;\r\n        panel.attach( p.root );\r\n        p.root.addEventListener(\"scroll\", ( e: any ) => {\r\n            if(e.currentTarget.scrollHeight > e.currentTarget.clientHeight){\r\n                this.currentScroll = e.currentTarget.scrollTop / (e.currentTarget.scrollHeight - e.currentTarget.clientHeight);\r\n                this.currentScrollInPixels = e.currentTarget.scrollTop;\r\n            }\r\n            else{\r\n                this.currentScroll = 0;\r\n                this.currentScrollInPixels = 0;\r\n            }\r\n        });\r\n\r\n        this.trackTreesPanel.root.scrollTop = this.currentScrollInPixels;\r\n        this.setTrackHeight( this.trackHeight );\r\n\r\n        if( this.leftPanel.parent.root.classList.contains(\"hidden\") || !this.root.parentElement ){\r\n            return;\r\n        }\r\n\r\n        this.resizeCanvas();\r\n\r\n        this.setScroll( this.currentScroll ); // avoid scroll bugs\r\n\r\n    }\r\n\r\n    setTrackHeight( trackHeight: number )\r\n    {\r\n        // ul list has a \"gap\" of 0.25rem. Compute pixel count of 0.25 rem\r\n        const gapSize = parseFloat(getComputedStyle(document.documentElement).fontSize) * 0.25;\r\n\r\n        this.trackHeight = trackHeight = Math.max(gapSize, trackHeight);\r\n\r\n        if( !this.trackTreesComponent ){\r\n            return;\r\n        }\r\n\r\n        trackHeight -= gapSize;\r\n        const tracks = this.trackTreesComponent.root.querySelector(\"ul\").children;\r\n        for( let i = 0; i < tracks.length; ++i )\r\n        {\r\n            tracks[ i ].style.height = trackHeight + \"px\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Object} options options for the new track\r\n     *  { id: string, active: bool, locked: bool, }\r\n     * @returns\r\n     */\r\n    addNewTrack( options: any = {}, skipCallback: boolean = false )\r\n    {\r\n        const trackInfo = this.instantiateTrack( options );\r\n        trackInfo.trackIdx = this.animationClip.tracks.length;\r\n        this.animationClip.tracks.push( trackInfo );\r\n\r\n        if( this.onAddNewTrack && !skipCallback )\r\n        {\r\n            this.onAddNewTrack( trackInfo, options );\r\n        }\r\n\r\n        return trackInfo.trackIdx;\r\n    }\r\n\r\n    /**\r\n     * Finds tracks (wholy and partially) inside the range minY maxY.\r\n     * (Full) Canvas local coordinates.\r\n     * @param {Number} minY pixels\r\n     * @param {Number} maxY pixels\r\n     * @returns array of trackDatas\r\n     */\r\n    getTracksInRange( minY: number , maxY: number )\r\n    {\r\n        let tracks: any = [];\r\n\r\n        // Manage negative selection\r\n        if( minY > maxY )\r\n        {\r\n            let aux = minY;\r\n            minY = maxY;\r\n            maxY = aux;\r\n        }\r\n\r\n        const elements = this.getVisibleItems();\r\n        if( elements.length < 1 )\r\n        {\r\n            return [];\r\n        }\r\n\r\n        const startY = minY - this.lastTrackTreesComponentOffset + this.currentScrollInPixels;\r\n        const endY = maxY - this.lastTrackTreesComponentOffset + this.currentScrollInPixels;\r\n\r\n        const startIdx = Math.max( 0, Math.floor( startY / this.trackHeight ) );\r\n        const endIdx = Math.min( elements.length-1, Math.floor( endY / this.trackHeight ) ) + 1;\r\n\r\n        for( let i = startIdx; i < endIdx; ++i )\r\n        {\r\n            const e = elements[ i ];\r\n            if( e.treeData && e.treeData.trackData )\r\n            {\r\n                tracks.push( e.treeData.trackData );\r\n            }\r\n        }\r\n\r\n        return tracks;\r\n    }\r\n\r\n    /**\r\n     * @method setAnimationClip\r\n     * @param {*} animation\r\n     * @param {Boolean} needsToProcess\r\n     * @param {Object} processOptions\r\n     * [KeyFrameTimeline] - each track should contain an attribute \"dim\" to indicate the value dimension (e.g. vector3 -> dim=3). Otherwise dimensions will be infered from track's values and times. Default is 1\r\n     */\r\n    setAnimationClip( animation: any, needsToProcess: boolean = true )\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left panel yet\r\n\r\n        this.selectedItems = [];\r\n\r\n        this.clearState();\r\n\r\n        if( !animation || !animation.tracks || needsToProcess )\r\n        {\r\n            this.animationClip = this.instantiateAnimationClip( animation ); // generate default animationclip or process the user's one\r\n        }\r\n        else\r\n        {\r\n            this.animationClip = animation;\r\n        }\r\n\r\n        this.setDuration( this.animationClip.duration, true, true );\r\n\r\n        this.updateLeftPanel();\r\n\r\n        this.resize();\r\n\r\n        return this.animationClip;\r\n    }\r\n\r\n    drawTimeInfo( w: number, h: number = this.topMargin )\r\n    {\r\n        let ctx : any = this.canvas.getContext( \"2d\" );\r\n        ctx.font = \"11px \" + Timeline.FONT;//\"11px Calibri\";\r\n        ctx.textAlign = \"center\";\r\n\r\n        // Draw time markers\r\n        ctx.save();\r\n\r\n        // background of timeinfo\r\n        ctx.fillStyle = Timeline.BACKGROUND_COLOR;\r\n        ctx.fillRect( 0, 0, this.canvas.width, h );\r\n        ctx.strokeStyle = Timeline.FONT_COLOR_PRIMARY;\r\n\r\n        // set tick and sub tick times\r\n        let tickTime = 4;\r\n        if( this.pixelsPerSecond > 900 ) { tickTime = 1; }\r\n        else if( this.pixelsPerSecond > 100 ) { tickTime = 2; }\r\n        else if( this.pixelsPerSecond > 50 ) { tickTime = 3; }\r\n\r\n        let subtickTime = this.timeSeparators[tickTime - 1];\r\n        tickTime = this.timeSeparators[tickTime];\r\n\r\n        const startTime = this.visualTimeRange[ 0 ];\r\n        const endTime = this.visualTimeRange[ 1 ];\r\n        // Transform times into pixel coords\r\n        let tickX = this.timeToX( startTime + tickTime ) - this.timeToX( startTime );\r\n        let subtickX = subtickTime * tickX / tickTime;\r\n\r\n        let startx = this.timeToX( Math.floor( startTime / tickTime) * tickTime ); // floor because might need to draw previous subticks\r\n        startx += 0.0000001; // slight offset to avoid \"-0.0\"\r\n        let endx = this.timeToX( endTime ); // draw up to endTime\r\n\r\n        // Begin drawing\r\n        ctx.beginPath();\r\n        ctx.fillStyle = Timeline.FONT_COLOR_PRIMARY;\r\n        ctx.globalAlpha = 1;\r\n\r\n        for( let x = startx; x <= endx; x += tickX )\r\n        {\r\n            // Draw main line\r\n            ctx.moveTo( Math.round( x ) + 0.5, h * 0.4 + h * 0.3 );\r\n            ctx.lineTo( Math.round( x ) + 0.5, h * 0.95 );\r\n\r\n            // Draw following sub lines\r\n            let endsub = x + tickX - subtickX * 0.5;\r\n            for ( let subX = x; subX < endsub && subX < endx; subX += subtickX )\r\n            {\r\n                ctx.moveTo( Math.round( subX ) + 0.5, h * 0.4 + h * 0.45 );\r\n                ctx.lineTo( Math.round( subX ) + 0.5, h * 0.95 );\r\n            }\r\n\r\n            // Draw time number\r\n            let t = this.xToTime( x );\r\n            ctx.fillText( t.toFixed( tickTime < 1 ? 1 : 0 ), x, h * 0.6 );\r\n        }\r\n\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n\r\n    drawTracksBackground( w: number, h: number )\r\n    {\r\n        let canvas = this.canvas;\r\n        let ctx: any = canvas.getContext( \"2d\" );\r\n        let duration = this.duration;\r\n        ctx.globalAlpha = 1;\r\n\r\n        // Content\r\n        const topMargin = this.topMargin;\r\n        const treeOffset = this.lastTrackTreesComponentOffset;\r\n        const line_height = this.trackHeight;\r\n\r\n        //fill track lines\r\n        w = w || canvas.width;\r\n        let max_tracks = Math.ceil( ( h - topMargin ) / line_height ) + 1;\r\n\r\n        ctx.save();\r\n        ctx.fillStyle = Timeline.TRACK_COLOR_SECONDARY;\r\n\r\n        const rectsOffset = this.currentScrollInPixels % line_height;\r\n        const blackOrWhite = 1 - Math.floor(this.currentScrollInPixels / line_height ) % 2;\r\n        for(let i = blackOrWhite; i <= max_tracks; i+=2)\r\n        {\r\n            ctx.fillRect(0, treeOffset - rectsOffset + i * line_height, w, line_height );\r\n        }\r\n\r\n        //bg lines\r\n        ctx.strokeStyle = Timeline.TRACK_COLOR_TERCIARY;\r\n        ctx.beginPath();\r\n\r\n        let pos = this.timeToX( 0 );\r\n        if( pos < 0 ) { pos = 0; }\r\n        ctx.lineWidth = 1;\r\n        ctx.moveTo( pos + 0.5, topMargin);\r\n        ctx.lineTo( pos + 0.5, canvas.height);\r\n        ctx.moveTo( Math.round( this.timeToX( duration ) ) + 0.5, topMargin );\r\n        ctx.lineTo( Math.round( this.timeToX( duration ) ) + 0.5, canvas.height );\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * @method draw\r\n     */\r\n\r\n    draw()\r\n    {\r\n        let ctx: any = this.canvas.getContext( \"2d\" );\r\n        ctx.textBaseline = \"bottom\";\r\n        ctx.font = \"11px \" + Timeline.FONT;//\"11px Calibri\";\r\n        ctx.globalAlpha = 1;\r\n\r\n        const w = ctx.canvas.width;\r\n        const h = ctx.canvas.height;\r\n\r\n        const scrollableHeight = this.trackTreesComponent.root.scrollHeight;\r\n        // tree has gaps of 0.25rem (4px) inbetween entries but not in the beginning nor ending. Move half gap upwards.\r\n        const treeOffset = this.lastTrackTreesComponentOffset = this.trackTreesComponent.innerTree.domEl.offsetTop - this.canvas.offsetTop -2;\r\n\r\n        //zoom\r\n        let startTime = this.visualOriginTime; //seconds\r\n        startTime = Math.min( this.duration, Math.max( 0, startTime ) );\r\n        let endTime = this.visualOriginTime + w * this.secondsPerPixel; //seconds\r\n        endTime = Math.max( startTime, Math.min( this.duration, endTime ) );\r\n        this.visualTimeRange[ 0 ] = startTime;\r\n        this.visualTimeRange[ 1 ] = endTime;\r\n\r\n        // Background\r\n        ctx.globalAlpha = 1;\r\n        ctx.fillStyle = Timeline.TRACK_COLOR_SECONDARY;\r\n        ctx.clearRect(0,0, this.canvas.width, this.canvas.height );\r\n\r\n        this.drawTracksBackground(w, h);\r\n\r\n        if( this.onBeforeDrawContent )\r\n        {\r\n            this.onBeforeDrawContent( ctx );\r\n        }\r\n\r\n        if( this.animationClip )\r\n        {\r\n            ctx.translate( 0, treeOffset );\r\n            this.drawContent( ctx );\r\n            ctx.translate( 0, -treeOffset );\r\n        }\r\n\r\n        //scrollbar\r\n        if( ( h - this.topMargin ) < scrollableHeight )\r\n        {\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillRect( w - 10, 0, 10, h );\r\n\r\n            ctx.fillStyle = this.grabbingScroll ? Timeline.FONT_COLOR_TERTIARY : Timeline.FONT_COLOR_QUATERNARY;\r\n\r\n            let scrollBarHeight = Math.max( 10, (h-this.topMargin)* (h-this.topMargin)/ this.trackTreesPanel.root.scrollHeight);\r\n            let scrollLoc = this.currentScroll * ( h - this.topMargin - scrollBarHeight ) + this.topMargin;\r\n            drawRoundRect(ctx, w - 10, scrollLoc, 10, scrollBarHeight, 5, true );\r\n        }\r\n\r\n        this.drawTimeInfo( w );\r\n\r\n        // Current time marker vertical line\r\n        let posx = Math.round( this.timeToX( this.currentTime ) );\r\n        let posy = this.topMargin * 0.4;\r\n\r\n        if( posx >= 0 )\r\n        {\r\n            ctx.strokeStyle = ctx.fillStyle = Timeline.TIME_MARKER_COLOR;\r\n            ctx.globalAlpha = 1;\r\n            ctx.beginPath();\r\n            ctx.moveTo( posx, posy * 0.6 ); ctx.lineTo( posx, this.canvas.height );//line\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n            ctx.shadowBlur = 8;\r\n            ctx.shadowColor = Timeline.TIME_MARKER_COLOR;\r\n            ctx.shadowOffsetX = 1;\r\n            ctx.shadowOffsetY = 1;\r\n\r\n            drawRoundRect(ctx, posx - 10, posy * 0.6, 20, posy, 5, true );\r\n            ctx.fill();\r\n            ctx.shadowBlur = 0;\r\n            ctx.shadowOffsetX = 0;\r\n            ctx.shadowOffsetY = 0;\r\n        }\r\n\r\n        // Current time seconds in text\r\n        ctx.font = \"11px \" + Timeline.FONT;//\"11px Calibri\";\r\n        ctx.textAlign = \"center\";\r\n        //ctx.textBaseline = \"middle\";\r\n        ctx.fillStyle = Timeline.TIME_MARKER_COLOR_TEXT;\r\n        ctx.fillText( ( Math.floor( this.currentTime * 10 ) * 0.1 ).toFixed( 1 ), posx, this.topMargin * 0.6 );\r\n\r\n        // Selections\r\n        ctx.strokeStyle = ctx.fillStyle = Timeline.FONT_COLOR_PRIMARY;\r\n        if( this.boxSelection )\r\n        {\r\n            ctx.globalAlpha = 0.15;\r\n            ctx.fillStyle = Timeline.BOX_SELECTION_COLOR;\r\n            ctx.strokeRect( this.boxSelectionStart[ 0 ], this.boxSelectionStart[ 1 ], this.boxSelectionEnd[ 0 ] - this.boxSelectionStart[ 0 ], this.boxSelectionEnd[ 1 ] - this.boxSelectionStart[ 1 ]);\r\n            ctx.fillRect( this.boxSelectionStart[ 0 ], this.boxSelectionStart[ 1 ], this.boxSelectionEnd[ 0 ] - this.boxSelectionStart[ 0 ], this.boxSelectionEnd[ 1 ] - this.boxSelectionStart[ 1 ]);\r\n            ctx.stroke();\r\n            ctx.globalAlpha = 1;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @method clearState\r\n     */\r\n\r\n    clearState()\r\n    {\r\n        this.historyUndo = [];\r\n        this.historyRedo = [];\r\n    }\r\n\r\n    /**\r\n     * @method setDuration\r\n     * @param {Number} t\r\n     * @param {Boolean} skipCallback\r\n     * @param {Boolean} updateHeader\r\n     */\r\n    setDuration( t: number, skipCallback: boolean = false, updateHeader: boolean = true )\r\n    {\r\n        let v = Math.max( 0, t );\r\n        this.duration = this.animationClip.duration = v;\r\n\r\n        if( updateHeader )\r\n        {\r\n            this.header.components[\"Duration\"].set( +this.duration.toFixed(2), true ); // skipcallback = true\r\n        }\r\n\r\n        if( this.onSetDuration && !skipCallback )\r\n        {\r\n            this.onSetDuration( this.duration );\r\n        }\r\n    }\r\n\r\n    setTime(time: number, skipCallback: boolean = false )\r\n    {\r\n        this.currentTime = Math.max( 0, Math.min( time, this.duration ) );\r\n        this.header.components[\"Current Time\"].set( +this.currentTime.toFixed( 2 ), true ); // skipcallback = true\r\n\r\n        if( this.onSetTime && !skipCallback )\r\n        {\r\n            this.onSetTime( this.currentTime );\r\n        }\r\n    }\r\n\r\n    // Converts distance in pixels to time\r\n    xToTime( x: number )\r\n    {\r\n        return x * this.secondsPerPixel + this.visualOriginTime;\r\n    }\r\n\r\n    // Converts time to disance in pixels\r\n    timeToX( t: number )\r\n    {\r\n        return ( t - this.visualOriginTime ) * this.pixelsPerSecond;\r\n    }\r\n\r\n    /**\r\n     * @method setScale\r\n     * @param {*} pixelsPerSecond >0.  totalVisiblePixels / totalVisibleSeconds.\r\n     */\r\n\r\n    setScale( pixelsPerSecond: number )\r\n    {\r\n        const xCurrentTime = this.timeToX( this.currentTime );\r\n        this.pixelsPerSecond = pixelsPerSecond;\r\n        this.pixelsPerSecond = Math.max( 0.00001, this.pixelsPerSecond );\r\n\r\n        this.secondsPerPixel = 1 / this.pixelsPerSecond;\r\n        this.visualOriginTime += this.currentTime - this.xToTime( xCurrentTime );\r\n    }\r\n\r\n    /**\r\n     * @method setScroll\r\n     * not delta from last state, but full scroll amount.\r\n     * @param {Number} scrollY either pixels or [0,1]\r\n     * @param {Boolean} normalized if true, scrollY is in range[0,1] being 1 fully scrolled. Otherwised scrollY represents pixels\r\n     * @returns\r\n     */\r\n\r\n    setScroll( scrollY: number, normalized: boolean = true )\r\n    {\r\n        if( !this.trackTreesPanel )\r\n        {\r\n            this.currentScroll = 0;\r\n            this.currentScrollInPixels = 0;\r\n            return;\r\n        }\r\n\r\n        const r = this.trackTreesPanel.root;\r\n        if( r.scrollHeight > r.clientHeight )\r\n        {\r\n            if( normalized )\r\n            {\r\n                this.currentScroll = scrollY;\r\n                this.currentScrollInPixels = scrollY * ( r.scrollHeight - r.clientHeight );\r\n            }\r\n            else\r\n            {\r\n                this.currentScroll = scrollY / ( r.scrollHeight - r.clientHeight );\r\n                this.currentScrollInPixels = scrollY;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.currentScroll = 0;\r\n            this.currentScrollInPixels = 0;\r\n        }\r\n\r\n        // automatically calls event.\r\n        this.trackTreesPanel.root.scrollTop = this.currentScrollInPixels;\r\n\r\n    }\r\n\r\n    /**\r\n     * @method processMouse\r\n     * @param {*} e\r\n     */\r\n\r\n    processMouse( e: any /*MouseEvent*/ )\r\n    {\r\n        if( !this.canvas )\r\n        {\r\n            return;\r\n        }\r\n\r\n        let h = this.canvas.height;\r\n        let w = this.canvas.width;\r\n\r\n        // Process mouse\r\n        let x = e.offsetX;\r\n        let y = e.offsetY;\r\n        e.deltax = x - this.lastMouse[ 0 ];\r\n        e.deltay = y - this.lastMouse[ 1 ];\r\n        let localX = e.offsetX;\r\n        let localY = e.offsetY;\r\n\r\n        let timeX = this.timeToX( this.currentTime );\r\n        let isHoveringTimeBar = localY < this.topMargin &&\r\n                                localX > (timeX - 6) && localX < (timeX + 6);\r\n\r\n        const time = this.xToTime(x);\r\n\r\n        if( isHoveringTimeBar )\r\n        {\r\n            this.canvas.style.cursor = \"col-resize\";\r\n        }\r\n        else if( this.movingKeys )\r\n        {\r\n            this.canvas.style.cursor = \"grabbing\";\r\n        }\r\n        else if( e.shiftKey )\r\n        {\r\n            this.canvas.style.cursor = \"crosshair\";\r\n        }\r\n        else\r\n        {\r\n            this.canvas.style.cursor = \"default\";\r\n        }\r\n\r\n        if( e.type == \"wheel\" )\r\n        {\r\n            if( e.shiftKey )\r\n            {\r\n                if( e.wheelDelta )\r\n                {\r\n                    let mouseTime = this.xToTime( localX );\r\n                    this.setScale( this.pixelsPerSecond * (e.wheelDelta < 0 ? 0.95 : 1.05) );\r\n                    this.visualOriginTime = mouseTime - localX * this.secondsPerPixel;\r\n                }\r\n\r\n            }\r\n            else if( ( h - this.topMargin ) < this.trackTreesComponent.root.scrollHeight )\r\n            {\r\n                this.trackTreesPanel.root.scrollTop += e.deltaY; // wheel deltaY\r\n            }\r\n\r\n            if( this.onMouse )\r\n            {\r\n                this.onMouse( e, time );\r\n            }\r\n            return;\r\n        }\r\n\r\n        const is_inside = x >= 0 && x <= this.size[ 0 ] &&\r\n                        y >= 0 && y <= this.size[ 1 ];\r\n\r\n        let track = this.getTracksInRange(localY, localY);\r\n        track = track.length ? track[ 0 ] : null;\r\n\r\n        e.track = track;\r\n        e.localX = localX;\r\n        e.localY = localY;\r\n\r\n        if( e.type == \"mouseup\" )\r\n        {\r\n            if( !this.active )\r\n            {\r\n                this.grabbing = false;\r\n                this.grabbingTimeBar = false;\r\n                this.grabbingScroll = false;\r\n                this.movingKeys = false;\r\n                this.timeBeforeMove = 0;\r\n                this.boxSelection = false;\r\n                return;\r\n            }\r\n\r\n            // this.canvas.style.cursor = \"default\";\r\n            const discard = this.movingKeys || (LX.getTime() - this.clickTime) > this.clickDiscardTimeout; // ms\r\n\r\n            e.discard = discard;\r\n\r\n            if( !this.grabbingScroll && !this.grabbingTimeBar && e.button == 0 && this.onMouseUp )\r\n            {\r\n                this.onMouseUp( e, time );\r\n            }\r\n\r\n            this.grabbing = false;\r\n            this.grabbingTimeBar = false;\r\n            this.grabbingScroll = false;\r\n            this.movingKeys = false;\r\n            this.timeBeforeMove = 0;\r\n            this.boxSelection = false; // after mouseup\r\n        }\r\n\r\n        if( e.type == \"mousedown\" )\r\n        {\r\n            window.getSelection()?.empty(); // if canvas DOM is selected, dragging does not work properly. Deselect it\r\n\r\n            // e.preventDefault();\r\n\r\n            this.clickTime = LX.getTime();\r\n\r\n            if( e.shiftKey && this.active )\r\n            {\r\n                this.boxSelection = true;\r\n                this.boxSelectionEnd[ 0 ] = this.boxSelectionStart[ 0 ] = localX;\r\n                this.boxSelectionEnd[ 1 ] = this.boxSelectionStart[ 1 ] = localY;\r\n                return; // Handled\r\n            }\r\n            else if( e.localY < this.topMargin )\r\n            {\r\n                this.grabbing = true;\r\n                this.grabbingTimeBar = true;\r\n                this.setTime( time );\r\n            }\r\n            else if( ( h - this.topMargin ) < this.trackTreesComponent.root.scrollHeight && x > w - 10 ) // grabbing scroll bar\r\n            {\r\n                this.grabbing = true;\r\n                this.grabbingScroll = true;\r\n            }\r\n            else // grabbing canvas\r\n            {\r\n                this.grabbing = true;\r\n                this.grabTime = time;\r\n                this.grabbingTimeBar = isHoveringTimeBar;\r\n                if( this.onMouseDown && this.active )\r\n                {\r\n                    this.onMouseDown( e, time );\r\n                }\r\n            }\r\n        }\r\n        else if( e.type == \"mousemove\" )\r\n        {\r\n            if( e.shiftKey && this.active && this.boxSelection )\r\n            {\r\n                this.boxSelectionEnd[ 0 ] = localX;\r\n                this.boxSelectionEnd[ 1 ] = localY;\r\n                return; // Handled\r\n            }\r\n            else if( this.grabbing && e.button !=2 && !this.movingKeys ) // e.buttons != 2 on mousemove needs to be plural\r\n            {\r\n                this.canvas.style.cursor = \"grabbing\";\r\n                if( this.grabbingTimeBar && this.active )\r\n                {\r\n                    this.setTime( time );\r\n                }\r\n                else if( this.grabbingScroll )\r\n                {\r\n                    // will automatically call scroll event\r\n                    if( y < this.topMargin )\r\n                    {\r\n                        this.trackTreesPanel.root.scrollTop = 0;\r\n                    }\r\n                    else\r\n                    {\r\n                        this.trackTreesPanel.root.scrollTop += this.trackTreesPanel.root.scrollHeight * e.deltay / ( h - this.topMargin );\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    // Move timeline in X (independent of current time)\r\n                    var old = this.xToTime( this.lastMouse[ 0 ] );\r\n                    var now = this.xToTime( e.offsetX );\r\n                    this.visualOriginTime += ( old - now );\r\n                    this.trackTreesPanel.root.scrollTop -= e.deltay; // will automatically call scroll event\r\n                }\r\n            }\r\n\r\n            if( this.onMouseMove )\r\n            {\r\n                this.onMouseMove( e, time );\r\n            }\r\n        }\r\n        else if( e.type == \"dblclick\" && this.onDblClick )\r\n        {\r\n            this.onDblClick( e );\r\n        }\r\n        else if( e.type == \"contextmenu\" && this.onShowContextMenu && this.active )\r\n        {\r\n            this.onShowContextMenu( e );\r\n        }\r\n\r\n        this.lastMouse[ 0 ] = x;\r\n        this.lastMouse[ 1 ] = y;\r\n\r\n        if( !is_inside && !this.grabbing && !( e.metaKey || e.altKey ) )\r\n        {\r\n            return true;\r\n        }\r\n\r\n        if( this.onMouse )\r\n        {\r\n            this.onMouse( e, time );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * keydown\r\n     * @method processKeys\r\n     * @param {*} e\r\n     */\r\n    processKeys( e: KeyboardEvent )\r\n    {\r\n        switch( e.key )\r\n        {\r\n            case 'Delete':\r\n            case 'Backspace':\r\n                this.deleteSelectedContent( false );\r\n                break;\r\n            case 'c':\r\n            case 'C':\r\n                if( e.ctrlKey ){ this.copySelectedContent(); }\r\n                break;\r\n            case 'v':\r\n            case 'V':\r\n                if( e.ctrlKey ) { this.pasteContent( this.currentTime ); }\r\n                break;\r\n            case ' ':\r\n                e.preventDefault();\r\n                e.stopImmediatePropagation();\r\n                this.changeState();\r\n                break;\r\n\r\n            case \"Shift\":\r\n                this.canvas.style.cursor = \"crosshair\";\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method changeState\r\n     * @param {Boolean} skipCallback defaults false\r\n     * @description change play/pause state\r\n     **/\r\n    changeState(skipCallback = false)\r\n    {\r\n        this.setState( !this.playing, skipCallback );\r\n    }\r\n    /**\r\n     * @method setState\r\n     * @param {Boolean} state\r\n     * @param {Boolean} skipCallback defaults false\r\n     * @description change play/pause state\r\n     **/\r\n    setState(state: boolean, skipCallback: boolean = false)\r\n    {\r\n        this.playing = state;\r\n\r\n        this.header.components.playBtn.setState( this.playing, true );\r\n\r\n        if( this.onStateChange && !skipCallback )\r\n        {\r\n            this.onStateChange( this.playing );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method setLoopMode\r\n     * @param {Boolean} loopState\r\n     * @param {Boolean} skipCallback defaults false\r\n     * @description change loop mode of the timeline\r\n     */\r\n    setLoopMode( loopState: boolean, skipCallback: boolean = false )\r\n    {\r\n        this.loop = loopState;\r\n\r\n        if( this.loop )\r\n        {\r\n            this.header.components.loopBtn.root.children[ 0 ].classList.add(\"selected\");\r\n        }\r\n        else\r\n        {\r\n            this.header.components.loopBtn.root.children[ 0 ].classList.remove(\"selected\")\r\n        }\r\n\r\n        if( this.onChangeLoopMode && !skipCallback )\r\n        {\r\n            this.onChangeLoopMode( this.loop );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the tree elements (tracks and grouops) shown in the timeline.\r\n     *  Each item has { treeData: { trackData: track } }, where track is the actual track information of the animationClip.\r\n     *  If not a track, trackData will be undefined\r\n     */\r\n    getVisibleItems()\r\n    {\r\n        return this.trackTreesComponent.innerTree.domEl.children[ 0 ].children; // children of 'ul'\r\n    }\r\n\r\n    /**\r\n     * [ trackIdx ]\r\n     * @param {Array} itemsName array of numbers identifying tracks\r\n     */\r\n    setSelectedItems( items: any[], skipCallback: boolean = false )\r\n    {\r\n        this.selectedItems = [];\r\n        this.changeSelectedItems( items, null, skipCallback );\r\n    }\r\n\r\n    /**\r\n     * @param {Array} itemsToAdd [ trackIdx ], array of numbers identifying tracks by their index\r\n     * @param {Array} itemsToRemove [ trackIdx ], array of numbers identifying tracks by their index\r\n     */\r\n    changeSelectedItems( itemsToAdd: Nullable< any[] > = null, itemsToRemove: Nullable< any[] > = null, skipCallback: boolean = false )\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left panel. It is going to be rebuilt anyways\r\n\r\n        const tracks = this.animationClip.tracks;\r\n\r\n        if( itemsToRemove )\r\n        {\r\n            for( let i = 0; i < itemsToRemove.length; ++i)\r\n            {\r\n                const compareObj = itemsToRemove[ i ];\r\n                for( let s = 0; s < this.selectedItems.length; ++s)\r\n                {\r\n                    if( this.selectedItems[ s ] === compareObj )\r\n                    {\r\n                        this.selectedItems.splice( s, 1 );\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if( itemsToAdd )\r\n        {\r\n            for( let i = 0; i < itemsToAdd.length; ++i )\r\n            {\r\n                const v = itemsToAdd[ i ];\r\n                if( tracks[ v ] )\r\n                {\r\n                    this.selectedItems.push( tracks[ v ] );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateLeftPanel();\r\n\r\n        if( this.onItemSelected && !skipCallback )\r\n        {\r\n            this.onItemSelected( this.selectedItems, itemsToAdd, itemsToRemove );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * It will find the first occurrence of trackId in animationClip.tracks\r\n     * @param {String} trackId\r\n     * @returns\r\n     */\r\n    getTrack( trackId: string )\r\n    {\r\n        const tracks = this.animationClip.tracks;\r\n\r\n        for( let i = 0; i < tracks.length; ++i)\r\n        {\r\n            if( tracks[ i ].id == trackId )\r\n            {\r\n                return tracks[ i ];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @param {Boolean} updateTrackTree whether the track tree needs a refresh\r\n     * @returns\r\n     */\r\n    deselectAllTracks( updateTrackTree: boolean = true )\r\n    {\r\n        if( !this.animationClip )\r\n        {\r\n            return;\r\n        }\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        for(let i = 0; i < tracks.length; i++)\r\n        {\r\n            tracks[ i ].isSelected = false;\r\n        }\r\n\r\n        this.selectedTracks.length = 0;\r\n\r\n        if( updateTrackTree )\r\n        {\r\n            this._updateTrackTreeSelection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Int} trackIdx\r\n     * @param {Boolean} isSelected new \"selected\" state of the track\r\n     * @param {Boolean} skipCallback whether to call onSetTrackSelection\r\n     * @param {Boolean} updateTrackTree whether track tree panel needs a refresh\r\n     * @returns\r\n     */\r\n    setTrackSelection( trackIdx: number, isSelected: boolean, skipCallback: boolean = false, updateTrackTree: boolean = true )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        const oldValue = track.isSelected;\r\n        track.isSelected = isSelected;\r\n\r\n        const idx = this.selectedTracks.indexOf( track );\r\n        if( ( idx == -1 && !isSelected ) || ( idx > -1 && isSelected ) )\r\n        {\r\n            return;\r\n        }\r\n\r\n        if( idx == -1 )\r\n        {\r\n            this.selectedTracks.push( track );\r\n        }\r\n        else\r\n        {\r\n            this.selectedTracks.splice( idx, 1 );\r\n        }\r\n\r\n        if( this.onSetTrackSelection && !skipCallback )\r\n        {\r\n            this.onSetTrackSelection( track, oldValue );\r\n        }\r\n\r\n        if( updateTrackTree )\r\n        {\r\n            this._updateTrackTreeSelection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * updates trackTreesComponent's nodes, to match the selectedTracks\r\n     */\r\n    _updateTrackTreeSelection()\r\n    {\r\n        const data = this.trackTreesComponent.innerTree.data;\r\n        const selected = this.trackTreesComponent.innerTree.selected;\r\n        selected.length = 0;\r\n\r\n        const addToSelection = (nodes: any[]) =>\r\n        {\r\n            for( let i = 0; i < nodes.length; ++i )\r\n            {\r\n                if( nodes[ i ].trackData && nodes[ i ].trackData.isSelected )\r\n                {\r\n                    selected.push( nodes[ i ] );\r\n                }\r\n\r\n                if( nodes[ i ].children )\r\n                {\r\n                    addToSelection( nodes[ i ].children );\r\n                }\r\n            }\r\n        }\r\n\r\n        // update innerTree (visible) selected nodes\r\n        if( this.selectedTracks.length )\r\n        {\r\n            addToSelection( data );\r\n        }\r\n\r\n        this.trackTreesComponent.innerTree.refresh();\r\n    }\r\n\r\n    deselectAllElements()\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n    * @method setTrackState\r\n    * @param {Int} trackIdx\r\n    * @param {Boolean} isEnbaled\r\n    * @param {Boolean} skipCallback onSetTrackState\r\n    * @param {Boolean} updateTrackTree updates eye icon of the track, if it is visible in the timeline\r\n    */\r\n    setTrackState(trackIdx: number, isEnbaled: boolean = true, skipCallback: boolean = false, updateTrackTree: boolean = true )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        const oldState = track.active;\r\n        track.active = isEnbaled;\r\n\r\n        if( this.onSetTrackState && !skipCallback )\r\n        {\r\n            this.onSetTrackState( track, oldState );\r\n        }\r\n\r\n        if( updateTrackTree && !this.skipVisibility )\r\n        {\r\n            // TODO: a bit of an overkill. Maybe searching the node in the tree is less expensive\r\n            this.updateLeftPanel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Int} trackIdx\r\n     * @param {Boolean} isLocked\r\n     * @param {Boolean} skipCallback onSetTrackLock\r\n     * @param {Boolean} updateTrackTree updates lock icon of the track, if it is visible in the timeline\r\n     */\r\n    setTrackLock( trackIdx: number, isLocked: boolean = false, skipCallback: boolean = false, updateTrackTree: boolean = true )\r\n    {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n        const oldState = track.locked;\r\n        track.locked = isLocked;\r\n\r\n        if( this.onSetTrackLock && !skipCallback )\r\n        {\r\n            this.onSetTrackLock( track, oldState );\r\n        }\r\n\r\n        if( updateTrackTree && !this.skipLock )\r\n        {\r\n            // TODO: a bit of an overkill. Maybe searching the node in the tree is less expensive\r\n            this.updateLeftPanel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Int} trackIdx index of track in the animation (not local index)\r\n     * @param {Boolean} combineWithPrevious whether to create a new entry or unify changes into a single undo entry\r\n     */\r\n    saveState( trackIdx: number, combineWithPrevious: boolean = false )\r\n    {\r\n        if( !this.historySaveEnabler ){ return; }\r\n\r\n        const undoStep = this.historyGenerateTrackStep( trackIdx );\r\n        undoStep.trackIdx = trackIdx;\r\n\r\n        if( combineWithPrevious && this.historyUndo.length ){\r\n            this.historyUndo[ this.historyUndo.length - 1 ].push( undoStep );\r\n        }\r\n        else\r\n        {\r\n            this.historyUndo.push( [ undoStep ] );\r\n        }\r\n\r\n        if( this.historyUndo.length > this.historyMaxSteps ){ this.historyUndo.shift(); } // remove first (oldest) element\r\n        this.historyRedo = [];\r\n    }\r\n\r\n    #undoRedo( isUndo = true )\r\n    {\r\n        let toBeShown = isUndo ? this.historyUndo : this.historyRedo;\r\n        let toBeStored = isUndo ? this.historyRedo : this.historyUndo;\r\n\r\n        if( !toBeShown.length ){ return false; }\r\n\r\n        this.deselectAllElements();\r\n\r\n        const combinedState = toBeShown.pop();\r\n        const combinedStateToStore: any = [];\r\n\r\n        for( let i = 0; i < combinedState.length; ++i )\r\n        {\r\n            const state = combinedState[ i ];\r\n            const trackIdx = state.trackIdx;\r\n\r\n            const stateToStore: any = this.historyApplyTrackStep( state, isUndo );\r\n            stateToStore.trackIdx = trackIdx;\r\n            combinedStateToStore.push( stateToStore );\r\n\r\n            // Update animation action interpolation info\r\n            if( this.onUpdateTrack )\r\n            {\r\n                this.onUpdateTrack( [state.trackIdx] );\r\n            }\r\n        }\r\n\r\n        toBeStored.push(combinedStateToStore);\r\n\r\n        return true;\r\n    }\r\n\r\n    undo() { return this.#undoRedo(true); }\r\n    redo() { return this.#undoRedo( false ); }\r\n    // historyApplyTrackStep( state, isUndo ) MUST BE IMPLEMENTED BY CHILD CLASS\r\n    // historyGenerateTrackStep( trackIdx ) MUST BE IMPLEMENTED BY CHILD CLASS\r\n\r\n    /**\r\n     * @method resize\r\n     * @param {*} size\r\n     */\r\n    resize( size: Nullable< [ number, number ] > = null )\r\n    {\r\n        if( size )\r\n        {\r\n            this.size[ 0 ] = size[ 0 ];\r\n            this.size[ 1 ] = size[ 1 ];\r\n        }\r\n        else if( this.root.parentElement )\r\n        {\r\n            this.size[ 0 ] = this.root.parentElement.clientWidth;\r\n            this.size[ 1 ] = this.root.parentElement.clientHeight;\r\n        }\r\n\r\n        //this.content_area.setSize([size[ 0 ], size[ 1 ] - this.header_offset]);\r\n        this.mainArea.sections[ 1 ].root.style.height = \"calc(100% - \"+ this.header_offset + \"px)\";\r\n\r\n        let w = this.size[ 0 ] - this.leftPanel.root.clientWidth - 8;\r\n        this.mainArea.sections[ 1 ]._update(); // update area's this.size attribute\r\n\r\n        this.resizeCanvas();\r\n    }\r\n\r\n    resizeCanvas()\r\n    {\r\n        this.canvas.width = this.canvasArea.root.clientWidth;\r\n        this.canvas.height = this.canvasArea.root.clientHeight;\r\n    }\r\n\r\n    /**\r\n    * @method hide\r\n    * Hide timeline area\r\n    */\r\n    hide()\r\n    {\r\n        this.mainArea.hide();\r\n    }\r\n\r\n    /**\r\n    * @method show\r\n    * Show timeline area if it is hidden\r\n    */\r\n    show()\r\n    {\r\n        this.mainArea.show();\r\n        this.resize();\r\n        this.updateLeftPanel();\r\n    }\r\n\r\n    // ----- BASE FUNCTIONS -----\r\n    /**\r\n        These functions might be overriden by child classes. Nonetheless, they must have the same attributes, at least.\r\n        Usually call a super.whateverFunction to generate its base form, and expand it with extra attributes\r\n    */\r\n\r\n\r\n    /**\r\n     * This functions uses the selectedItems and generates the data that will feed the LX.Tree Component.\r\n     * This function is used by updateLeftPanel. Some timelines might allow grouping of tracks. Such timelines may override this function\r\n     * WARNING: track entries MUST have an attribute of 'trackData' with the track info\r\n     * @returns lexgui tree data as expected for the creation of a LX.Tree\r\n     */\r\n    generateSelectedItemsTreeData(): any\r\n    {\r\n        const treeTracks: any[] = [];\r\n\r\n        for( let i = 0; i < this.selectedItems.length; i++ )\r\n        {\r\n            const track = this.selectedItems[ i ];\r\n            treeTracks.push({trackData: track, id: track.id, skipVisibility: this.skipVisibility, visible: track.active, children:[], actions : this.skipLock ? null : [{\r\n                'name':'Lock edition',\r\n                'icon': (track.locked ? 'TimelineLock' : 'TimelineLockOpen'),\r\n                'swap': (track.locked ? 'TimelineLockOpen' : 'TimelineLock'),\r\n                'callback': (node: any, swapValue: boolean, event: Event) => {\r\n                    this.setTrackLock( node.trackData.trackIdx, !node.trackData.locked, false, false ); // do not update left panel\r\n                }\r\n            }]});\r\n        }\r\n\r\n        return treeTracks;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * @param {Object} options set some values for the track instance (groups and trackIdx not included)\r\n     * @returns\r\n     */\r\n    instantiateTrack( options: any = {}, clone: boolean = false )\r\n    {\r\n        return {\r\n            isTrack: true,\r\n            id: options.id ?? ( Math.floor( performance.now() ) + \"_\" + Math.floor( Math.random() * 0xffff ) ), //must be unique, at least inside a group\r\n            active: options.active ?? true,\r\n            locked: options.locked ?? false,\r\n            isSelected: false, // render and lexgui tree\r\n            trackIdx: -1,\r\n            data: options.data ?? null // user defined data\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates an animationClip using either the parameters set in the animation argument or using default values\r\n     * @param {Object} options data with which to generate an animationClip\r\n     * @param {Boolean} clone whether to clone clips or make a shallow copy\r\n     * @returns\r\n     */\r\n    instantiateAnimationClip( options : any = {}, clone: boolean = false )\r\n    {\r\n        const animationClip: any = {\r\n            id: options.id ?? (options.name ?? \"animationClip\"),\r\n            duration: options.duration ?? 0,\r\n            tracks: [],\r\n            data: options.data ?? null, // user defined data\r\n        };\r\n\r\n        return animationClip;\r\n    }\r\n    // ----- END OF BASE FUNCTIONS -----\r\n};\r\n\r\nTimeline.BACKGROUND_COLOR = LX.getThemeColor(\"global-blur-background\");\r\nTimeline.TRACK_COLOR_PRIMARY = LX.getThemeColor(\"global-color-primary\");\r\nTimeline.TRACK_COLOR_SECONDARY = LX.getThemeColor(\"global-color-secondary\");\r\nTimeline.TRACK_COLOR_TERCIARY = LX.getThemeColor(\"global-color-terciary\");\r\nTimeline.TRACK_COLOR_QUATERNARY = LX.getThemeColor(\"global-color-quaternary\");\r\nTimeline.TRACK_SELECTED = LX.getThemeColor(\"global-color-accent\");\r\nTimeline.TRACK_SELECTED_LIGHT = LX.getThemeColor(\"global-color-accent-light\");\r\nTimeline.FONT = LX.getThemeColor(\"global-font\");\r\nTimeline.FONT_COLOR_PRIMARY = LX.getThemeColor(\"global-text-primary\");\r\nTimeline.FONT_COLOR_TERTIARY = LX.getThemeColor(\"global-text-tertiary\");\r\nTimeline.FONT_COLOR_QUATERNARY = LX.getThemeColor(\"global-text-quaternary\");\r\nTimeline.TIME_MARKER_COLOR = LX.getThemeColor(\"global-color-accent\");\r\nTimeline.TIME_MARKER_COLOR_TEXT = \"#ffffff\";\r\n\r\nLX.setThemeColor(\"lxTimeline-keyframe\", \"light-dark(#2d69da,#2d69da)\");\r\nLX.setThemeColor(\"lxTimeline-keyframe-selected\", \"light-dark(#f5c700,#fafa14)\");\r\nLX.setThemeColor(\"lxTimeline-keyframe-hovered\", \"light-dark(#f5c700,#fafa14)\");\r\nLX.setThemeColor(\"lxTimeline-keyframe-locked\", \"light-dark(#c62e2e,#ff7d7d)\");\r\nLX.setThemeColor(\"lxTimeline-keyframe-edited\", \"light-dark(#00d000,#00d000)\");\r\nLX.setThemeColor(\"lxTimeline-keyframe-inactive\", \"light-dark(#706b6b,#706b6b)\");\r\nTimeline.KEYFRAME_COLOR = LX.getThemeColor(\"lxTimeline-keyframe\");\r\nTimeline.KEYFRAME_COLOR_SELECTED = Timeline.KEYFRAME_COLOR_HOVERED = LX.getThemeColor(\"lxTimeline-keyframe-selected\");\r\nTimeline.KEYFRAME_COLOR_LOCK = LX.getThemeColor(\"lxTimeline-keyframe-locked\");\r\nTimeline.KEYFRAME_COLOR_EDITED = LX.getThemeColor(\"lxTimeline-keyframe-edited\");\r\nTimeline.KEYFRAME_COLOR_INACTIVE =LX.getThemeColor(\"lxTimeline-keyframe-inactive\");\r\nTimeline.BOX_SELECTION_COLOR = \"#AAA\";\r\nLX.Timeline = Timeline;\r\n\r\n/**\r\n * @class KeyFramesTimeline\r\n */\r\n\r\nexport class KeyFramesTimeline extends Timeline\r\n{\r\n    static ADDKEY_VALUESINARRAYS = 0x01; // addkeyframes as [ [k0v0, k0v1...], [k1v0, k1v1...] ] instead of [k0v0,k0v1,k1v0,k1v1]\r\n\r\n    lastKeyFramesSelected: any[];\r\n    keyValuePerPixel: number;\r\n    defaultCurves: boolean;\r\n    defaultCurvesRange: [number, number];\r\n\r\n    keyframeSize: number;\r\n    keyframeSizeHovered: number;\r\n\r\n    lastHovered: Nullable< [number, number] >= null;\r\n    moveKeyMinTime: number = 0;\r\n\r\n    onContentMoved: Nullable< (trackIdx: number, keyIdx: number) => void > = null;\r\n    onOptimizeTracks: Nullable< (trackIdx: number) => void > = null;\r\n    onDeleteKeyFrames: Nullable< (trackIdx: number, indices: number[] ) => void > = null;\r\n    onSelectKeyFrame: Nullable< (selection: [number,number,number][] ) => void > = null;\r\n    onDeselectKeyFrames: Nullable< (lastSelected: any[])=> void > = null;\r\n\r\n    /**\r\n     * @param {String} name unique string\r\n     * @param {Object} options = {animationClip, selectedItems, x, y, width, height, canvas, trackHeight}\r\n     */\r\n    constructor( name: string, options: any = {} )\r\n    {\r\n        super( name, options );\r\n\r\n        this.lastKeyFramesSelected = [];\r\n\r\n        // curves --- track.dim == 1\r\n        this.keyValuePerPixel = 1/this.trackHeight; // used onMouseMove, vertical move only for dim==1. Normalized value movement / pixels\r\n        this.defaultCurves = true; // whn a track with dim == 1 has no curves attribute, defaultCurves will be used instead. If true, track is rendered using curves\r\n        this.defaultCurvesRange = [0,1]; // whn a track with dim == 1 has no curves attribute, defaultCurves will be used instead. If true, track is rendered using curves\r\n\r\n        this.keyframeSize = this.trackHeight * 0.5; // height of keyframe\r\n        this.keyframeSizeHovered = this.trackHeight * 0.5 + 5;\r\n\r\n        if( options.onShowOptimizeMenu && typeof options.onShowOptimizeMenu == \"boolean\" )\r\n        {\r\n            this.onShowOptimizeMenu = ( e: any ): void =>\r\n            {\r\n                if( this.selectedItems.length == 0 )\r\n                {\r\n                    return;\r\n                }\r\n\r\n                LX.addContextMenu(\"Optimize\", e, ( m: any ) =>\r\n                {\r\n                    this.selectedItems.forEach( item => {\r\n                        if( item.isTrack )\r\n                        {\r\n                            m.add( (item.groupId ? item.groupId : \"\" ) + \"@\" + item.id, () => {\r\n                                this.optimizeTrack( item.trackIdx, false );\r\n                            });\r\n                        }\r\n                        else\r\n                        {\r\n                            const tracks = this.animationClip.tracksPerGroup[ item ];\r\n                            for( let i = 0; i < tracks.length; ++i )\r\n                            {\r\n                                const t = tracks[ i ];\r\n                                m.add( (t.groupId ? t.groupId : \"\" ) + \"@\" + t.id, () => {\r\n                                    this.optimizeTrack( t.trackIdx, false );\r\n                                });\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        }\r\n\r\n        this.onShowContextMenu = ( e: any ) =>\r\n        {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n\r\n            let actions: any = [];\r\n            if( this.lastKeyFramesSelected && this.lastKeyFramesSelected.length )\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: \"Copy\",\r\n                        callback: () => {\r\n                            this.copySelectedContent();\r\n                        }\r\n                    }\r\n                );\r\n                actions.push(\r\n                    {\r\n                        title: \"Delete\",\r\n                        callback: () => {\r\n                            this.deleteSelectedContent();\r\n                        }\r\n                    }\r\n                );\r\n\r\n                if( this.lastKeyFramesSelected.length == 1 && this.clipboard && this.clipboard.value )\r\n                {\r\n                    actions.push(\r\n                        {\r\n                            title: \"Paste Value\",\r\n                            callback: () => {\r\n                                this.pasteContentValue();\r\n                            }\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: \"Add Here\",\r\n                        callback: () => {\r\n                            if( !e.track ){ return; }\r\n                            const values: any = new Float32Array( e.track.dim );\r\n                            values.fill( 0 );\r\n                            this.addKeyFrames( e.track.trackIdx, values, [this.xToTime(e.localX)] );\r\n                        }\r\n                    }\r\n                );\r\n                actions.push(\r\n                    {\r\n                        title: \"Add\",\r\n                        callback: () => {\r\n                            if( !e.track ){ return; }\r\n                            const values: any = new Float32Array( e.track.dim );\r\n                            values.fill( 0 );\r\n                            this.addKeyFrames( e.track.trackIdx, values, [this.currentTime] );\r\n                        }\r\n                    }\r\n                );\r\n\r\n            }\r\n\r\n            if( this.clipboard && this.clipboard.keyframes )\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: \"Paste Here\",\r\n                        callback: () => {\r\n                            this.pasteContent( this.xToTime( e.localX ) );\r\n                        }\r\n                    }\r\n                );\r\n                actions.push(\r\n                    {\r\n                        title: \"Paste\",\r\n                        callback: () => {\r\n                            this.pasteContent( this.currentTime );\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n\r\n            LX.addContextMenu(\"Options\", e, ( m: any ) => {\r\n                for(let i = 0; i < actions.length; i++) {\r\n                    m.add(actions[ i ].title,  actions[ i ].callback );\r\n                }\r\n            });\r\n        } // end of onShowContextMenu\r\n\r\n\r\n        if( this.animationClip )\r\n        {\r\n            this.setAnimationClip( this.animationClip );\r\n        }\r\n    }\r\n\r\n    // OVERRIDE\r\n    generateSelectedItemsTreeData(): any\r\n    {\r\n        const treeTracks: any[] = [];\r\n        const tracksPerGroup = this.animationClip.tracksPerGroup;\r\n\r\n        for( let i = 0; i < this.selectedItems.length; i++ )\r\n        {\r\n            const item = this.selectedItems[ i ];\r\n            const isGroup = !item.isTrack;\r\n            const itemTracks = isGroup ? tracksPerGroup[ item ] : [ item ];\r\n            const nodes: any[] = [];\r\n\r\n            for( let j = 0; j < itemTracks.length; j++ )\r\n            {\r\n                const track = itemTracks[ j ];\r\n                nodes.push({'trackData': track, 'id': track.id, 'skipVisibility': this.skipVisibility, visible: track.active, 'children':[], actions : this.skipLock ? null : [{\r\n                    'name':'Lock edition',\r\n                    'icon': (track.locked ? 'TimelineLock' : 'TimelineLockOpen'),\r\n                    'swap': (track.locked ? 'TimelineLockOpen' : 'TimelineLock'),\r\n                    'callback': (node: any, swapValue: boolean, event: Event) => {\r\n                        this.setTrackLock( node.trackData.trackIdx, !node.trackData.locked, false, false ); // do not update left panel\r\n                    }\r\n                }]});\r\n            }\r\n\r\n            if( isGroup )\r\n            {\r\n                const t = {\r\n                    'id': item,\r\n                    'skipVisibility': true,\r\n                    'children': nodes\r\n                };\r\n\r\n                treeTracks.push( t );\r\n            }\r\n            else\r\n            {\r\n                treeTracks.push( nodes[ 0 ] );\r\n            }\r\n        }\r\n\r\n        return treeTracks;\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE\r\n     * @param {Object} options track information that wants to be set to the new track\r\n     *  id, dim, values, times, selected, edited, hovered\r\n     * @returns\r\n     */\r\n    instantiateTrack( options: any = {}, clone: boolean = false )\r\n    {\r\n        const track : any = super.instantiateTrack( options );\r\n        track.dim = Math.max( 1, options.dim ?? 1 ); // >= 1\r\n        track.groupId = null,\r\n        track.groupTrackIdx = -1, // track Idx inside group only if in group\r\n\r\n        track.values = new Float32Array( 0 );\r\n        track.times = new Float32Array( 0 );\r\n        track.selected = [];\r\n        track.edited = [];\r\n        track.hovered = [];\r\n\r\n        if( options.values && options.times )\r\n        {\r\n            track.values = clone ? options.values.slice() : options.values;\r\n            track.times = clone ? options.times.slice() : options.times;\r\n\r\n            const numFrames = track.times.length;\r\n            if( options.selected && options.selected.length == numFrames )\r\n            {\r\n                track.selected = clone ? options.selected.slice() : options.selected;\r\n            }\r\n            else\r\n            {\r\n                track.selected = ( new Array( numFrames ) ).fill( false );\r\n            }\r\n\r\n            if( options.edited && options.edited.length == numFrames )\r\n            {\r\n                track.edited = clone ? options.edited.slice() : options.edited;\r\n            }\r\n            else\r\n            {\r\n                track.edited = ( new Array( numFrames ) ).fill( false );\r\n            }\r\n\r\n            if( options.hovered && options.hovered.length == numFrames )\r\n            {\r\n                track.hovered = clone ? options.hovered.slice() : options.hovered;\r\n            }\r\n            else\r\n            {\r\n                track.hovered = ( new Array( numFrames ) ).fill( false );\r\n            }\r\n        }\r\n\r\n        track.curves = options.curves ?? this.defaultCurves; // only works if dim == 1\r\n        track.curvesRange = ( options.curvesRange ?? this.defaultCurvesRange ).slice();\r\n\r\n        return track;\r\n    }\r\n\r\n    /**\r\n     * Generates an animationClip using either the parameters set in the animation argument or using default values\r\n     * @param {Object} animation data with which to generate an animationClip\r\n     * @returns\r\n     */\r\n    instantiateAnimationClip(animation: Nullable< any >, clone: boolean = false)\r\n    {\r\n        const animationClip: any = super.instantiateAnimationClip(animation, clone);\r\n\r\n        animationClip.tracksPerGroup = {};\r\n\r\n        if( animation && animation.tracks )\r\n        {\r\n            const tracksPerGroup: any = {};\r\n            let duration = 0;\r\n            for( let i = 0; i < animation.tracks.length; ++i ) {\r\n\r\n                let track = animation.tracks[ i ];\r\n                let times = track.times ?? [];\r\n                let values = track.values ?? [];\r\n\r\n                let valueDim = track.dim;\r\n                if( !valueDim || valueDim < 0 ){\r\n                    if( times.length && values.length ){ valueDim = Math.round(values.length/times.length); }\r\n                    else{ valueDim = 1; }\r\n                }\r\n\r\n                let baseName = track.id ?? track.name;\r\n                const [groupId, trackId] = baseName ? this._getValidTrackName(baseName) : [null, null];\r\n\r\n                const toInstantiate = Object.assign({}, track);\r\n                toInstantiate.id = trackId;\r\n                toInstantiate.dim = valueDim;\r\n                const trackInfo = this.instantiateTrack(toInstantiate, clone);\r\n\r\n                // manual group insertion\r\n                if( groupId )\r\n                {\r\n                    if( !tracksPerGroup[ groupId ] )\r\n                    {\r\n                        tracksPerGroup[ groupId ] = [ trackInfo ];\r\n                    }\r\n                    else\r\n                    {\r\n                        tracksPerGroup[ groupId ].push( trackInfo );\r\n                    }\r\n\r\n                    trackInfo.groupId = groupId;\r\n                    trackInfo.groupTrackIdx = tracksPerGroup[ groupId ].length - 1; // index of track in group\r\n                }\r\n\r\n                trackInfo.trackIdx = i; // index of track in the entire animation\r\n\r\n                animationClip.tracks.push( trackInfo );\r\n\r\n                if( trackInfo.times.length ) { duration = Math.max( duration, trackInfo.times[trackInfo.times.length-1]); }\r\n            }\r\n\r\n            animationClip.tracksPerGroup = tracksPerGroup;\r\n            if( !animation || !animation.duration )\r\n            {\r\n                animationClip.duration = duration;\r\n            }\r\n\r\n            // overwrite trackspergroup\r\n            if( animation.tracksPerGroup )\r\n            {\r\n                // ungroup all tracks (just in case)\r\n                animationClip.tracks.forEach( (v: any,i: number) =>{ v.groupId = null; v.groupTrackIdx = -1; } );\r\n\r\n                animationClip.tracksPerGroup = {};\r\n                let tpg = animation.tracksPerGroup;\r\n                for( let groupId in tpg )\r\n                {\r\n                    const source = tpg[ groupId ];\r\n                    const target: any[] = [];\r\n                    for( let ti = 0; ti < source.length; ++ti )\r\n                    {\r\n                        const trackInfo = animationClip.tracks[ source[ ti ].trackIdx ]; // redo references\r\n                        target[ ti ] = trackInfo;\r\n                        trackInfo.groupId = groupId;\r\n                        trackInfo.groupTrackIdx = ti; // index of track in group\r\n                    }\r\n                    animationClip.tracksPerGroup[ groupId ] = target;\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationClip;\r\n    }\r\n\r\n    // OVERRIDE\r\n    deselectAllElements()\r\n    {\r\n        this.deselectAllKeyFrames();\r\n        this.unHoverAll();\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE\r\n     * @param {Array} itemsToAdd [ trackIdx, \"groupId\" ], array of strings and/or number identifying groups and/or tracks\r\n     * @param {Array} itemsToRemove [ trackIdx, \"groupId\" ], array of strings and/or number identifying groups and/or tracks\r\n     */\r\n    changeSelectedItems( itemsToAdd: Nullable<any[]> = null, itemsToRemove: Nullable<any[]> = null, skipCallback: boolean = false )\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left panel. It is going to be rebuilt anyways\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        const tracksPerGroup = this.animationClip.tracksPerGroup;\r\n\r\n        if( itemsToRemove )\r\n        {\r\n            for( let i = 0; i < itemsToRemove.length; ++i)\r\n            {\r\n                const isGroup: boolean = !!itemsToRemove[ i ].substr;\r\n                let compareObj = isGroup ? itemsToRemove[ i ] : tracks[itemsToRemove[ i ]]; // trackData or groupId\r\n                for( let s = 0; s < this.selectedItems.length; ++s)\r\n                {\r\n                    if( this.selectedItems[ s ] === compareObj )\r\n                    {\r\n                        const size = isGroup ? tracksPerGroup[ compareObj ].length : 1;\r\n                        this.selectedItems.splice( s, size );\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if( itemsToAdd )\r\n        {\r\n            for( let i = 0; i < itemsToAdd.length; ++i )\r\n            {\r\n                const v = itemsToAdd[ i ];\r\n                if( isNaN(v) ) // assuming it is a string\r\n                {\r\n                    if( tracksPerGroup[ v ] )\r\n                    {\r\n                        this.selectedItems.push( v );\r\n                    }\r\n                }\r\n                else if( tracks[ v ] )\r\n                {\r\n                    this.selectedItems.push( tracks[ v ] );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateLeftPanel();\r\n\r\n        if( this.onItemSelected && !skipCallback )\r\n        {\r\n            this.onItemSelected( this.selectedItems, itemsToAdd, itemsToRemove );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {String} groupId unique identifier\r\n     * @param {Array} groupTracks [ \"trackID\", trackIdx ] array of strings and/or numbers of the existing tracks to include in this group. A track can only be part of 1 group\r\n     *  if groupTracks == null, groupId is removed from the list\r\n     */\r\n    setTracksGroup( groupId: string, groupTracks: Nullable< (string | number)[] > = null )\r\n    {\r\n        const tracks = this.animationClip.tracks;\r\n        const tracksPerGroup = this.animationClip.tracksPerGroup;\r\n        const result: any = [];\r\n\r\n        let selectedItemsCounter = -1;\r\n\r\n        if( tracksPerGroup[ groupId ] )\r\n        {\r\n            // if group exists, ungroup tracks.\r\n            tracksPerGroup[ groupId ].forEach((t: any)=> {\r\n                t.groupId = null;\r\n                t.groupTrackIdx = -1;\r\n            });\r\n\r\n            // modify groups cannot appear more than once\r\n            for( let i = 0; i < this.selectedItems.length; ++i ){\r\n                if(this.selectedItems[ i ] === groupId){\r\n                    selectedItemsCounter = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if( !groupTracks )\r\n        {\r\n            delete tracksPerGroup.groupId;\r\n            // remove entry from selectedItems\r\n            if( selectedItemsCounter > -1 ){\r\n                this.selectedItems.splice(selectedItemsCounter, 1);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // find tracks and group them\r\n        for (let i = 0; i < groupTracks.length; ++i)\r\n        {\r\n            const v = groupTracks[ i ];\r\n            let track: any = null;\r\n            if( typeof v == \"string\" )\r\n            {\r\n                // v is an id  (string)\r\n                for( let t = 0; t < tracks.length; ++t )\r\n                {\r\n                    if(tracks[ t ].id == v)\r\n                    {\r\n                        track = tracks[ t ];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else if( tracks[ v ] )\r\n            {\r\n                track = tracks[ v ];\r\n            }\r\n\r\n            if( track )\r\n            {\r\n                track.groupId = groupId;\r\n                track.groupTrackIdx = result.length;\r\n                result.push( track );\r\n            }\r\n        }\r\n\r\n        tracksPerGroup[ groupId ] = result;\r\n\r\n        // if group is currently visible\r\n        if( selectedItemsCounter > -1 )\r\n        {\r\n            this.updateLeftPanel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {String} groupId\r\n     * @returns array of tracks or null\r\n     */\r\n    getTracksGroup( groupId: string ): any[] | null\r\n    {\r\n        return this.animationClip.tracksPerGroup[ groupId ] ?? null;\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE\r\n     * @param {String} trackId\r\n     * @param {String} groupId optionl. If not set, it will find the first occurrence of trackId in animationClip.tracks\r\n     * @returns\r\n     */\r\n    getTrack( trackId: string, groupId: Nullable< string > = null )\r\n    {\r\n        let tracks = this.animationClip.tracks;\r\n        if( groupId )\r\n        {\r\n            tracks = this.animationClip.tracksPerGroup[ groupId ] ?? [];\r\n        }\r\n\r\n        for( let i = 0; i < tracks.length; ++i)\r\n        {\r\n            if( tracks[ i ].id == trackId )\r\n            {\r\n                return tracks[ i ];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Number} size pixels, height of keyframe\r\n     * @param {Number} sizeHovered optional, size in pixels when hovered\r\n     */\r\n    setKeyframeSize( size: number, sizeHovered: Nullable< number > = null )\r\n    {\r\n        this.keyframeSizeHovered = sizeHovered ?? size;\r\n        this.keyframeSize = size;\r\n    }\r\n\r\n    onMouseUp( e: any, time: number )\r\n    {\r\n        let track = e.track;\r\n        let localX = e.localX;\r\n        let discard = e.discard; // true when too much time has passed between Down and Up\r\n\r\n        if( e.shiftKey )\r\n        {\r\n            // Manual multiple selection\r\n            if( !discard && track )\r\n            {\r\n                const thresholdPixels = this.keyframeSize * 0.5; // radius of circle (curves) or rotated square (keyframes)\r\n                const keyFrameIdx = this.getCurrentKeyFrame( track, this.xToTime( localX ), this.secondsPerPixel * thresholdPixels );\r\n                if( keyFrameIdx > -1 ){\r\n                    track.selected[keyFrameIdx] ?\r\n                        this.deselectKeyFrame(track.trackIdx, keyFrameIdx) :\r\n                        this.processSelectionKeyFrame( track.trackIdx, keyFrameIdx, true );\r\n                }\r\n            }\r\n            // Box selection\r\n            else if( this.boxSelection )\r\n            {\r\n                let tracks = this.getTracksInRange( this.boxSelectionStart[ 1 ], this.boxSelectionEnd[ 1 ] );\r\n\r\n                for( let t of tracks )\r\n                {\r\n                    let keyFrameIndices = this.getKeyFramesInRange( t,\r\n                        this.xToTime( this.boxSelectionStart[ 0 ] ),\r\n                        this.xToTime( this.boxSelectionEnd[ 0 ] ),\r\n                        this.secondsPerPixel * 5 );\r\n\r\n                    if( keyFrameIndices )\r\n                    {\r\n                        for( let index = keyFrameIndices[ 0 ]; index <= keyFrameIndices[ 1 ]; ++index )\r\n                        {\r\n                            this.processSelectionKeyFrame( t.trackIdx, index, true );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if( !this.movingKeys && !discard ) // if not moving timeline and not adding keyframes through e.shiftkey (just a click)\r\n        {\r\n            if( this.lastKeyFramesSelected.length )\r\n            {\r\n                if( this.onDeselectKeyFrames )\r\n                {\r\n                    this.onDeselectKeyFrames( this.lastKeyFramesSelected );\r\n                }\r\n\r\n                this.deselectAllKeyFrames();\r\n            }\r\n\r\n            if( track )\r\n            {\r\n                const thresholdPixels = this.keyframeSize * 0.5; // radius of circle (curves) or rotated square (keyframes)\r\n                const keyFrameIndex = this.getCurrentKeyFrame( track, this.xToTime( localX ), this.secondsPerPixel * thresholdPixels );\r\n                if( keyFrameIndex > -1 )\r\n                {\r\n                    this.processSelectionKeyFrame( track.trackIdx, keyFrameIndex, false ); // Settings this as multiple so time is not being set\r\n                }\r\n            }\r\n        }\r\n\r\n        this.canvas.classList.remove( 'grabbing' );\r\n    }\r\n\r\n    onMouseDown( e: any, time: number )\r\n    {\r\n        // function not called if shift is pressed (boxselection)\r\n\r\n        let localX = e.localX;\r\n        let localY = e.localY;\r\n        let track = e.track;\r\n\r\n        if( ( e.ctrlKey || e.altKey ) && this.lastKeyFramesSelected.length ) // move keyframes\r\n        {\r\n            this.movingKeys = true;\r\n            this.canvas.style.cursor = \"grab\";\r\n            this.canvas.classList.add('grabbing');\r\n\r\n            // Set pre-move state\r\n            this.moveKeyMinTime = Infinity;\r\n            const tracks = this.animationClip.tracks;\r\n            let lastTrackIdx = -1;\r\n            for(let selectedKey of this.lastKeyFramesSelected) // WARNING assumes lasKeyFramesSelected is sorted, so all keyframes of the same track are grouped\r\n            {\r\n                let [trackIdx, keyIndex, keyTime] = selectedKey;\r\n                const track = tracks[ trackIdx ];\r\n\r\n                selectedKey[ 2 ] = track.times[ keyIndex ]; // update original time just in case\r\n\r\n                if( lastTrackIdx != trackIdx )\r\n                {\r\n                    // save track states only once\r\n                    if( this.moveKeyMinTime < Infinity )\r\n                    {\r\n                        this.saveState( track.trackIdx, true );\r\n                    }\r\n                    else\r\n                    {\r\n                        this.saveState( track.trackIdx, false );\r\n                    }\r\n\r\n                    this.moveKeyMinTime = Math.min( this.moveKeyMinTime, selectedKey[ 2 ] );\r\n                    lastTrackIdx = trackIdx;\r\n                }\r\n            }\r\n\r\n            this.timeBeforeMove = this.xToTime( localX );\r\n\r\n            this.grabbing = false;\r\n            this.grabbingTimeBar = false;\r\n        }\r\n    }\r\n\r\n    onMouseMove( e: any, time: number )\r\n    {\r\n        // function not called if shift is pressed (boxselection)\r\n\r\n        let localX = e.localX;\r\n        let localY = e.localY;\r\n        let track = e.track;\r\n\r\n        if(this.movingKeys) // move keyframes\r\n        {\r\n            let newTime = this.xToTime( localX );\r\n            let deltaTime = newTime - this.timeBeforeMove;\r\n\r\n            if( deltaTime + this.moveKeyMinTime < 0 )\r\n            {\r\n                deltaTime = -this.moveKeyMinTime;\r\n            }\r\n\r\n            this.timeBeforeMove = this.timeBeforeMove + deltaTime;\r\n\r\n            if( e.ctrlKey )\r\n            {\r\n                this.moveKeyMinTime += deltaTime;\r\n                const tracks = this.animationClip.tracks;\r\n                for( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n                {\r\n                    let idx = i;\r\n                    if( deltaTime > 0 ){\r\n                        idx = this.lastKeyFramesSelected.length - 1 - i;\r\n                    }\r\n\r\n                    const [trackIdx, keyIndex, originalKeyTime] = this.lastKeyFramesSelected[ idx ];\r\n                    track = tracks[ trackIdx ];\r\n\r\n                    if( track && track.locked )\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    this.canvas.style.cursor = \"grabbing\";\r\n\r\n                    const times = this.animationClip.tracks[ track.trackIdx ].times;\r\n                    times[ keyIndex ] = Math.max(0,times[ keyIndex ] + deltaTime);\r\n\r\n                    if( times[ keyIndex ] > this.duration )\r\n                    {\r\n                        this.setDuration( times[ keyIndex ] );\r\n                    }\r\n\r\n                    // sort keyframe\r\n                    let k = keyIndex;\r\n                    if( deltaTime > 0 )\r\n                    {\r\n                        for( ; k < times.length-1; ++k )\r\n                        {\r\n                            if( times[ k ] < times[ k + 1 ] )\r\n                            {\r\n                                break;\r\n                            }\r\n\r\n                            this.swapKeyFrames( track, k + 1, k );\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        for( ; k > 0; --k )\r\n                        {\r\n                            if( times[ k - 1 ] < times[ k ] ){\r\n                                break;\r\n                            }\r\n                            this.swapKeyFrames(track, k-1, k);\r\n                        }\r\n                    }\r\n                    this.lastKeyFramesSelected[ idx ][ 1 ] = k; // update keyframe index\r\n                    this.lastKeyFramesSelected[ idx ][ 2 ] = times[ k ]; // update keyframe time\r\n                }\r\n\r\n                if( this.onContentMoved )\r\n                {\r\n                    for( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n                    {\r\n                        const [ trackIdx, keyIndex, originalKeyTime ] = this.lastKeyFramesSelected[ i ];\r\n                        track = this.animationClip.tracks[ trackIdx ];\r\n                        if( track && track.locked )\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        this.onContentMoved( trackIdx, keyIndex );\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Track.dim == 1:  move keyframes vertically (change values instead of time)\r\n            // RELIES ON SORTED ARRAY OF lastKeyFramesSelected\r\n            if( e.altKey && e.buttons & 0x01 )\r\n            {\r\n                const tracks = this.animationClip.tracks;\r\n                let lastTrackChanged = -1;\r\n                for( let i = 0; i < this.lastKeyFramesSelected.length; ++i )\r\n                {\r\n                    const [trackIdx, keyIndex, originalKeyTime] = this.lastKeyFramesSelected[ i ];\r\n                    track = tracks[ trackIdx ];\r\n                    if( track.locked || track.dim != 1 || !track.curves )\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    let value = track.values[ keyIndex ];\r\n                    let delta = e.deltay * this.keyValuePerPixel * (track.curvesRange[ 1 ]-track.curvesRange[ 0 ]);\r\n                    track.values[ keyIndex ] = Math.max(track.curvesRange[ 0 ], Math.min(track.curvesRange[ 1 ], value - delta)); // invert delta because of screen y\r\n                    track.edited[ keyIndex ] = true;\r\n\r\n                    if( this.onUpdateTrack && track.trackIdx != lastTrackChanged && lastTrackChanged > -1){ // do it only once all keyframes of the same track have been modified\r\n                        this.onUpdateTrack( [track.trackIdx] );\r\n                    }\r\n                    lastTrackChanged = track.trackIdx;\r\n                }\r\n                if( this.onUpdateTrack && lastTrackChanged > -1 ) // do the last update, once the last track has been processed\r\n                {\r\n                    this.onUpdateTrack( [ track.trackIdx ] );\r\n                }\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        if( this.grabbing && e.button != 2 )\r\n        {\r\n\r\n        }\r\n        else if( track )\r\n        {\r\n            this.unHoverAll();\r\n            const thresholdPixels = this.keyframeSize * 0.5; // radius of circle (curves) or rotated square (keyframes)\r\n            let keyFrameIndex = this.getCurrentKeyFrame( track, this.xToTime( localX ), this.secondsPerPixel * thresholdPixels );\r\n\r\n            if( keyFrameIndex > -1 )\r\n            {\r\n                if( track && track.locked )\r\n                {\r\n                    return;\r\n                }\r\n\r\n                this.lastHovered = [ track.trackIdx, keyFrameIndex ];\r\n                track.hovered[ keyFrameIndex ] = true;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.unHoverAll();\r\n        }\r\n    }\r\n\r\n    drawContent( ctx: CanvasRenderingContext2D )\r\n    {\r\n        if( !this.animationClip )\r\n        {\r\n            return;\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        const trackHeight = this.trackHeight;\r\n        const scrollY = - this.currentScrollInPixels;\r\n\r\n        // elements from \"ul\" should match the visible tracks (and groups) as if this.selectedItems was flattened\r\n        const visibleElements = this.getVisibleItems();\r\n\r\n        let offset = scrollY;\r\n\r\n        // compute track from which to start rendering (avoid rendering unseen tracks)\r\n        let startElIdx = 0;\r\n        if( offset < -this.lastTrackTreesComponentOffset ) // offset 0 = (0 of canvas) + track-Tree-Offset. This renders tracks under the time zone\r\n        {\r\n            startElIdx = Math.floor( -(offset + this.lastTrackTreesComponentOffset) / this.trackHeight ); // how many tracks to skip\r\n            offset += startElIdx * this.trackHeight;\r\n        }\r\n\r\n        ctx.translate( 0, offset );\r\n\r\n        // compute track to end rendering (avoid rendering unseen tracks)\r\n        let endElIdx = startElIdx + Math.ceil( ( ctx.canvas.height - this.lastTrackTreesComponentOffset - offset ) / this.trackHeight );\r\n        endElIdx = endElIdx > visibleElements.length ? visibleElements.length : endElIdx;\r\n\r\n        for( let t = startElIdx; t < endElIdx; t++ )\r\n        {\r\n            const track = visibleElements[ t ].treeData.trackData;\r\n            if( track )\r\n            {\r\n                if( track.dim == 1 && track.curves )\r\n                {\r\n                    this.drawTrackWithCurves( ctx, trackHeight, track );\r\n                }\r\n                else\r\n                {\r\n                    this.drawTrackWithKeyframes( ctx, trackHeight, track );\r\n                }\r\n            }\r\n\r\n            ctx.translate( 0, trackHeight );\r\n        }\r\n\r\n        ctx.restore();\r\n    };\r\n\r\n    /**\r\n     * @method drawTrackWithKeyframes\r\n     * @param {*} ctx\r\n     * ...\r\n     * @description helper function, you can call it from drawContent to render all the keyframes\r\n    */\r\n    drawTrackWithKeyframes( ctx: CanvasRenderingContext2D, trackHeight: number, track: any ) {\r\n\r\n        if(track.isSelected) {\r\n            ctx.globalAlpha = 0.2;\r\n            ctx.fillStyle = Timeline.TRACK_SELECTED;\r\n            ctx.fillRect(0, 0, ctx.canvas.width, trackHeight );\r\n        }\r\n\r\n        ctx.fillStyle = Timeline.KEYFRAME_COLOR;\r\n        ctx.globalAlpha = 1;\r\n\r\n        const keyframes = track.times;\r\n        const startTime = this.visualTimeRange[ 0 ];\r\n        const endTime = this.visualTimeRange[ 1 ] + 0.0000001;\r\n        const defaultPointSize = this.keyframeSize / Math.SQRT2; // pythagoras with equal sides h2 = c2 + c2 = 2 * c2\r\n        const hoverPointSize = this.keyframeSizeHovered / Math.SQRT2;\r\n\r\n        for(let j = 0; j < keyframes.length; ++j)\r\n        {\r\n            let time = keyframes[ j ];\r\n            if( time < startTime || time > endTime ) {\r\n                continue;\r\n            }\r\n\r\n            let keyframePosX = this.timeToX( time );\r\n            let size = defaultPointSize;\r\n\r\n            if(!this.active || track.active == false) {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_INACTIVE;\r\n            }\r\n            else if(track.locked) {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_LOCK;\r\n            }\r\n            else if(track.hovered[ j ]) {\r\n                size = hoverPointSize;\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_HOVERED;\r\n            }\r\n            else if(track.selected[ j ]) {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_SELECTED;\r\n            }\r\n            else if(track.edited[ j ]) {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_EDITED;\r\n            }\r\n            else {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR;\r\n            }\r\n\r\n            ctx.save();\r\n            ctx.translate(keyframePosX, trackHeight * 0.5);\r\n            ctx.rotate(45 * Math.PI / 180);\t\t\r\n            ctx.fillRect( -size*0.5, -size*0.5, size, size);\r\n            ctx.restore();\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n    }\r\n\r\n    drawTrackWithCurves (ctx: CanvasRenderingContext2D, trackHeight: number, track: any) {\r\n        if(track.isSelected){\r\n            ctx.globalAlpha = 0.2;\r\n            ctx.fillStyle = Timeline.TRACK_SELECTED_LIGHT;\r\n            ctx.fillRect(0, 0, ctx.canvas.width, trackHeight );\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n        const keyframes = track.times;\r\n        const values = track.values;\r\n        const defaultPointSize = this.keyframeSize * 0.5; // radius\r\n        const hoverPointSize = this.keyframeSizeHovered * 0.5; // radius\r\n        const valueRange = track.curvesRange; //[min, max]\r\n        const displayRange = trackHeight - defaultPointSize * 2;\r\n        const startTime = this.visualTimeRange[ 0 ];\r\n        const endTime = this.visualTimeRange[ 1 ] + 0.0000001;\r\n        //draw lines\r\n        ctx.strokeStyle = \"white\";\r\n        ctx.beginPath();\r\n\r\n        if( keyframes.length > 1){\r\n            let startPosX = this.timeToX( keyframes[ 0 ] );\r\n            let startValue = values[ 0 ];\r\n            startValue = LX.clamp((startValue - valueRange[ 0 ]) / (valueRange[ 1 ] - valueRange[ 0 ]), 0,1) * (-displayRange) + (trackHeight - defaultPointSize); // normalize and offset\r\n            ctx.moveTo( startPosX, startValue );\r\n\r\n            for(let j = 1; j < keyframes.length; ++j){\r\n\r\n                let time = keyframes[ j ];\r\n                let keyframePosX = this.timeToX( time );\r\n                let value = values[ j ];\r\n                value = LX.clamp((value - valueRange[ 0 ]) / (valueRange[ 1 ] - valueRange[ 0 ]), 0,1) * (-displayRange) + (trackHeight - defaultPointSize); // normalize and offset\r\n\r\n                if( time < startTime ){\r\n                    ctx.moveTo( keyframePosX, value );\r\n                    continue;\r\n                }\r\n\r\n                if( time > endTime ){\r\n                    let lastKeyframePosX = this.timeToX( keyframes[j-1] );\r\n                    let dt = keyframePosX - lastKeyframePosX;\r\n                    if( dt > 0 ){\r\n                        let lastValue = values[j-1];\r\n                        lastValue = LX.clamp((lastValue - valueRange[ 0 ]) / (valueRange[ 1 ] - valueRange[ 0 ]), 0,1) * (-displayRange) + (trackHeight - defaultPointSize); // normalize and offset\r\n                        let f = (this.timeToX( endTime ) - lastKeyframePosX) / dt;\r\n                        ctx.lineTo( lastKeyframePosX + dt * f, lastValue * (1-f) + value * f );\r\n                    }\r\n                    break; //end loop, but print line\r\n                }\r\n\r\n                //convert to timeline track range\r\n                ctx.lineTo( keyframePosX, value );\r\n            }\r\n            ctx.stroke();\r\n        }\r\n\r\n        //draw points\r\n        ctx.fillStyle = Timeline.KEYFRAME_COLOR;\r\n        for(let j = 0; j < keyframes.length; ++j)\r\n        {\r\n            let time = keyframes[ j ];\r\n            if( time < startTime || time > endTime )\r\n                continue;\r\n\r\n            let size = defaultPointSize;\r\n            let keyframePosX = this.timeToX( time );\r\n\r\n            if(!this.active || !track.active)\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_INACTIVE;\r\n            else if(track.locked)\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_LOCK;\r\n            else if(track.hovered[ j ]) {\r\n                size = hoverPointSize;\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_HOVERED;\r\n            }\r\n            else if(track.selected[ j ])\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_SELECTED;\r\n            else if(track.edited[ j ])\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_EDITED;\r\n            else\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR\r\n\r\n            let value = values[ j ];\r\n            value = LX.clamp((value - valueRange[ 0 ]) / (valueRange[ 1 ] - valueRange[ 0 ]), 0,1) *(-displayRange) + (trackHeight - defaultPointSize); // normalize, clamp and offset\r\n\r\n            ctx.beginPath();\r\n            ctx.arc( keyframePosX, value, size, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n        }\r\n    }\r\n\r\n    _getValidTrackName( uglyName: string ) {\r\n\r\n        let groupId = null;\r\n        let trackId = null;\r\n        let trackNameInfo;\r\n        // Support other versions\r\n        if(uglyName.includes(\"[\")) {\r\n            const nameIndex = uglyName.indexOf('[');\r\n            trackNameInfo = uglyName.substring(nameIndex+1).split(\"].\");\r\n        }else {\r\n            trackNameInfo = uglyName.split(\".\");\r\n        }\r\n\r\n        if( trackNameInfo.length > 1 ){\r\n            groupId = trackNameInfo[ 0 ];\r\n            trackId = trackNameInfo[ 1 ];\r\n        }else{\r\n            trackId = trackNameInfo[ 0 ];\r\n        }\r\n\r\n        return [groupId, trackId];\r\n    }\r\n\r\n    /**\r\n     * updates an existing track with new values and times.\r\n     * @param {Int} trackIdx index of track in the animationClip\r\n     * @param {*} newTrack object with two arrays: values and times. These will be set to the selected track\r\n     * @returns\r\n     */\r\n    updateTrack(trackIdx: number, newTrack: any) {\r\n        if(!this.animationClip)\r\n            return false;\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        track.values = newTrack.values;\r\n        track.times = newTrack.times;\r\n\r\n        track.selected = newTrack.selected ?? (new Array(track.times.length)).fill( false );\r\n        track.hovered = newTrack.hovered ?? (new Array(track.times.length)).fill( false );\r\n        track.edited = newTrack.edited ?? (new Array(track.times.length)).fill( false );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * removes equivalent sequential keys either because of equal times or values\r\n     * (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n     * @param {Int} trackIdx index of track in the animation\r\n     * @param {Boolean} onlyEqualTime if true, removes only keyframes with equal times. Otherwise, values are ALSO compared through the class threshold\r\n     * @param {Boolean} skipCallback if false, triggers \"onOptimizeTracks\" after optimizing\r\n     */\r\n    optimizeTrack( trackIdx: number, onlyEqualTime: boolean = false, skipCallback: boolean = false ) {\r\n        if( !this.animationClip ){ return; }\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ],\r\n            times = track.times,\r\n            values = track.values,\r\n            stride = track.dim,\r\n            threshold = this.optimizeThreshold;\r\n\r\n        if( track.locked ){\r\n            return;\r\n        }\r\n\r\n        let cmpFunction = (v: number, p: number, n: number, t: number) => { return Math.abs(v - p) >= t || Math.abs(v - n) >= t };\r\n        let lastSavedIndex = 0;\r\n        const lastIndex = times.length-1;\r\n\r\n        this.saveState(track.trackIdx);\r\n\r\n        for ( let i = 1; i < lastIndex; ++ i ) {\r\n\r\n            let keep = false;\r\n            const time = times[ i ];\r\n            const timePrev = times[ lastSavedIndex ];\r\n\r\n            // remove adjacent keyframes scheduled at the same time\r\n            if( time !== timePrev ) {\r\n                if( ! onlyEqualTime ) {\r\n                    // remove unnecessary keyframes same as their neighbors\r\n                    const offset = i * stride,\r\n                        offsetP = lastSavedIndex * stride,\r\n                        offsetN = offset + stride;\r\n\r\n                    for ( let j = 0; j !== stride; ++ j ) {\r\n                        if( cmpFunction(\r\n                            values[ offset + j ],\r\n                            values[ offsetP + j ],\r\n                            values[ offsetN + j ],\r\n                            threshold))\r\n                        {\r\n                            keep = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    keep = true;\r\n                }\r\n            }\r\n\r\n            // in-place compaction\r\n            if( keep ) {\r\n                ++lastSavedIndex;\r\n                if( i !== lastSavedIndex ) {\r\n                    times[ lastSavedIndex ] = times[ i ];\r\n                    const readOffset = i * stride,\r\n                        writeOffset = lastSavedIndex * stride;\r\n                    for ( let j = 0; j !== stride; ++ j ) {\r\n                        values[ writeOffset + j ] = values[ readOffset + j ];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // add last frame. first and last keyframes should be always kept\r\n        if( times.length > 1 ) {\r\n            ++lastSavedIndex;\r\n            times[ lastSavedIndex ] = times[ times.length - 1 ];\r\n            const readOffset = values.length - stride,\r\n                writeOffset = lastSavedIndex * stride;\r\n            for ( let j = 0; j !== stride; ++j ) {\r\n                values[ writeOffset + j ] = values[ readOffset + j ];\r\n            }\r\n        }\r\n\r\n        // commit changes\r\n        if( lastSavedIndex < times.length-1 ) {\r\n            track.times = times.slice( 0, lastSavedIndex + 1 );\r\n            track.values = values.slice( 0, (lastSavedIndex + 1) * stride );\r\n            this.updateTrack( track.trackIdx, track ); // update control variables (hover, edited, selected)\r\n        }\r\n\r\n        if(this.onOptimizeTracks && !skipCallback )\r\n            this.onOptimizeTracks(trackIdx);\r\n    }\r\n\r\n    optimizeTracks(onlyEqualTime: boolean = false) {\r\n\r\n        if(!this.animationClip)\r\n            return;\r\n\r\n        // save all states into a single entry\r\n        if( this.historySaveEnabler ){\r\n            for( let i = 0; i < this.animationClip.tracks.length; ++i ) {\r\n                this.saveState(i, i!=0);\r\n            }\r\n        }\r\n\r\n        // disable state saving\r\n        const oldStateEnabler = this.historySaveEnabler;\r\n        this.historySaveEnabler = false;\r\n\r\n        // optimize\r\n        for( let i = 0; i < this.animationClip.tracks.length; ++i ) {\r\n            const track = this.animationClip.tracks[ i ];\r\n            this.optimizeTrack( track.trackIdx, onlyEqualTime, true );\r\n        }\r\n\r\n        // restore old enabler status\r\n        this.historySaveEnabler = oldStateEnabler;\r\n\r\n        // callback\r\n        if( this.onOptimizeTracks )\r\n            this.onOptimizeTracks(-1); // signal as \"all tracks\"\r\n    }\r\n\r\n    /**\r\n     * saveState function uses this to generate a \"copy\" of the track.\r\n     * @param {Number} trackIdx\r\n     * @returns All necessary information to reconstruct the track state\r\n     */\r\n    historyGenerateTrackStep( trackIdx: number ){\r\n        const trackInfo = this.animationClip.tracks[ trackIdx ];\r\n\r\n        const undoStep = {\r\n            trackIdx: trackIdx, // already done by saveState\r\n            t: trackInfo.times.slice(),\r\n            v: trackInfo.values.slice(),\r\n            edited: trackInfo.edited.slice(0, trackInfo.times.length)\r\n        };\r\n\r\n        return undoStep;\r\n    }\r\n\r\n    /**\r\n     * It should swap the previous state with the incoming state of the track. It must return the previous state.\r\n     * historyGenerateTrackStep could be used to copy the previous state. However, as it is a swap, it suffices to just copy the references.\r\n     * @param {Object} state object with a trackIdx:Number and whatever information was saved in historyGenerateTrackStep\r\n     * @param {Boolean} isUndo\r\n     * @returns previous state object\r\n     */\r\n    historyApplyTrackStep( state: any, isUndo: boolean ){\r\n        const track = this.animationClip.tracks[state.trackIdx];\r\n\r\n        const stateToReturn = {\r\n            trackIdx: state.trackIdx,\r\n            t: track.times,\r\n            v: track.values,\r\n            edited: track.edited\r\n        };\r\n\r\n        track.times = state.t;\r\n        track.values = state.v;\r\n        track.edited = state.edited;\r\n        if( track.selected.length != track.times.length ){ track.selected.length = track.times.length; }\r\n        if( track.hovered.length != track.times.length ){ track.hovered.length = track.times.length; }\r\n        track.selected.fill( false );\r\n        track.hovered.fill( false );\r\n\r\n        return stateToReturn;\r\n    }\r\n\r\n    /**\r\n    *\r\n    * @param {*} track\r\n    * @param {Number} srcIdx keyFrame index\r\n    * @param {Number} trgIdx keyFrame index\r\n    */\r\n    swapKeyFrames(track: any, srcIdx: number, trgIdx: number){\r\n        const times = track.times;\r\n        const values = track.values;\r\n\r\n        let tmp = times[srcIdx];\r\n        times[srcIdx] = times[trgIdx];\r\n        times[trgIdx] = tmp;\r\n\r\n        tmp = track.hovered[srcIdx];\r\n        track.hovered[srcIdx] = track.hovered[trgIdx];\r\n        track.hovered[trgIdx] = tmp;\r\n\r\n        tmp = track.edited[srcIdx];\r\n        track.edited[srcIdx] = track.edited[trgIdx];\r\n        track.edited[trgIdx] = tmp;\r\n\r\n        tmp = track.selected[srcIdx];\r\n        track.selected[srcIdx] = track.selected[trgIdx];\r\n        track.selected[trgIdx] = tmp;\r\n\r\n        let src = srcIdx * track.dim;\r\n        let end = src + track.dim;\r\n        let trg = trgIdx * track.dim;\r\n        for( ; src < end; ++src ){\r\n            tmp = values[ src ];\r\n            values[ src ] = values[ trg ];\r\n            values[ trg ] = tmp;\r\n            ++trg;\r\n        }\r\n    }\r\n\r\n    copySelectedContent() {\r\n        if(!this.lastKeyFramesSelected.length){\r\n            return;\r\n        }\r\n\r\n        if(!this.clipboard)\r\n            this.clipboard = {};\r\n\r\n        this.clipboard.keyframes = {}; // reset clipboard\r\n\r\n        // sort keyframes selected by track\r\n        let toCopy: any = {};\r\n        const tracks = this.animationClip.tracks;\r\n        for(let i = 0; i < this.lastKeyFramesSelected.length; i++){\r\n            let [trackIdx, keyIdx] = this.lastKeyFramesSelected[ i ];\r\n            const track = tracks[ trackIdx ];\r\n\r\n            if(toCopy[ trackIdx ]) {\r\n                toCopy[ trackIdx ].idxs.push(keyIdx);\r\n            } else {\r\n                toCopy[ trackIdx ] = {track: track, idxs : [keyIdx]};\r\n            }\r\n            if(i == 0) {\r\n                this.copyKeyFrameValue(track, keyIdx);\r\n            }\r\n        }\r\n\r\n        // for each track selected, copy its values\r\n        for(let trackIdx in toCopy) {\r\n            this.copyKeyFrames(toCopy[ trackIdx ].track, toCopy[ trackIdx ].idxs);\r\n        }\r\n    }\r\n\r\n    // copies the current value of the keyframe. This value can be pasted across any track (as long as they are of the same type)\r\n    copyKeyFrameValue( track: any, index: number ) {\r\n\r\n        // 1 element clipboard by now\r\n        const start = index * track.dim;\r\n        const values = this.animationClip.tracks[ track.trackIdx ].values.slice(start, start + track.dim);\r\n\r\n        if(!this.clipboard)\r\n            this.clipboard = {};\r\n\r\n        this.clipboard.value = {\r\n            type: track.type,\r\n            values: values\r\n        };\r\n    }\r\n\r\n    // each track will have its own entry of copied keyframes. When pasting, only the apropiate track's keyframes are pasted\r\n    copyKeyFrames( track: any, indices: number[] ) {\r\n\r\n        let trackIdx = track.trackIdx;\r\n        if(!this.clipboard)\r\n            this.clipboard = {};\r\n\r\n        indices.sort( (a,b) => a < b ? -1 : 1 ); // just in case\r\n\r\n        let obj: any = { track: track, values: [], times:[] };\r\n\r\n        for(let i = 0; i < indices.length; i++ ){\r\n            let keyIdx = indices[ i ];\r\n            let start = keyIdx * track.dim;\r\n            let keyValues = track.values.slice(start, start + track.dim); // copy values into a new array\r\n            obj.values.push(keyValues); // save to clipboard\r\n            obj.times.push(track.times[keyIdx]); // save to clipboard\r\n        };\r\n\r\n        this.clipboard.keyframes[ trackIdx ] = obj;\r\n    }\r\n\r\n    canPasteKeyFrame () {\r\n        return this.clipboard != null;\r\n    }\r\n\r\n    // raw paste of values\r\n    #paste( track: any, index: number, values: number[] ) {\r\n        const start = index * track.dim;\r\n        let j = 0;\r\n        for(let i = start; i < start + track.dim; ++i) {\r\n            track.values[ i ] = values[ j ];\r\n            ++j;\r\n        }\r\n\r\n        track.edited[ index ] = true;\r\n    }\r\n\r\n    // paste value on selected content (only one keyframe can be selected)\r\n    pasteContentValue(){\r\n        if(!this.clipboard)\r\n        return false;\r\n\r\n        // copy the value into the only selected keyframe\r\n        if(this.clipboard.value && this.lastKeyFramesSelected.length == 1) {\r\n\r\n            let [trackIdx, keyIdx] = this.lastKeyFramesSelected[ 0 ];\r\n            this.pasteKeyFrameValue(this.animationClip.tracks[ trackIdx ], keyIdx);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // paste copied keyframes. New keyframes are created and overlapping ones are overwritten\r\n    pasteContent( time = this.currentTime ) {\r\n        if(!this.clipboard)\r\n            return false;\r\n\r\n        // create new keyframes from the ones copied\r\n        if(this.clipboard.keyframes) {\r\n\r\n            for( let trackIdx in this.clipboard.keyframes ){\r\n                const clipboardItem = this.animationClip.tracks[ trackIdx ];\r\n\r\n                // ensure all tracks are visible\r\n                const idx = this.selectedItems.findIndex( (item) =>\r\n                    {\r\n                        if( item.isTrack ){ return ( item === clipboardItem ) }\r\n                        return item === clipboardItem.groupId;\r\n                    } );\r\n\r\n                if( idx == -1 ){\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            this.pasteKeyFrames( time );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    pasteKeyFrameValue( track: any, index: number ) {\r\n\r\n        if(track.locked || this.clipboard.value.type != track.type){\r\n            return;\r\n        }\r\n\r\n        this.saveState(track.trackIdx);\r\n\r\n        // Copy to current key\r\n        this.#paste( track, index, this.clipboard.value.values );\r\n\r\n        if(this.onUpdateTrack){\r\n            this.onUpdateTrack( [track.trackIdx] );\r\n        }\r\n    }\r\n\r\n    pasteKeyFrames( pasteTime: number = this.currentTime ){\r\n        if( !this.clipboard.keyframes ){ return false; }\r\n\r\n        this.unHoverAll();\r\n        this.deselectAllKeyFrames();\r\n\r\n        let clipboardTracks = this.clipboard.keyframes;\r\n        let globalStart = Infinity;\r\n        for( let trackIdx in clipboardTracks ){\r\n            if( globalStart > clipboardTracks[ trackIdx ].times[ 0 ] ){\r\n                globalStart = clipboardTracks[ trackIdx ].times[ 0 ];\r\n            }\r\n        }\r\n\r\n        if( globalStart == Infinity ){ return false; }\r\n\r\n        // disable callback. It will be done once at the end\r\n        const onUpdateTrack = this.onUpdateTrack;\r\n        this.onUpdateTrack = null;\r\n\r\n\r\n        // disable history. It will be done with all changes combined into a single entry\r\n        const oldSaveEnabler = this.historySaveEnabler;\r\n        let trackCount: number = 0; // to detect when to create an entry or\r\n        for( let trackIdx in clipboardTracks ){\r\n\r\n            const clipboardInfo = this.clipboard.keyframes[ trackIdx ];\r\n            const times = clipboardInfo.times;\r\n            const values = clipboardInfo.values;\r\n            const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n            if( track.locked ){\r\n                continue;\r\n            }\r\n\r\n            this.saveState(track.trackIdx, Boolean(trackCount++) );\r\n            this.historySaveEnabler = false;\r\n            this.addKeyFrames( track.trackIdx, values, times, -globalStart + pasteTime, KeyFramesTimeline.ADDKEY_VALUESINARRAYS  );\r\n            this.historySaveEnabler = oldSaveEnabler;\r\n        }\r\n\r\n        // do only one update\r\n        if(onUpdateTrack){\r\n            this.onUpdateTrack = onUpdateTrack;\r\n\r\n            this.onUpdateTrack( Object.keys( clipboardTracks ) );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Int} trackIdx\r\n     * @param {Array} newValues array of values for each keyframe. It should be a flat array of size track.dim*numKeyframes. Check ADDKEY_VALUESINARRAYS flag\r\n     * @param {Array of numbers} newTimes must be ordered ascendently\r\n     * @param {Number} timeOffset\r\n     * @param {Int} flags\r\n     *      KeyFramesTimeline.ADDKEY_VALUESINARRAYS: if set, newValues is an array of arrays, one for each entry [ [1,2,3], [5,6,7] ]. Times is still a flat array of values [ 0, 0.2 ]\r\n\r\n     * @returns\r\n     */\r\n    addKeyFrames( trackIdx: number, newValues: any[], newTimes: number[], timeOffset: number = 0, flags: number = 0x00 ){\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n        if( !newTimes.length || track.locked ){ return null; }\r\n\r\n        const valueDim = track.dim;\r\n        const trackTimes = track.times;\r\n        const trackValues = track.values;\r\n        const times = new Float32Array( trackTimes.length + newTimes.length );\r\n        const values = new Float32Array( trackValues.length + newTimes.length * valueDim );\r\n\r\n        // let newIdx = this.getNearestKeyFrame( track, newTimes[newTimes.length-1], -1 );\r\n        this.saveState(trackIdx);\r\n\r\n        let newIdx = newTimes.length-1;\r\n        let oldIdx = trackTimes.length-1;\r\n        let resultIndices: number[] = [];\r\n        if( KeyFramesTimeline.ADDKEY_VALUESINARRAYS & flags ){\r\n\r\n            for( let i: number = times.length-1; i > -1; --i ){\r\n                // copy new value in this place if needed\r\n                if( oldIdx<0 || (newIdx>-1 && trackTimes[oldIdx] < (newTimes[newIdx]+timeOffset)) ){\r\n                    const vals : any = newValues[newIdx];\r\n                    for( let v = 0; v < valueDim; ++v ){\r\n                        values[i * valueDim + v] = vals[ v ];\r\n                    }\r\n                    times[ i ] = newTimes[newIdx--]+timeOffset;\r\n                    // Add new entry into each control array\r\n                    track.hovered.splice(oldIdx+1, 0, false);\r\n                    track.selected.splice(oldIdx+1, 0, false);\r\n                    track.edited.splice(oldIdx+1, 0, true);\r\n\r\n                    resultIndices.push(i);\r\n                    continue;\r\n                }\r\n\r\n                // copy old values instead\r\n                for( let v = 0; v < valueDim; ++v ){\r\n                    values[i * valueDim + v] = trackValues[oldIdx * valueDim + v];\r\n                }\r\n                times[ i ] = trackTimes[oldIdx--];\r\n            }\r\n        }\r\n        else{\r\n            for( let i = times.length-1; i > -1; --i ){\r\n                // copy new value in this place if needed\r\n                if( oldIdx<0 || (newIdx>-1 && trackTimes[oldIdx] < (newTimes[newIdx]+timeOffset)) ){\r\n                    // ----------- this is different from the 'if' -----------\r\n                    for( let v = 0; v < valueDim; ++v ){\r\n                        values[i * valueDim + v] = newValues[newIdx * valueDim + v];\r\n                    }\r\n                    times[ i ] = newTimes[newIdx--] + timeOffset;\r\n                    // Add new entry into each control array\r\n                    track.hovered.splice(oldIdx+1, 0, false);\r\n                    track.selected.splice(oldIdx+1, 0, false);\r\n                    track.edited.splice(oldIdx+1, 0, true);\r\n\r\n                    resultIndices.push(i);\r\n                    continue;\r\n                }\r\n\r\n                // copy old values instead\r\n                for( let v = 0; v < valueDim; ++v ){\r\n                    values[i * valueDim + v] = trackValues[oldIdx * valueDim + v];\r\n                }\r\n                times[ i ] = trackTimes[oldIdx--];\r\n            }\r\n\r\n        }\r\n\r\n        // update track pointers\r\n        track.times = times;\r\n        track.values = values;\r\n\r\n        if( (newTimes[newTimes.length - 1] + timeOffset) > this.duration ){\r\n            this.setDuration(newTimes[newTimes.length - 1] + timeOffset);\r\n        }\r\n\r\n        if(this.onUpdateTrack){\r\n            this.onUpdateTrack( [ trackIdx ] );\r\n        }\r\n\r\n        return resultIndices;\r\n    }\r\n\r\n    deleteSelectedContent(skipCallback = false) {\r\n\r\n        //*********** WARNING: RELIES ON SORTED lastKeyFramesSelected ***********\r\n\r\n        if(!this.lastKeyFramesSelected.length){\r\n            return;\r\n        }\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        const firstTrack = this.lastKeyFramesSelected[ 0 ][ 0 ];\r\n        let trackToRemove = firstTrack;\r\n        let toDelete: number[] = []; // indices to delete of the same track\r\n\r\n        const oldSaveEnabler = this.historySaveEnabler;\r\n\r\n        const numSelected = this.lastKeyFramesSelected.length;\r\n        for( let i = 0; i < numSelected; ++i ){\r\n            const [trackIdx, frameIdx] = this.lastKeyFramesSelected[ i ];\r\n\r\n            if( tracks[ trackIdx ].locked ){\r\n                tracks[ trackIdx ].selected[frameIdx] = false; // unselect\r\n                continue;\r\n            }\r\n\r\n            if( trackToRemove != trackIdx ){\r\n                this.saveState(trackToRemove, trackToRemove != firstTrack);\r\n\r\n                this.historySaveEnabler = false;\r\n                this.deleteKeyFrames( trackToRemove, toDelete, skipCallback );\r\n                this.historySaveEnabler = oldSaveEnabler;\r\n\r\n                trackToRemove = trackIdx;\r\n                toDelete.length = 0;\r\n            }\r\n\r\n            toDelete.push( frameIdx );\r\n        }\r\n\r\n        this.saveState(trackToRemove, trackToRemove != firstTrack);\r\n        this.historySaveEnabler = false;\r\n        this.deleteKeyFrames( trackToRemove, toDelete, skipCallback );\r\n        this.historySaveEnabler = oldSaveEnabler;\r\n\r\n        this.lastKeyFramesSelected = [];\r\n    }\r\n\r\n    // for typed arrays. Does not update lastSelectedKeyframes\r\n    deleteKeyFrames( trackIdx: number, indices: number[], skipCallback: boolean = false ){\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n        if( !indices.length || track.locked ){\r\n            return false;\r\n        }\r\n\r\n        this.saveState( trackIdx );\r\n\r\n        const oldNumFrames = track.times.length;\r\n        const newNumFrames = track.times.length - indices.length;\r\n        const newTimes = track.times.slice(0, newNumFrames);\r\n        const newValues = track.values.slice(0, newNumFrames * track.dim);\r\n\r\n        let resultIdx = indices[ 0 ];\r\n        let resultValIdx = indices[ 0 ] * track.dim;\r\n        for(let i = 0; i < indices.length; ++i){\r\n            track.edited.splice(resultIdx, 1);\r\n            track.selected.splice(resultIdx, 1);\r\n            track.hovered.splice(resultIdx, 1);\r\n\r\n            const idx = indices[ i ];\r\n            const endIdx = (i < (indices.length-1)) ? indices[i+1] : oldNumFrames;\r\n            const endValIdx = endIdx * track.dim;\r\n            for(let v = (idx+1)*track.dim; v < endValIdx; ++v ){\r\n                newValues[resultValIdx++] = track.values[ v ];\r\n            }\r\n            for( let f = idx+1; f < endIdx; ++f){\r\n                newTimes[resultIdx++] = track.times[f];\r\n            }\r\n        }\r\n\r\n        track.times = newTimes;\r\n        track.values = newValues;\r\n\r\n        // Update animation action interpolation info\r\n        if(this.onDeleteKeyFrames && !skipCallback)\r\n            this.onDeleteKeyFrames( trackIdx, indices );\r\n\r\n\r\n        if( (newTimes[newTimes.length - 1]) > this.duration ){\r\n            this.setDuration(newTimes[newTimes.length - 1]);\r\n        }\r\n\r\n        // if(this.onUpdateTrack)\r\n        //     this.onUpdateTrack( [ trackIdx ] );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binary search. Relies on track.times being a sorted array\r\n     * @param {Object} track\r\n     * @param {Number} time\r\n     * @param {Number} mode on of the possible values\r\n     *  - -1 = nearest frame with t[f] <= time\r\n     *  - 0 = nearest frame\r\n     *  - 1 = nearest frame with t[f] >= time\r\n     * @returns a zero/positive value if successful. On failure returnes -1 meaning either there are no frames ( 0 ), no frame-time is lower (-1) or no frame-time is higher (1)\r\n     */\r\n    getNearestKeyFrame( track: any, time: number, mode: number = 0 ) {\r\n\r\n        if(!track || !track.times || !track.times.length)\r\n            return -1;\r\n\r\n        //binary search\r\n        const times = track.times;\r\n        let min = 0, max = times.length - 1;\r\n\r\n        // edge cases\r\n        if( times[min] > time ){\r\n            return mode == -1 ? -1 : 0;\r\n        }\r\n        if( times[max] < time ){\r\n            return mode == 1 ? -1 : max;\r\n        }\r\n\r\n        // time is between first and last frame\r\n        let half = Math.floor( ( min + max ) / 2 );\r\n        while ( min < half && half < max ){\r\n            if( time < times[half] ){ max = half; }\r\n            else{ min = half; }\r\n            half = Math.floor( ( min + max ) / 2 );\r\n        }\r\n\r\n        if(mode == 0 ){\r\n            return Math.abs( time - times[min] ) < Math.abs( time - times[max] ) ? min : max;\r\n        }\r\n        else if( mode == -1 ){\r\n            return times[max] == time ? max : min;\r\n        }\r\n        return times[min] == time ? min : max;\r\n    }\r\n\r\n    /**\r\n     * get the nearest keyframe to \"time\" given a maximum threshold.\r\n     * @param {Object} track\r\n     * @param {Number} time\r\n     * @param {Number} threshold must be positive value\r\n     * @returns returns a postive/zero value if there is a frame inside the threshold range. Otherwise, -1\r\n     */\r\n    getCurrentKeyFrame( track: any, time: number, threshold: number = 0.0 ) {\r\n\r\n        if(!track || !track.times.length)\r\n            return -1;\r\n\r\n        let frame = this.getNearestKeyFrame( track, time );\r\n        if( frame > -1 ){\r\n            frame = Math.abs(track.times[frame] - time) > threshold ? -1 : frame;\r\n        }\r\n\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Returns the interval of frames between minTime and maxTime (both included)\r\n     * @param {Object} track\r\n     * @param {Number} minTime\r\n     * @param {Number} maxTime\r\n     * @param {Number} threshold must be positive value\r\n     * @returns an array with two values [ minFrame, maxFrame ]. Otherwise null\r\n     */\r\n    getKeyFramesInRange( track: any, minTime: number, maxTime: number, threshold: number = 0.0 ) {\r\n\r\n        if(!track || !track.times.length)\r\n            return null;\r\n\r\n        // Manage negative selection\r\n        if(minTime > maxTime) {\r\n            let aux = minTime;\r\n            minTime = maxTime;\r\n            maxTime = aux;\r\n        }\r\n\r\n        const minFrame = this.getNearestKeyFrame( track, minTime - threshold, 1 );\r\n        const maxFrame = this.getNearestKeyFrame( track, maxTime + threshold, -1 );\r\n\r\n        if( maxFrame == -1 || minFrame == -1 ){ return null; }\r\n\r\n        return [minFrame, maxFrame];\r\n    }\r\n\r\n    unHoverAll(){\r\n        if(this.lastHovered) {\r\n            this.animationClip.tracks[ this.lastHovered[ 0 ] ].hovered[ this.lastHovered[ 1 ] ] = false;\r\n        }\r\n        let h = this.lastHovered;\r\n        this.lastHovered = null;\r\n        return h;\r\n    }\r\n\r\n    deselectAllKeyFrames() {\r\n\r\n        for(let [trackIdx, keyIndex] of this.lastKeyFramesSelected) {\r\n            this.animationClip.tracks[ trackIdx ].selected[ keyIndex ] = false;\r\n        }\r\n\r\n        // Something has been deselected\r\n        const deselected = this.lastKeyFramesSelected.length > 0;\r\n        this.lastKeyFramesSelected.length = 0;\r\n        return deselected;\r\n    }\r\n\r\n    isKeyFrameSelected( track: any, index: number ) {\r\n        return track.selected[ index ];\r\n    }\r\n\r\n    /**\r\n     * @param {Int} trackIdx track index of animation clip\r\n     * @param {Int} frameIdx frame (index) to select inside the track\r\n     * @param {Boolean} skipCallback\r\n     * @returns\r\n     */\r\n    selectKeyFrame( trackIdx: number, frameIdx: number, skipCallback: boolean = false ) {\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        if( track.locked || !track.active || track.selected[frameIdx] )\r\n            return null;\r\n\r\n        // [track idx, keyframe, keyframe time]\r\n        const selection = [track.trackIdx, frameIdx, track.times[frameIdx]];\r\n\r\n        // sort lastkeyframeselected ascending order (track and frame)\r\n        let i = 0;\r\n        for( ; i < this.lastKeyFramesSelected.length; ++i){\r\n            let s = this.lastKeyFramesSelected[ i ];\r\n            if(s[ 0 ] > trackIdx || (s[ 0 ] == trackIdx && s[ 1 ] > frameIdx)){\r\n                break;\r\n            }\r\n        }\r\n        this.lastKeyFramesSelected.splice( i, 0, selection );\r\n        track.selected[frameIdx] = true;\r\n\r\n        if( this.onSelectKeyFrame && !skipCallback){\r\n            this.onSelectKeyFrame(selection);\r\n        }\r\n\r\n        return selection;\r\n    }\r\n\r\n    deselectKeyFrame( trackIdx: number, frameIdx: number ){\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        if( track.locked || !track.active || !track.selected[frameIdx] )\r\n            return false;\r\n\r\n        track.selected[frameIdx] = false;\r\n\r\n        for( let i = 0; i < this.lastKeyFramesSelected.length; ++i ){\r\n            const sk = this.lastKeyFramesSelected[ i ];\r\n            if( sk[ 0 ] === trackIdx && sk[ 1 ] === frameIdx ){\r\n                this.lastKeyFramesSelected.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    getNumKeyFramesSelected() {\r\n        return this.lastKeyFramesSelected.length;\r\n    }\r\n\r\n    /**\r\n     * helper function to process a selection with multiple keyframes. Sets the time of the timeline to the first selected keyframe\r\n     * @param {Number} trackIdx\r\n     * @param {Number} keyFrameIndex\r\n     * @param {Boolean} multipleSelection whether to append to selection or reset it and make this keyframe the only current selection\r\n     * @returns\r\n     */\r\n    processSelectionKeyFrame( trackIdx: number, keyFrameIndex: number, multipleSelection: boolean = false ) {\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        if(track.locked)\r\n            return;\r\n\r\n        if(!multipleSelection) {\r\n            this.deselectAllKeyFrames();\r\n        }\r\n\r\n        this.selectKeyFrame(trackIdx, keyFrameIndex);\r\n\r\n        if( !multipleSelection ) {\r\n            this.setTime(track.times[ keyFrameIndex ]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method clearTrack\r\n     */\r\n    clearTrack( trackIdx: number ) {\r\n\r\n        const track =  this.animationClip.tracks[ trackIdx ];\r\n\r\n        this.unHoverAll();\r\n        this.deselectAllKeyFrames();\r\n\r\n        if( track.locked ){\r\n            return;\r\n        }\r\n\r\n        this.saveState(track.trackIdx);\r\n\r\n        track.times = track.times.slice(0,0);\r\n        track.values = track.values.slice(0,0);\r\n        track.edited.length = 0;\r\n        track.hovered.length = 0;\r\n        track.selected.length = 0;\r\n\r\n        return trackIdx;\r\n    }\r\n}\r\n\r\nLX.KeyFramesTimeline = KeyFramesTimeline;\r\n/**\r\n * @class ClipsTimeline\r\n */\r\n\r\nexport class ClipsTimeline extends Timeline\r\n{\r\n    static CLONEREASON_COPY = 1;\r\n    static CLONEREASON_PASTE = 2;\r\n    static CLONEREASON_HISTORY = 3;\r\n    static CLONEREASON_TRACKCLONE = 4;\r\n\r\n    lastClipsSelected: any = [];\r\n    lastTrackClipsMove: number = 0; // vertical movement of clips, onMouseMove onMousedown\r\n    dragClipMode: Nullable< string > = \"\";\r\n    lastHovered: Nullable< [number, number] > = null;\r\n\r\n    onSelectClip: Nullable< (clip: Nullable<any>) => void > = null;\r\n    onContentMoved: Nullable< (clip: Nullable<any>, delta: number ) => void > = null;\r\n    onDeleteSelectedClips: Nullable< (selected: any[] ) => void > = null;\r\n    onDeleteClip: Nullable< (trackIdx: number, clipIdx: number, clip: any ) => void > = null;\r\n\r\n    /**\r\n     * @param {String} name\r\n     * @param {Object} options = {animationClip, selectedItems, x, y, width, height, canvas, trackHeight}\r\n     */\r\n    constructor(name: string, options: any = {})\r\n    {\r\n        super( name, options );\r\n\r\n        this.lastClipsSelected = [];\r\n        this.lastTrackClipsMove = 0; // vertical movement of clips, onMouseMove onMousedown\r\n        this.dragClipMode = \"\";\r\n\r\n        this.setAnimationClip(this.animationClip);\r\n\r\n        this.onDblClick = ( e: any ) => {\r\n            const track = e.track;\r\n            const localX = e.localX;\r\n\r\n            if( track ){\r\n                const clipIdx = this.getClipOnTime(track, this.xToTime(localX), 0.001);\r\n                this.selectClip(track.trackIdx, clipIdx); // deselect and try to select clip in localX, if any\r\n            }\r\n        }\r\n\r\n        this.onShowContextMenu = ( e: any ) => {\r\n\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n\r\n            let actions: any[] = [];\r\n            if( this.lastClipsSelected.length )\r\n            {\r\n                actions.push(\r\n                    {\r\n                        title: \"Copy\",\r\n                        callback: () => { this.copySelectedContent();}\r\n                    }\r\n                )\r\n                actions.push(\r\n                    {\r\n                        title: \"Delete\",\r\n                        callback: () => {\r\n                            this.deleteSelectedContent();\r\n                        }\r\n                    }\r\n                )\r\n            }\r\n            else{\r\n\r\n                if(this.clipboard)\r\n                {\r\n                    actions.push(\r\n                        {\r\n                            title: \"Paste\",\r\n                            callback: () => {\r\n                                this.pasteContent();\r\n                            }\r\n                        }\r\n                    );\r\n                    actions.push(\r\n                        {\r\n                            title: \"Paste Here\",\r\n                            callback: () => {\r\n                                this.pasteContent( this.xToTime(e.localX) );\r\n                            }\r\n                        }\r\n                    )\r\n                }\r\n            }\r\n\r\n            LX.addContextMenu(\"Options\", e, ( m: any ) => {\r\n                for(let i = 0; i < actions.length; i++) {\r\n                    m.add(actions[ i ].title,  actions[ i ].callback )\r\n                }\r\n            });\r\n\r\n        } // end of onShowContextMenu\r\n\r\n    }\r\n\r\n    /**\r\n     * Generates an animationClip using either the parameters set in the animation argument or using default values\r\n     * @param {Object} animation data with which to generate an animationClip\r\n     * @returns\r\n     */\r\n    instantiateAnimationClip(animation: any, clone: boolean = false) {\r\n\r\n        const animationClip = super.instantiateAnimationClip(animation);\r\n\r\n        if(animation && animation.tracks){\r\n            for( let i = 0; i < animation.tracks.length; ++i ) {\r\n\r\n                const trackInfo: any = this.instantiateTrack( animation.tracks[ i ], clone );\r\n                trackInfo.trackIdx = animationClip.tracks.length;\r\n\r\n                animationClip.tracks.push(trackInfo);\r\n            }\r\n        }\r\n\r\n        return animationClip;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Object} options set some values for the track instance (groups and trackIdx not included)\r\n     * @returns\r\n    */\r\n    instantiateTrack(options: any = {}, clone: boolean = false) {\r\n        const track: any = super.instantiateTrack(options);\r\n\r\n        track.trackIdx = this.animationClip.tracks.length;\r\n\r\n        track.selected = [];\r\n        track.edited = [];\r\n        track.hovered = [];\r\n\r\n        if( options.clips ){\r\n            track.clips = clone ? this.cloneClips(options.clips, 0, ClipsTimeline.CLONEREASON_TRACKCLONE) : options.clips;\r\n        }else{\r\n            track.clips = [];\r\n        }\r\n\r\n        const numClips = track.clips.length;\r\n\r\n        if( options.selected && options.selected.length == numClips ){\r\n            track.selected = clone ? options.selected.slice() : options.selected;\r\n        }else{\r\n            track.selected = (new Array(numClips)).fill( false );\r\n        }\r\n        if( options.edited && options.edited.length == numClips ){\r\n            track.edited = clone ? options.edited.slice() : options.edited;\r\n        }else{\r\n            track.edited = (new Array(numClips)).fill( false );\r\n        }\r\n        if( options.hovered && options.hovered.length == numClips ){\r\n            track.hovered = clone ? options.hovered.slice() : options.hovered;\r\n        }else{\r\n            track.hovered = (new Array(numClips)).fill( false );\r\n        }\r\n\r\n        // sanity check. Also done in addClip\r\n        for( let i = 0; i < track.clips.length; ++i ){\r\n            track.clips[ i ].active = track.clips[ i ].active ?? true;\r\n        }\r\n        return track;\r\n    }\r\n\r\n    // provides an base example of a proper clip\r\n    instantiateClip(options: any = {}){\r\n        return {\r\n            id: options.id ?? (options.name ?? \"clip\"),\r\n\r\n            start: options.start ?? 0,\r\n            duration: options.duration ?? 1,\r\n            fadein: options.fadein ?? undefined,\r\n            fadeout: options.fadeout ?? undefined,\r\n\r\n            clipColor: options.clipColor ?? LX.getThemeColor(\"global-color-accent\"),\r\n            fadeColor: options.fadeColor ?? null,\r\n            active: options.active ?? true,\r\n            trackIdx: -1, // filled by addClip\r\n        }\r\n\r\n    }\r\n    // use default updateleftpanel\r\n    // generateSelectedItemsTreeData(){}\r\n\r\n    addNewTrack( options: any = {}, updateLeftPanel: boolean = true, skipCallback: boolean = false ) {\r\n\r\n        const trackInfo = this.instantiateTrack(options ?? {});\r\n        trackInfo.trackIdx = this.animationClip.tracks.length;\r\n        this.animationClip.tracks.push( trackInfo );\r\n\r\n        if( this.onAddNewTrack && !skipCallback ){\r\n            this.onAddNewTrack( trackInfo, options );\r\n        }\r\n\r\n        this.selectedItems.push(trackInfo);\r\n        if( updateLeftPanel ){\r\n            this.updateLeftPanel();\r\n        }\r\n\r\n        return trackInfo.trackIdx;\r\n    }\r\n\r\n    // OVERRIDE ITEM SELECTION - ClipsTimeline will not offer any selection. Alltracks are visible\r\n    setAnimationClip( animation: any, needsToProcess: boolean = true  ){\r\n        super.setAnimationClip(animation, needsToProcess);\r\n        this.changeSelectedItems();\r\n        return this.animationClip;\r\n    }\r\n\r\n    // OVERRIDE\r\n    deselectAllElements(){\r\n        this.deselectAllClips();\r\n        this.unHoverAll();\r\n    }\r\n\r\n    /**\r\n     * OVERRIDE ITEM SELECTION.\r\n     * CLIPS WILL OFFER NO SELECTION. All tracks are visible\r\n     */\r\n    changeSelectedItems()\r\n    {\r\n        this.deselectAllElements();\r\n        this.deselectAllTracks( false ); // no need to update left\r\n\r\n        this.selectedItems = this.animationClip.tracks.slice();\r\n\r\n        this.updateLeftPanel();\r\n    }\r\n\r\n    unHoverAll()\r\n    {\r\n        if( this.lastHovered )\r\n        {\r\n            this.animationClip.tracks[ this.lastHovered[ 0 ] ].hovered[ this.lastHovered[ 1 ] ] = false;\r\n        }\r\n\r\n        let h = this.lastHovered;\r\n        this.lastHovered = null;\r\n        return h;\r\n    }\r\n\r\n    onMouseUp( e: any )\r\n    {\r\n        let track = e.track;\r\n        let localX = e.localX;\r\n        let discard = e.discard; // true when too much time has passed between Down and Up\r\n\r\n        if(e.shiftKey) {\r\n\r\n            // Manual Multiple selection\r\n            if(!discard) {\r\n                if( track ){\r\n                    let clipIndex = this.getClipOnTime( track, this.xToTime( localX ), this.secondsPerPixel * 5 );\r\n                    if( clipIndex > -1 ){\r\n                        track.selected[clipIndex] ?\r\n                            this.deselectClip( track.trackIdx, clipIndex ) :\r\n                            this.selectClip( track.trackIdx, clipIndex, false );\r\n                    }\r\n                }\r\n            }\r\n            // Box selection\r\n            else if(this.boxSelection){\r\n\r\n                let tracks = this.getTracksInRange(this.boxSelectionStart[ 1 ], this.boxSelectionEnd[ 1 ]);\r\n\r\n                for(let t of tracks) {\r\n                    let clipsIndices = this.getClipsInRange(t,\r\n                        this.xToTime( this.boxSelectionStart[ 0 ] ),\r\n                        this.xToTime( this.boxSelectionEnd[ 0 ] ),\r\n                        0.000001);\r\n\r\n                    if(clipsIndices) {\r\n                        for(let index of clipsIndices)\r\n                            this.selectClip( t.trackIdx, index, false );\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        else {\r\n\r\n            let boundingBox = this.canvas.getBoundingClientRect()\r\n            if(e.y < boundingBox.top || e.y > boundingBox.bottom)\r\n                return;\r\n\r\n            // Check exact track clip\r\n            if(!discard && track) {\r\n                if(e.button!=2){\r\n                    const clipIdx = this.getClipOnTime(track, this.xToTime(localX), 0.001);\r\n                    this.selectClip( track.trackIdx, clipIdx );\r\n                }\r\n            }\r\n\r\n        }\r\n        this.movingKeys = false;\r\n    }\r\n\r\n    onMouseDown( e: any, time: number ) {\r\n        // function not called if shift is pressed (boxselection)\r\n        let localX = e.localX;\r\n        let localY = e.localY;\r\n        let track = e.track;\r\n\r\n        if( e.button > 0 ){\r\n            return;\r\n        }\r\n\r\n        if(e.ctrlKey && track) { // move clips\r\n\r\n            let x = e.offsetX;\r\n            // clip selection is done on MouseUP\r\n            const selectedClips = this.lastClipsSelected;\r\n\r\n            this.canvas.style.cursor = \"grab\";\r\n            let curTrackIdx = -1;\r\n\r\n            this.lastTrackClipsMove = Math.floor( (e.localY - this.topMargin + this.trackTreesPanel.root.scrollTop) / this.trackHeight );\r\n\r\n            for(let i = 0; i < selectedClips.length; i++)\r\n            {\r\n                let [trackIndex, clipIndex] = selectedClips[ i ];\r\n                const clip = this.animationClip.tracks[trackIndex].clips[clipIndex];\r\n\r\n                let endingX = this.timeToX( clip.start + clip.duration );\r\n\r\n                if(Math.abs( endingX - x ) < 5 ) {\r\n                    this.dragClipMode = \"duration\";\r\n                    this.canvas.style.cursor = \"column-resize\";\r\n                }\r\n                else {\r\n                    this.dragClipMode = \"move\";\r\n                }\r\n\r\n                //*********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n                if(curTrackIdx != trackIndex){\r\n                    this.saveState(trackIndex, curTrackIdx != -1 );\r\n                    curTrackIdx = trackIndex;\r\n                }\r\n            }\r\n\r\n            this.movingKeys = true;\r\n        }\r\n        else if( !track || track && this.getClipOnTime(track, time, 0.001) == -1) { // clicked on empty space\r\n            if( this.lastClipsSelected.length ){\r\n                this.deselectAllClips();\r\n                if(this.onSelectClip){\r\n                    this.onSelectClip(null);\r\n                }\r\n            }\r\n        }\r\n        else if(track && (this.dragClipMode == \"duration\" || this.dragClipMode == \"fadein\" || this.dragClipMode == \"fadeout\" )) { // clicked while mouse was over fadeIn, fadeOut, duration\r\n            const clipIdx = this.getClipOnTime(track, this.xToTime(localX), 0.001);\r\n            this.selectClip( track.trackIdx, clipIdx ); // select current clip if any (deselect others)\r\n            if( this.lastClipsSelected.length ){\r\n                this.saveState(track.trackIdx);\r\n            }\r\n            this.movingKeys = true;\r\n        }\r\n    }\r\n\r\n    onMouseMove( e: any, time: number ) {\r\n        // function not called if shift is pressed (boxselection)\r\n\r\n        if( this.grabbingTimeBar || this.grabbingScroll ){\r\n            return;\r\n        }\r\n        else if(this.grabbing && e.buttons != 2) {\r\n            this.unHoverAll();\r\n\r\n            let delta = time - this.grabTime;\r\n            this.grabTime = time;\r\n            if( time < 0 && delta > 0 ){ delta = 0; }\r\n\r\n            if( this.dragClipMode != \"move\" && this.lastClipsSelected.length == 1 ){ // change fade and duration of clips\r\n\r\n                const track = this.animationClip.tracks[this.lastClipsSelected[ 0 ][ 0 ]];\r\n                let clip = track.clips[this.lastClipsSelected[ 0 ][ 1 ]];\r\n                if( this.dragClipMode == \"fadein\" ) {\r\n                    clip.fadein = Math.min(Math.max(clip.fadein + delta, clip.start), clip.fadeout ?? (clip.start+clip.duration) );\r\n                }\r\n                else if( this.dragClipMode == \"fadeout\" ) {\r\n                    clip.fadeout = Math.max(Math.min(clip.fadeout + delta, clip.start+clip.duration), clip.fadein ?? clip.start );\r\n                }\r\n                else if( this.dragClipMode == \"duration\" ) {\r\n                    let duration = Math.max(0, clip.duration + delta);\r\n                    if( this.lastClipsSelected[ 0 ][ 1 ] < track.clips.length-1 ){ // max next clip's start\r\n                        duration = Math.min( track.clips[this.lastClipsSelected[ 0 ][ 1 ] + 1].start - clip.start - 0.0001, duration );\r\n                    }\r\n                    clip.duration = duration;\r\n                    if( clip.fadeout != undefined ){\r\n                        clip.fadeout = Math.max(Math.min((clip.fadeout ?? (clip.start+clip.duration)) + delta, clip.start+clip.duration), clip.start);\r\n                    }\r\n                    if( clip.fadein != undefined ){\r\n                        clip.fadein = Math.max(Math.min((clip.fadein ?? (clip.start+clip.duration)), (clip.fadeout ?? (clip.start+clip.duration))), clip.start);\r\n                    }\r\n                    if(this.duration < clip.start + clip.duration){\r\n                        this.setDuration(clip.start + clip.duration);\r\n                    }\r\n                }\r\n                if(this.onContentMoved) { // content changed\r\n                    this.onContentMoved(clip, 0);\r\n                }\r\n            }\r\n            else if( this.dragClipMode == \"move\" && this.lastClipsSelected.length ) { // move clips\r\n                //*********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n\r\n                const treeOffset = this.lastTrackTreesComponentOffset;\r\n                let newTrackClipsMove = Math.floor( (e.localY - treeOffset) / this.trackHeight );\r\n\r\n                // move clips vertically\r\n                if( e.altKey ){\r\n                    let deltaTracks = newTrackClipsMove - this.lastTrackClipsMove;\r\n\r\n                    if( this.lastClipsSelected[ 0 ][ 0 ] + deltaTracks < 0 ){\r\n                        deltaTracks = -this.lastClipsSelected[ 0 ][ 0 ];\r\n                    }\r\n\r\n                    // if no movement of tracks, do not check\r\n                    if( deltaTracks != 0 ){\r\n\r\n                        // check if ALL selected clips can move track\r\n                        for( let i = 0; i < this.lastClipsSelected.length; ++i ){\r\n                            const track = this.animationClip.tracks[ this.lastClipsSelected[ i ][ 0 ] ];\r\n                            const newTrack = this.animationClip.tracks[ this.lastClipsSelected[ i ][ 0 ] + deltaTracks ];\r\n                            const clip = track.clips[ this.lastClipsSelected[ i ][ 1 ] ];\r\n\r\n                            const clipsInRange = this.getClipsInRange(newTrack, clip.start, clip.start+clip.duration, 0.0001)\r\n                            if( clipsInRange ){\r\n                                for( let c = 0; c < clipsInRange.length; ++c ){\r\n                                    if( !newTrack.selected[clipsInRange[c]] ){\r\n                                        // at least one clip cannot move, abort\r\n                                        c = clipsInRange.length;\r\n                                        i = this.lastClipsSelected.length;\r\n                                        deltaTracks = 0;\r\n                                        newTrackClipsMove = this.lastTrackClipsMove;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // if movement was not canceled\r\n                        if( deltaTracks != 0 ){\r\n                            let oldStateEnabler = this.historySaveEnabler;\r\n                            this.historySaveEnabler = false;\r\n\r\n                            const selectedClips = this.lastClipsSelected;\r\n                            this.lastClipsSelected = []; // avoid delete and addclips index reassignment loop (not necessary because of order of operations in for)\r\n\r\n                            for( let i = selectedClips[selectedClips.length-1][ 0 ] + deltaTracks - this.animationClip.tracks.length + 1; i > 0; --i ){\r\n                                this.addNewTrack(null, i == 1);\r\n                                if( i == 1 ){\r\n                                    this.updateLeftPanel();\r\n                                }\r\n                            }\r\n\r\n                            // selected clips MUST be ordered (ascendently)\r\n                            let startSel = deltaTracks > 0 ? selectedClips.length - 1 : 0;\r\n                            let endSel = startSel;\r\n                            let currTrack = selectedClips[startSel][ 0 ];\r\n\r\n                            // i <= length; to update last track. Otherwise a check outside of for would be needed\r\n                            for( let i = 1; i <= selectedClips.length; ++i ){\r\n\r\n                                let idx = deltaTracks > 0 ? (selectedClips.length -1 - i) : i;\r\n                                if( i == selectedClips.length || selectedClips[ idx ][ 0 ] != currTrack ){\r\n\r\n                                    const newTrackIdx = currTrack + deltaTracks;\r\n                                    const newTrack = this.animationClip.tracks[ newTrackIdx ];\r\n                                    const track = this.animationClip.tracks[currTrack ];\r\n\r\n                                    // save track state if necessary\r\n                                    const undoState = this.historyUndo[this.historyUndo.length-1];\r\n                                    let state = 0;\r\n                                    for( ; state < undoState.length; ++state ){\r\n                                        if( newTrackIdx == undoState[state].trackIdx ){ break; }\r\n                                    }\r\n                                    if( state == undoState.length ){\r\n                                        this.historySaveEnabler = true;\r\n                                        this.saveState(newTrackIdx, true);\r\n                                        this.historySaveEnabler = false;\r\n                                    }\r\n\r\n                                    // add clips of a track, from first to last\r\n                                    for( let c = startSel; c <= endSel; ++c ){\r\n                                        let newClipIdx = this.addClip(track.clips[ selectedClips[c][ 1 ] ], newTrackIdx, 0);\r\n                                        selectedClips[c][ 0 ] = newClipIdx; // temporarily store new clip index in trackIndex (HACK START)\r\n                                        newTrack.selected[newClipIdx] = true;\r\n                                    }\r\n\r\n                                    // delete clips of a track, from last to first\r\n                                    for( let c = endSel; c >=startSel ; --c ){\r\n                                        this.#delete(currTrack, selectedClips[c][ 1 ]);\r\n                                        selectedClips[c][ 1 ] = selectedClips[c][ 0 ]; // put new clip index (HACK)\r\n                                        selectedClips[c][ 0 ] = newTrackIdx; // put new track index (HACK FIX)\r\n                                    }\r\n\r\n                                    currTrack = i < selectedClips.length ? selectedClips[ idx ][ 0 ] : -1;\r\n                                    startSel = idx;\r\n                                    endSel = idx;\r\n                                    continue;\r\n                                }\r\n\r\n                                deltaTracks > 0 ? startSel = idx : endSel = idx;\r\n                            }\r\n\r\n                            this.lastClipsSelected = selectedClips;\r\n                            this.historySaveEnabler = oldStateEnabler;\r\n                        }\r\n                    }\r\n                }\r\n                this.lastTrackClipsMove = newTrackClipsMove;\r\n\r\n                // move clips horizontally\r\n\r\n                let leastDelta = delta;\r\n                let moveAccepted = true;\r\n\r\n                // find if all clips can move and/or how much they can move\r\n                for( let i = 0; i < this.lastClipsSelected.length; ++i ){\r\n                    let trackIdx = this.lastClipsSelected[ i ][ 0 ];\r\n                    let clipIdx = this.lastClipsSelected[ i ][ 1 ];\r\n                    const track = this.animationClip.tracks[ trackIdx ];\r\n                    const trackClips = track.clips;\r\n                    const clip = track.clips[clipIdx];\r\n\r\n                    if( delta >= 0 ){\r\n                        if( trackClips.length-1 == clipIdx ){ continue; } // all alowed\r\n                        if( !track.selected[clipIdx+1] ){ // if next is selected, force AllOrNothing and let next clip manage the leastDelta\r\n                            if( trackClips[clipIdx + 1].start >= (clip.start+clip.duration+delta) ){ continue; } //has not reached next clip. Enough space. All allowed\r\n                            const nextClip = trackClips[clipIdx + 1];\r\n                            leastDelta = Math.max( 0, Math.min( leastDelta,  nextClip.start - clip.start - clip.duration ) );\r\n                        }\r\n                    }\r\n                    else if( delta < 0 ){\r\n                        if( clipIdx > 0 && (trackClips[clipIdx - 1].start + trackClips[clipIdx - 1].duration) <= (clip.start+delta) ){ continue; } // has not reached previous clip. Enough space\r\n                        if( clipIdx > 0 ){\r\n                            const prevClip = trackClips[clipIdx - 1];\r\n                            leastDelta = Math.min( 0, Math.max( leastDelta,  prevClip.start + prevClip.duration - clip.start ) ); // delta is a negative value, that is why the leastDelta is the max\r\n                        }\r\n                        if( clip.start + delta < 0 ){\r\n                            leastDelta = Math.max(leastDelta, -clip.start);\r\n                            moveAccepted = false; // force it to be a leastDelta move only. No jumps\r\n                        }\r\n                    }\r\n\r\n                    if( !moveAccepted ){ continue; }\r\n                    let clipsInRange = this.getClipsInRange(track, clip.start + delta, clip.start + clip.duration + delta, 0.01);\r\n                    if( clipsInRange && (clipsInRange[ 0 ] != clipIdx || clipsInRange[clipsInRange.length-1] != clipIdx)){\r\n                        for( let c = 0; c < clipsInRange.length; ++c ){\r\n                            if( !track.selected[clipsInRange[c]] ){ moveAccepted = false; break; }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // if moveAccepted -> use full delta\r\n                // if !moveAccepted -> use leastDelta\r\n                if( moveAccepted ){ leastDelta = delta; }\r\n                this.grabTime = time - delta + leastDelta;\r\n\r\n\r\n                //*********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n                // move all selected clips using the computed delta.\r\n                for( let i = 0; i < this.lastClipsSelected.length; ++i ){\r\n                    const lcs = this.lastClipsSelected[ delta > 0 ? (this.lastClipsSelected.length - 1 - i) : i]; //delta > 0, move last-to-first; delta < 0, move first-to-last\r\n                    const track = this.animationClip.tracks[lcs[ 0 ]];\r\n                    const trackClips = track.clips;\r\n                    let clipIdx = lcs[ 1 ];\r\n                    const clip = track.clips[clipIdx];\r\n                    clip.start += leastDelta;\r\n                    if(clip.fadein != undefined ){ clip.fadein += leastDelta; }\r\n                    if(clip.fadeout != undefined ){ clip.fadeout += leastDelta; }\r\n\r\n                    // prepare swap\r\n                    const editedFlag = track.edited[clipIdx];\r\n                    const selectedFlag = track.selected[clipIdx];\r\n                    const hoveredFlag = track.hovered[clipIdx];\r\n\r\n                    // move other clips\r\n                    if( delta > 0 ){\r\n                        while( clipIdx < trackClips.length-1 ){\r\n                            if( trackClips[clipIdx+1].start >= clip.start ){\r\n                                break;\r\n                            }\r\n                            trackClips[clipIdx] = trackClips[clipIdx+1];\r\n                            track.selected[clipIdx] = track.selected[clipIdx+1];\r\n                            track.edited[clipIdx] = track.edited[clipIdx+1];\r\n                            track.hovered[clipIdx] = track.hovered[clipIdx+1];\r\n                            clipIdx++;\r\n                        }\r\n                    }else{\r\n                        while( clipIdx > 0 ){\r\n                            if( trackClips[clipIdx-1].start <= clip.start ){\r\n                                break;\r\n                            }\r\n                            trackClips[clipIdx] = trackClips[clipIdx-1];\r\n                            track.selected[clipIdx] = track.selected[clipIdx-1];\r\n                            track.edited[clipIdx] = track.edited[clipIdx-1];\r\n                            track.hovered[clipIdx] = track.hovered[clipIdx-1];\r\n                            clipIdx--;\r\n                        }\r\n                    }\r\n                    // commit swap\r\n                    trackClips[clipIdx] = clip;\r\n                    track.edited[clipIdx] = editedFlag;\r\n                    track.selected[clipIdx] = selectedFlag;\r\n                    track.hovered[clipIdx] = hoveredFlag;\r\n\r\n                    // update selected clip index\r\n                    lcs[ 1 ] = clipIdx;\r\n\r\n                    if( clip.start + clip.duration > this.duration ){\r\n                        this.setDuration( clip.start + clip.duration );\r\n                    }\r\n                    if(this.onContentMoved) {\r\n                        this.onContentMoved(clip, leastDelta);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n        else if(e.track && e.buttons == 0) { // mouse not dragging, just hovering\r\n\r\n            this.unHoverAll();\r\n            let clips = this.getClipsInRange(e.track, time, time, 0.00001);\r\n            if(!e.track.locked && clips) {\r\n\r\n                this.lastHovered = [e.track.trackIdx, clips[ 0 ]];\r\n                e.track.hovered[clips[ 0 ]] = true;\r\n\r\n                let clip = e.track.clips[clips[ 0 ]];\r\n                if(!clip) {\r\n                    return;\r\n                }\r\n\r\n                if(Math.abs(e.localX - this.timeToX(clip.start + clip.duration)) < 8) { // duration\r\n                    this.canvas.style.cursor = \"col-resize\";\r\n                    this.dragClipMode = \"duration\";\r\n                }\r\n                else if(clip.fadein != undefined && Math.abs(e.localX - this.timeToX(clip.fadein)) < 8) { // fadein\r\n                    this.canvas.style.cursor = \"e-resize\";\r\n                    this.dragClipMode = \"fadein\";\r\n                }\r\n                else if(clip.fadeout != undefined && Math.abs(e.localX - this.timeToX(clip.fadeout)) < 8) { // fadeout\r\n                    this.canvas.style.cursor = \"e-resize\";\r\n                    this.dragClipMode = \"fadeout\";\r\n                }\r\n                else {\r\n                    this.dragClipMode = \"\";\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.unHoverAll();\r\n        }\r\n\r\n    }\r\n\r\n    drawContent( ctx: CanvasRenderingContext2D )  {\r\n\r\n        if(!this.animationClip)\r\n            return;\r\n\r\n        const tracks = this.animationClip.tracks;\r\n        const trackHeight = this.trackHeight;\r\n        const scrollY = - this.currentScrollInPixels;\r\n\r\n        ctx.save();\r\n        for(let i = 0; i < tracks.length; i++) {\r\n            let track = tracks[ i ];\r\n            this.drawTrackWithBoxes(ctx, i * trackHeight + scrollY, trackHeight, track);\r\n        }\r\n\r\n        ctx.restore();\r\n\r\n    }\r\n\r\n    /**\r\n     * @method drawTrackWithBoxes\r\n     * @param {*} ctx\r\n     */\r\n    drawTrackWithBoxes( ctx: CanvasRenderingContext2D, y: number, trackHeight: number, track: any ) {\r\n\r\n        // Fill track background if it's selected\r\n        ctx.globalAlpha = 0.2;\r\n        ctx.fillStyle = Timeline.TRACK_SELECTED_LIGHT;\r\n        if(track.isSelected) {\r\n            ctx.fillRect(0, y, ctx.canvas.width, trackHeight );\r\n        }\r\n\r\n        const clips = track.clips;\r\n\r\n        // set clip box size\r\n        const offset = (trackHeight * 0.4) * 0.5;\r\n        trackHeight *= 0.6;\r\n\r\n        let selectedClipArea: any = null;\r\n\r\n        ctx.font = Math.floor( trackHeight * 0.8) + \"px\" + Timeline.FONT;\r\n        ctx.textAlign = \"left\";\r\n        ctx.textBaseline = \"middle\";\r\n\r\n        for(var j = 0; j < clips.length; ++j)\r\n        {\r\n            selectedClipArea = null;\r\n            const clip = clips[ j ];\r\n            //let selected = track.selected[ j ];\r\n            var x = Math.floor( this.timeToX(clip.start) ) + 0.5;\r\n            var x2 = Math.floor( this.timeToX( clip.start + clip.duration ) ) + 0.5;\r\n            var w = x2-x;\r\n\r\n            if( x2 < 0 || x > this.canvas.width )\r\n                continue;\r\n\r\n            // Overwrite clip color state depending on its state\r\n            ctx.globalAlpha = 1;\r\n            ctx.fillStyle = clip.clipColor || (track.hovered[ j ] ? Timeline.KEYFRAME_COLOR_HOVERED : (track.selected[ j ] ? Timeline.TRACK_SELECTED : Timeline.KEYFRAME_COLOR));\r\n            if(!this.active || !track.active || !clip.active) {\r\n                ctx.fillStyle = Timeline.KEYFRAME_COLOR_INACTIVE;\r\n            }\r\n\r\n            // Draw clip background\r\n            drawRoundRect(ctx, x, y + offset, w, trackHeight , 5, true);\r\n\r\n            if(this.active && track.active && clip.active) {\r\n\r\n                ctx.fillStyle = clip.fadeColor ?? \"#0004\";\r\n\r\n                if( clip.fadein != undefined ){\r\n                    const fadeinX = this.pixelsPerSecond * (clip.fadein - clip.start);\r\n                    drawRoundRect(ctx, x, y + offset, fadeinX, trackHeight, {tl: 5, bl: 5, tr:0, br:0}, true);\r\n                }\r\n                if( clip.fadeout != undefined ){\r\n                    const fadeoutX = this.pixelsPerSecond * (clip.start + clip.duration - (clip.fadeout));\r\n                    drawRoundRect(ctx, x + w - fadeoutX, y + offset, fadeoutX, trackHeight, {tl: 0, bl: 0, tr:5, br:5}, true);\r\n                }\r\n            }\r\n\r\n            ctx.fillStyle = Timeline.TRACK_COLOR_PRIMARY;\r\n\r\n            if(track.selected[ j ] || track.hovered[ j ]) {\r\n                ctx.strokeStyle = ctx.shadowColor = clip.clipColor || Timeline.TRACK_SELECTED;\r\n                ctx.shadowBlur = 10;\r\n                ctx.shadowOffsetX = 1.5;\r\n                ctx.shadowOffsetY = 1.5;\r\n\r\n                selectedClipArea = [x - 1, y + offset -1, x2 - x + 2, trackHeight + 2];\r\n                drawRoundRect(ctx, selectedClipArea[ 0 ], selectedClipArea[ 1 ], selectedClipArea[ 2 ], selectedClipArea[3], 5, false, true);\r\n\r\n                ctx.shadowBlur = 0;\r\n                ctx.shadowOffsetX = 0;\r\n                ctx.shadowOffsetY = 0;\r\n\r\n                ctx.font = \"bold\" + Math.floor( trackHeight) + \"px \" + Timeline.FONT;\r\n                ctx.fillStyle = Timeline.FONT_COLOR_PRIMARY;\r\n            }\r\n\r\n\r\n            let text = clip.id ?? \"\"; //clip.id.replaceAll(\"_\", \" \").replaceAll(\"-\", \" \");\r\n            const textInfo = ctx.measureText( text );\r\n\r\n            let textWidth = textInfo.width;\r\n            if( textWidth > w && textWidth > 0){\r\n                let amount = Math.floor( w * text.length / textWidth );\r\n                text = text.substr( 0, amount );\r\n                textWidth = w;\r\n            }\r\n            ctx.fillText( text, x + (w - textWidth)*0.5,  y + offset + trackHeight * 0.5);\r\n\r\n            ctx.fillStyle = track.hovered[ j ] ? \"white\" : \"#f5f5f5\"//track.hovered[ j ] ? \"white\" : Timeline.FONT_COLOR_QUATERNARY;\r\n            ctx.strokeStyle = \"rgba(125,125,125,0.4)\";\r\n\r\n            // Draw resize bounding\r\n            drawRoundRect(ctx, x + w - 8 , y + offset , 8, trackHeight, {tl: 4, bl: 4, tr:4, br:4}, true, true);\r\n        }\r\n\r\n        ctx.font = \"12px\" + Timeline.FONT;\r\n    }\r\n\r\n    /**\r\n     * @method optimizeTrack\r\n     */\r\n    optimizeTrack(trackIdx: number) {\t\r\n    }\r\n\r\n    /**\r\n     * @method optimizeTracks\r\n     */\r\n    optimizeTracks() {\r\n    }\r\n\r\n   /**\r\n    *\r\n    * @param {Object} clip  clip to be added\r\n    * @param {Int} trackIdx (optional) track where to put the clip. -1 will find the first free slot. ***WARNING*** Must call getClipsInRange, before calling this function with a valid trackdIdx\r\n    * @param {Number} offsetTime (optional) offset time of current time\r\n    * @param {Number} searchStartTrackIdx (optional) if trackIdx is set to -1, this idx will be used as the starting point to find a valid track\r\n    * @returns  a zero/positive value if successful. Otherwise, -1\r\n    */\r\n    addClip( clip: any, trackIdx: number = -1, offsetTime: number = 0, searchStartTrackIdx: number = 0 ) {\r\n        if( !this.animationClip ){ return -1; }\r\n\r\n        this.deselectAllElements(); // TODO: consider adjusting values of hovered and selected instead of deselecting everything\r\n\r\n        // Update clip information\r\n        let newStart = clip.start + offsetTime;\r\n        if(clip.fadein != undefined)\r\n            clip.fadein += (newStart - clip.start);\r\n        if(clip.fadeout != undefined)\r\n            clip.fadeout += (newStart - clip.start);\r\n        clip.start = newStart;\r\n\r\n        // sanity check\r\n        clip.active = clip.active ?? true;\r\n\r\n        // find appropriate track\r\n        if( trackIdx >= this.animationClip.tracks.length ){ // new track ad the end\r\n            trackIdx = this.addNewTrack();\r\n        }\r\n        else if( trackIdx < 0 ){ // find first free track slot\r\n            for(let i = searchStartTrackIdx; i < this.animationClip.tracks.length; i++) {\r\n                let clipInCurrentSlot = this.animationClip.tracks[ i ].clips.find( (t: any) => {\r\n                    return LX.compareThresholdRange(newStart, clip.start + clip.duration, t.start, t.start+t.duration);\r\n                });\r\n\r\n                if(!clipInCurrentSlot){\r\n                    trackIdx = i;\r\n                    break;\r\n                }\r\n            }\r\n            if(trackIdx < 0){\r\n                trackIdx = this.addNewTrack();\r\n            }\r\n        }else{ // check specific track slot\r\n            // commented to avoid double checks with \"addclips\" fn\r\n            // let clipsInRange = this.getClipsInRange(this.animationClip.tracks[ trackIdx ], clip.start, clip.start+clip.duration, 0.0001);\r\n            // if( clipsInRange ){\r\n            //     return -1;\r\n            // }\r\n        }\r\n\r\n        clip.trackIdx = trackIdx;\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n        // Find new index\r\n        let newIdx = track.clips.findIndex( (t: any) => t.start > newStart );\r\n\r\n        // Add as last index\r\n        if(newIdx < 0) {\r\n            newIdx = track.clips.length;\r\n        }\r\n\r\n        //Save track state before add the new clip\r\n        this.saveState(trackIdx);\r\n\r\n        // Add clip\r\n        track.clips.splice(newIdx, 0, clip); //insert clip into newIdx (or push at the end)\r\n\r\n        // Reset this clip's properties\r\n        track.hovered.splice(newIdx, 0, false);\r\n        track.selected.splice(newIdx, 0, false);\r\n        track.edited.splice(newIdx, 0, false);\r\n\r\n        if( !this.animationClip || (clip.start + clip.duration) > this.duration ){\r\n            this.setDuration(clip.start + clip.duration);\r\n        }\r\n\r\n        // Update animation action interpolation info\r\n        if(this.onUpdateTrack){\r\n            this.onUpdateTrack( [ trackIdx ] );\r\n        }\r\n\r\n        return newIdx;\r\n    }\r\n\r\n    /**\r\n     *  Add an array of clips to the timeline in the first suitable tracks. It tries to put clips in the same track if possible. All clips will be in adjacent tracks to each other\r\n     * @param {Array of objects} clips\r\n     * @param {Number} offsetTime\r\n     * @param {Int} searchStartTrackIdx\r\n     * @returns\r\n     */\r\n    addClips( clips: any[], offsetTime: number = 0, searchStartTrackIdx: number = 0 ){\r\n        if( !this.animationClip || !clips.length ){ return false; }\r\n\r\n        let clipTrackIdxs = new Int16Array( clips.length );\r\n        let baseTrackIdx = searchStartTrackIdx -1; // every time the algorithm fails, it increments the starting track Idx\r\n        let currTrackIdx = -1;\r\n        const tracks = this.animationClip.tracks;\r\n        const lastTrackLength = tracks.length;\r\n        let c = 0;\r\n        for( ; c < clips.length; ++c ){\r\n            const clip = clips[c];\r\n            const clipStart = clip.start + offsetTime;\r\n            const clipEnd = clipStart + clip.duration;\r\n            if( c == 0 ){ // last search failed, move one track down and check again\r\n                ++baseTrackIdx;\r\n                currTrackIdx = baseTrackIdx;\r\n\r\n                while ( currTrackIdx >= tracks.length ){ this.addNewTrack(null, false); }\r\n                let clipsInCurrentSlot = tracks[baseTrackIdx].clips.find( (t: any) => { return LX.compareThresholdRange(clipStart, clipEnd, t.start, t.start+t.duration); });\r\n\r\n                // reset search\r\n                if(clipsInCurrentSlot){\r\n                    c = -1;\r\n                    continue;\r\n                }\r\n\r\n                // success\r\n                clipTrackIdxs[c] = baseTrackIdx;\r\n            }else{\r\n\r\n                // check if it fits in current track\r\n                let clipsInCurrentSlot = tracks[currTrackIdx].clips.find( (t: any) => { return LX.compareThresholdRange(clipStart, clipEnd, t.start, t.start+t.duration); });\r\n\r\n                // check no previous added clips are in the way\r\n                for( let i = c-1; i > -1; --i ){\r\n                    if( clipTrackIdxs[ i ] != currTrackIdx || clipsInCurrentSlot ){ break; }\r\n                    clipsInCurrentSlot = LX.compareThresholdRange(clipStart, clipEnd, clips[ i ].start + offsetTime, clips[ i ].start + offsetTime + clips[ i ].duration);\r\n                }\r\n\r\n                // check if it fits in the next track\r\n                if( clipsInCurrentSlot ){\r\n                    ++currTrackIdx;\r\n                    if( currTrackIdx >= tracks.length ){ this.addNewTrack(null, false); }\r\n                    clipsInCurrentSlot = tracks[currTrackIdx].clips.find( (t:any) => { return LX.compareThresholdRange(clipStart, clipEnd, t.start, t.start+t.duration); });\r\n                }\r\n\r\n                // reset search\r\n                if( clipsInCurrentSlot ){\r\n                    c = -1;\r\n                    continue;\r\n                }\r\n\r\n                // success\r\n                clipTrackIdxs[c] = currTrackIdx;\r\n            }\r\n        }\r\n\r\n        // avoid updating panel on each new track. Instead just once at the end\r\n        if( lastTrackLength != tracks.length ){\r\n            this.updateLeftPanel();\r\n        }\r\n\r\n        // save state for all to-be-modified tracks. Do it once for all tracks\r\n        for( let i = baseTrackIdx; i <= currTrackIdx; ++i ){\r\n            this.saveState( i, i != baseTrackIdx );\r\n        }\r\n\r\n        // disable history saving\r\n        let oldStateEnabler = this.historySaveEnabler;\r\n        this.historySaveEnabler = false;\r\n\r\n        for( c = 0; c < clips.length; ++c ){\r\n            this.addClip(clips[c], clipTrackIdxs[c], offsetTime);\r\n        }\r\n\r\n        // recover old state of enabler\r\n        this.historySaveEnabler = oldStateEnabler;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    deleteSelectedContent(skipCallback: boolean = false) {\r\n        //*********** WARNING: RELIES ON SORTED lastClipsSelected ***********\r\n        if( !this.lastClipsSelected.length ){\r\n            return;\r\n        }\r\n\r\n        // delete selected clips from last to first. lastClipsSelected is sorted\r\n        const selected = this.lastClipsSelected;\r\n        this.lastClipsSelected = []; // so this.#delete does not check clipsselected on each loop (all will be destroyed)\r\n        let prevTrack = -1;\r\n        for( let i = selected.length-1; i > -1; --i ){\r\n            let s = selected[ i ];\r\n            if( s[ 0 ] != prevTrack){\r\n                this.saveState(s[ 0 ], prevTrack != -1 );\r\n                prevTrack = s[ 0 ];\r\n            }\r\n\r\n           this.#delete(s[ 0 ], s[ 1 ]);\r\n        }\r\n\r\n        if(this.onDeleteSelectedClips && !skipCallback){\r\n            this.onDeleteSelectedClips(selected);\r\n        }\r\n\r\n    }\r\n\r\n    /** Delete clip from the timeline\r\n     * @param {Number} trackIdx\r\n     * @param {Number} clipIdx clip to be deleted\r\n    */\r\n    deleteClip( trackIdx: number, clipIdx: number, skipCallback: boolean = false ) {\r\n\r\n\r\n        this.saveState(trackIdx);\r\n        const clip = this.#delete(trackIdx, clipIdx);\r\n\r\n        if( this.onDeleteClip && !skipCallback ){\r\n            this.onDeleteClip( trackIdx, clipIdx, clip );\r\n        }\r\n    }\r\n\r\n    #delete(trackIdx: number, clipIdx: number) {\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n\r\n        // remove from selected clips\r\n        for(let i = 0; i < this.lastClipsSelected.length; i++) {\r\n            const [selectedTrackIdx, selectedClipIdx] = this.lastClipsSelected[ i ];\r\n            if(selectedTrackIdx == trackIdx){\r\n                if(selectedClipIdx == clipIdx){ // remove self\r\n                    this.lastClipsSelected.splice(i--,1);\r\n                }else if(selectedClipIdx > clipIdx){ // move upper clips to the left\r\n                    this.lastClipsSelected[ i ][ 1 ]--;\r\n                }\r\n            }\r\n            else if( trackIdx < selectedTrackIdx ){\r\n                break;\r\n            }\r\n        }\r\n\r\n        if( this.lastHovered && this.lastHovered[ 0 ] == trackIdx ){\r\n            if( this.lastHovered[ 1 ] == clipIdx ){ this.unHoverAll(); }\r\n            else if( this.lastHovered[ 1 ] > clipIdx ){ this.lastHovered[ 1 ]--; }\r\n        }\r\n\r\n        const clip = track[clipIdx];\r\n        track.hovered.splice(clipIdx,1);\r\n        track.selected.splice(clipIdx,1);\r\n        track.edited.splice(clipIdx,1);\r\n        track.clips.splice(clipIdx, 1);\r\n        return clip;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * User defined. Used when copying and pasting\r\n     * @param {Array of clips} clipsToClone array of original clips. Do not modify clips in this array\r\n     * @param {Number} timeOffset Value of time that should be added (or subtracted) from the timing attributes\r\n     * @param {Int} reason Flag to signal the reason of the clone\r\n     * @returns {Array of clips}\r\n     */\r\n    cloneClips( clipsToClone: any[], timeOffset: number, reason: number = 0 ){\r\n        let clipsToReturn = JSON.parse(JSON.stringify(clipsToClone))\r\n        for(let i = 0; i < clipsToReturn.length; ++i){\r\n            let clip = clipsToReturn[ i ];\r\n            clip.start += timeOffset;\r\n            if(clip.fadein == null || clip.fadein == undefined ){ clip.fadein = undefined; }\r\n            else{ clip.fadein += timeOffset; }\r\n            if(clip.fadeout == null || clip.fadeout == undefined ){ clip.fadeout = undefined; }\r\n            else{ clip.fadeout += timeOffset; }\r\n        }\r\n        return clipsToReturn;\r\n    }\r\n\r\n    /**\r\n     * Overwrite the \"cloneClips\" function to provide a custom cloning of clips. Otherwise, JSON serialization is used\r\n     */\r\n    copySelectedContent() {\r\n\r\n        if( this.lastClipsSelected.length == 0 ){\r\n            return;\r\n        }\r\n\r\n        let clipsToCopy: any = [];\r\n        const lastClipsSelected = this.lastClipsSelected;\r\n        const tracks = this.animationClip.tracks;\r\n        let globalStart = Infinity;\r\n        for(let i = 0; i < lastClipsSelected.length; ++i){\r\n            let clip: any = tracks[ lastClipsSelected[ i ][ 0 ] ].clips[ lastClipsSelected[ i ][ 1 ] ];\r\n            clipsToCopy.push( clip );\r\n            if( globalStart > clip.start ){ globalStart = clip.start; }\r\n        }\r\n\r\n        globalStart = Math.max(0, globalStart);\r\n        this.clipboard = this.cloneClips( clipsToCopy, -globalStart, ClipsTimeline.CLONEREASON_COPY );\r\n    }\r\n\r\n    pasteContent( time: number = this.currentTime ) {\r\n        this.deselectAllClips();\r\n\r\n        if(!this.clipboard)\r\n            return;\r\n\r\n        time = Math.max(0, time);\r\n\r\n        let clipsToAdd = this.cloneClips( this.clipboard, time, ClipsTimeline.CLONEREASON_PASTE );\r\n        this.addClips(clipsToAdd, 0);\r\n    }\r\n\r\n    /**\r\n     * @method clearTrack\r\n     */\r\n\r\n    clearTrack( trackIdx: number ) {\r\n\r\n        if(!this.animationClip) {\r\n            this.animationClip = {tracks:[]};\r\n            return;\r\n        }\r\n        this.saveState(trackIdx);\r\n\r\n        if(this.animationClip.tracks[ trackIdx ].locked ) {\r\n            return;\r\n        }\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        track.selected = [];\r\n        track.edited = [];\r\n        track.hovered = [];\r\n        track.clips = [];\r\n\r\n        // remove from selected clips\r\n        for(let i = 0; i < this.lastClipsSelected.length; i++) {\r\n            const [selectedTrackIdx, selectedClipIdx] = this.lastClipsSelected[ i ];\r\n            if(selectedTrackIdx == trackIdx){\r\n                this.lastClipsSelected.splice(i--,1);\r\n            }\r\n            else if( trackIdx < selectedTrackIdx ){\r\n                break;\r\n            }\r\n        }\r\n\r\n        if( this.lastHovered && this.lastHovered[ 0 ] == trackIdx ){ this.unHoverAll(); }\r\n\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * saveState function uses this to generate a \"copy\" of the track.\r\n     * @param {Number} trackIdx\r\n     * @returns All necessary information to reconstruct the track state\r\n     */\r\n    historyGenerateTrackStep( trackIdx: number ){\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        const clips = this.cloneClips(track.clips, 0, ClipsTimeline.CLONEREASON_HISTORY);\r\n\r\n        // sanity check in case cloneClips misses this\r\n        for( let i = 0; i < clips.length; ++i ){\r\n            clips[ i ].trackIdx = trackIdx;\r\n        }\r\n\r\n        const undoStep = {\r\n            trackIdx: trackIdx, // already done by saveState\r\n            clips: clips,\r\n            edited: track.edited.slice(0,track.clips.length)\r\n        };\r\n\r\n        return undoStep;\r\n    }\r\n\r\n    /**\r\n     * It should swap the previous state with the incoming state of the track. It must return the previous state.\r\n     * historyGenerateTrackStep could be used to copy the previous state. However, as it is a swap, it suffices to just copy the references.\r\n     * @param {Object} state object with a trackIdx:Number and whatever information was saved in historyGenerateTrackStep\r\n     * @param {Boolean} isUndo\r\n     * @returns previous state object\r\n     */\r\n    historyApplyTrackStep( state: any, isUndo: boolean ){\r\n        const track = this.animationClip.tracks[state.trackIdx];\r\n\r\n        const stateToReturn = {\r\n            trackIdx: state.trackIdx, // already done by saveState\r\n            clips: track.clips,\r\n            edited: track.edited\r\n        };\r\n\r\n        track.clips = state.clips;\r\n        track.edited = state.edited;\r\n        if( track.selected.length < track.clips.length ){ track.selected.length = track.clips.length; }\r\n        if( track.hovered.length < track.clips.length ){ track.hovered.length = track.clips.length; }\r\n        track.selected.fill( false );\r\n        track.hovered.fill( false );\r\n\r\n        // sanity check. Also done in addClip\r\n        for( let i = 0; i < track.clips.length; ++i ){\r\n            track.clips[ i ].active = track.clips[ i ].active ?? true;\r\n        }\r\n\r\n        return stateToReturn;\r\n    }\r\n\r\n    getClipOnTime( track: any, time: number, threshold: number ) {\r\n\r\n        if(!track || !track.clips.length){\r\n            return -1;\r\n        }\r\n\r\n        // Avoid iterating through all timestamps\r\n        if((time + threshold) < track.clips[ 0 ].start){\r\n            return -1;\r\n        }\r\n\r\n        for(let i = 0; i < track.clips.length; ++i) {\r\n            let t = track.clips[ i ];\r\n            if(t.start + t.duration >= (time - threshold) &&\r\n                t.start <= (time + threshold)) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    };\r\n\r\n    deselectAllClips() {\r\n\r\n        for(let [trackIdx, clipIdx] of this.lastClipsSelected) {\r\n            this.animationClip.tracks[ trackIdx ].selected[clipIdx]= false;\r\n        }\r\n        // Something has been deselected\r\n        const deselected = this.lastClipsSelected.length > 0;\r\n        this.lastClipsSelected.length = 0;\r\n        return deselected;\r\n    }\r\n\r\n    selectAll( skipCallback = false) {\r\n\r\n        this.deselectAllClips();\r\n        for(let trackIdx = 0; trackIdx < this.animationClip.tracks.length; trackIdx++) {\r\n            for(let clipIdx = 0; clipIdx < this.animationClip.tracks[ trackIdx ].clips.length; clipIdx++) {\r\n                this.animationClip.tracks[ trackIdx ].selected[clipIdx] = true;\r\n                this.lastClipsSelected.push( [trackIdx, clipIdx] ); // already sorted\r\n            }\r\n        }\r\n        if(this.onSelectClip && !skipCallback)\r\n            this.onSelectClip(null);\r\n    }\r\n\r\n    selectClip( trackIdx: number, clipIndex: number, deselect: boolean = true, skipCallback: boolean = false ) {\r\n\r\n        if(deselect){\r\n            this.deselectAllClips();\r\n        }\r\n\r\n        if(clipIndex < 0){\r\n            return -1;\r\n        }\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        if(track.selected[clipIndex]){\r\n            return clipIndex;\r\n        }\r\n\r\n        // Select if not handled\r\n\r\n        // push selection sorted by track index and clip index\r\n        let i = 0;\r\n        for( ; i < this.lastClipsSelected.length; ++i){\r\n            let t = this.lastClipsSelected[ i ];\r\n            if( t[ 0 ] < track.trackIdx ){ continue; }\r\n            if( t[ 0 ] > track.trackIdx || t[ 1 ] > clipIndex ){ break;}\r\n        }\r\n        this.lastClipsSelected.splice(i,0, [track.trackIdx, clipIndex, track.clips[clipIndex] ] ); //\r\n        track.selected[clipIndex] = true;\r\n\r\n        if( !skipCallback && this.onSelectClip ){\r\n            this.onSelectClip(track.clips[ clipIndex ]);\r\n            // Event handled\r\n        }\r\n        return clipIndex;\r\n    }\r\n\r\n    deselectClip( trackIdx: number, clipIndex: number ){\r\n\r\n        if(clipIndex == -1){\r\n            return -1;\r\n        }\r\n\r\n        const track = this.animationClip.tracks[ trackIdx ];\r\n        if(!track.selected[clipIndex]){\r\n            return -1;\r\n        }\r\n\r\n        track.selected[clipIndex] = false;\r\n\r\n        // deselect\r\n        for( let i = 0; i < this.lastClipsSelected.length; ++i){\r\n            let t = this.lastClipsSelected[ i ];\r\n            if( t[ 0 ] == trackIdx && t[ 1 ] == clipIndex ){\r\n                this.lastClipsSelected.splice(i,1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        return clipIndex;\r\n    }\r\n\r\n    getClipsInRange( track: any, minTime: number, maxTime: number, threshold: number = 0 ) {\r\n\r\n        if(!track || !track.clips.length)\r\n        return null;\r\n\r\n        // Manage negative selection\r\n        if(minTime > maxTime) {\r\n            let aux = minTime;\r\n            minTime = maxTime;\r\n            maxTime = aux;\r\n        }\r\n\r\n        minTime -= threshold;\r\n        maxTime += threshold;\r\n\r\n        // Avoid iterating through all timestamps\r\n        minTime -= threshold;\r\n        maxTime += threshold;\r\n\r\n        const clips = track.clips;\r\n        if(maxTime < clips[ 0 ].start || minTime > (clips[clips.length-1].start + clips[clips.length-1].duration) )\r\n            return null;\r\n\r\n        let indices: number[] = [];\r\n\r\n        for(let i = 0; i < clips.length; ++i) {\r\n            const c = clips[ i ];\r\n            if( c.start+c.duration < minTime ){ continue; }\r\n            if( c.start > maxTime ){ break; }\r\n            indices.push(i);\r\n        }\r\n        return indices.length ? indices : null;\r\n    }\r\n\r\n    validateDuration(t: number) {\r\n        for(let i = 0; i < this.animationClip.tracks.length; i++) {\r\n            const track = this.animationClip.tracks[ i ];\r\n            if( track.clips.length ){\r\n                const clip = track.clips[track.clips.length-1]; // assuming they are ordered ascendently\r\n                t = Math.max(t, clip.start + clip.duration);\r\n            }\r\n        }\r\n        return t;\r\n    }\r\n\r\n    setDuration( t: number, skipCallback: boolean = false, updateHeader: boolean = true ){\r\n        const oldT = t;\r\n        const newT = this.validateDuration(t);\r\n        super.setDuration( newT, skipCallback, oldT != newT || updateHeader );\r\n    }\r\n}\r\n\r\nLX.ClipsTimeline = ClipsTimeline;\r\n\r\n/**\r\n * Draws a rounded rectangle using the current state of the canvas.\r\n * If you omit the last three params, it will draw a rectangle\r\n * outline with a 5 pixel border radius\r\n * @param {Number} x The top left x coordinate\r\n * @param {Number} y The top left y coordinate\r\n * @param {Number} width The width of the rectangle\r\n * @param {Number} height The height of the rectangle\r\n * @param {Number} [radius = 5] The corner radius; It can also be an object\r\n *                 to specify different radii for corners\r\n * @param {Number} [radius.tl = 0] Top left\r\n * @param {Number} [radius.tr = 0] Top right\r\n * @param {Number} [radius.br = 0] Bottom right\r\n * @param {Number} [radius.bl = 0] Bottom left\r\n * @param {Boolean} [fill = false] Whether to fill the rectangle.\r\n * @param {Boolean} [stroke = true] Whether to stroke the rectangle.\r\n */\r\n\r\nfunction drawRoundRect( ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: any = 5, fill: boolean = false, stroke: boolean = false ) {\r\n\r\n    if(typeof radius === 'number') {\r\n        radius = {tl: radius, tr: radius, br: radius, bl: radius};\r\n    } else {\r\n        var defaultRadius: any = {tl: 0, tr: 0, br: 0, bl: 0};\r\n        for (var side in defaultRadius) {\r\n            radius[side] = radius[side] ?? defaultRadius[side];\r\n        }\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(x + radius.tl, y);\r\n    ctx.lineTo(x + width - radius.tr, y);\r\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\r\n    ctx.lineTo(x + width, y + height - radius.br);\r\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\r\n    ctx.lineTo(x + radius.bl, y + height);\r\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\r\n    ctx.lineTo(x, y + radius.tl);\r\n    ctx.quadraticCurveTo(x, y, x + radius.tl, y);\r\n    ctx.closePath();\r\n\r\n    if(fill) {\r\n        ctx.fill();\r\n    }\r\n    if(stroke) {\r\n     ctx.stroke();\r\n    }\r\n}\r\n\r\nLX.concatTypedArray = (arrays: any[], ArrayType: any) => {\r\n    let size = arrays.reduce((acc,arr) => acc + arr.length, 0);\r\n    let result = new ArrayType( size ); // generate just one array\r\n    let offset = 0;\r\n    for( let i = 0; i < arrays.length; ++i ){\r\n        result.set(arrays[ i ], offset ); // copy values\r\n        offset += arrays[ i ].length;\r\n    }\r\n    return result;\r\n}"],"names":[],"mappings":"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"}