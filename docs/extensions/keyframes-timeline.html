<script type="module">
    import { LX } from "lexgui"
    import { KeyFramesTimeline } from "lexgui/extensions/timeline.js"

    MAKE_HEADER( "Keyframes Timeline", "h1", "keyframes-timeline" );

    {
        const keyframestimeline = new KeyFramesTimeline( "KeyframesId", { title: "Keyframes Timeline" } );
        const content = document.getElementById( 'content' );
        const area = new LX.Area( { skipAppend: true, height: "350px" } );
        area.attach(keyframestimeline);
        content.appendChild( area.root );
        keyframestimeline.resize();

        if ( window.keyframeTimeline ){ window.keyframeTimeline.__terminate = true; }
        window.keyframeTimeline = keyframestimeline;
        
        const animation = {
            duration: 10,
            tracks: [
                { id: "track1" },
                { id: "group.track2", times: [0,1,2,3] },
                { id: "group.track3", times: [0,1,2,3], values:[0,11,22,33], curvesRange:[0,33] },
                { id: "group.track333", times: [0,1,2,3], values:[0,11,22,33], curves: false, curvesRange:[0,33] },
                { id: "group.track4", times: [1,2,3,4], values:[0,0,0,1,11,111,2,22,222,3,33,333], dim:3 },
                { id: "track5", times: [0,1,2,3] },
                { times: [0,1,2,3], values: [0,1,2,3], curvesRange:[0,3]  },
            ]
        }
        keyframestimeline.setAnimationClip(animation, true);
        keyframestimeline.setSelectedItems( ["group", 0, 6] );

        keyframestimeline.onAddNewTrack = (trackInfo, options) => {
            trackInfo.dim = 1 + Math.floor( Math.random() * 3.1 ); //doing this before any keyframe is added
            trackInfo.id = "Track " + keyframestimeline.animationClip.tracks.length + " " + trackInfo.dim + "D";
        }

        keyframestimeline.processKeys = function(e){
            if( e.type != 'keydown' ){
                return;
            }
            switch(e.key) {
                case 'Delete': case 'Backspace':
                    this.deleteSelectedContent();
                    break;
                case 'c': case 'C':
                    if(e.ctrlKey)
                        this.copySelectedContent();
                    break;
                case 'v': case 'V':
                    if(e.ctrlKey)
                        this.pasteContent();
                    break;
                case 'z': case 'Z':
                    if(e.ctrlKey)
                        this.undo();
                    break;
                case 'y': case 'Y':
                    if(e.ctrlKey)
                        this.redo();
                    break;
                case ' ':
                    this.changeState();
                    break; 

                case "Shift":
                    this.canvas.style.cursor = "crosshair";
                    break;
            }
        }

        let lastTimestamp = performance.now();
        keyframestimeline.onStateStop = () => {
            keyframestimeline.setTime(0);
        }
        keyframestimeline.onStateChange = () => {
            lastTimestamp = performance.now();
        }
        function render(timestamp){

            // avoids multiple instances of keyframestimeline to render. Just render the last one
            // clicking on other documentation entries WILL NOT terminate render. 
            // TODO it should terminate as soon as documentation page is changed
            if ( keyframestimeline.__terminate ){
                return;
            }

            requestAnimationFrame( render );
            
            if ( keyframestimeline.playing ){
                const dt = ( timestamp - lastTimestamp ) * 0.001;
                keyframestimeline.setTime( (keyframestimeline.currentTime + dt) % keyframestimeline.animationClip.duration)
            }

            lastTimestamp = timestamp;
            keyframestimeline.draw();
        }

        render();
    }
    MAKE_CODE( `@let@ kfTimeline = @new@ LX.@[cls]KeyframesTimeline@(@"KeyTimelineUniqueID"@, {title: @"Keyframes Timeline"@});
panel.@[mtd]attach@(kfTimeline.root);` );

   const baseAnimationClipOptions = [
            [".id", "String", "Id of the animation"],
            [".data", "", "User defined data"],
            [".duration", "Number", "0 by default"],
            [".tracks", "Array", "Tracks of the animation clip"],
        ];

    MAKE_HEADER( "Keyframes AnimationClip", "h2", "" );
    MAKE_PARAGRAPH( `New animations should be created and set to the timeline through the ${INLINE_CODE("setAnimationClip")} function, that (optionaly) expects an object with the same attributes as an animationClip (see below). )`);
    MAKE_PARAGRAPH( `Tracks will also be processed. Missing attributes will be set to default values.`);
    MAKE_CODE_BULLET_LIST( baseAnimationClipOptions.concat([
        [".tracksPerGroup", "Object", "maps groupIds (Strings) to an array of tracks"],
    ]) );
    MAKE_PARAGRAPH( `${INLINE_CODE("instantiateAnimationClip")} method can be used to duplicate animationClips through the ${INLINE_CODE("clone")} argument` );


    MAKE_HEADER( "Keyframes Tracks", "h2", "" );
    MAKE_PARAGRAPH( `New Tracks should be added to the animationClip clip through the ${INLINE_CODE("addNewTrack")} function, that (optionaly) expects an object of the same attributes as a track (see below).`);
    MAKE_PARAGRAPH(`All attributes except ${INLINE_CODE("isTrack")} and ${INLINE_CODE("trackIdx")} will be retrieved from the track information sent to the function, if available.`);
    MAKE_PARAGRAPH(`${INLINE_CODE("id")} and ${INLINE_CODE("name")} attributes will me mapped to the ${INLINE_CODE("id")} of the track (in this order of precedence).`);
    MAKE_CODE_BULLET_LIST( [
        [".isTrack", "Boolean", `${INLINE_CODE("Read-Only")} Identifies it as a track`],
        [".id", "String", `Name of the track. If the track is currently visible, changing its id will require a call to ${INLINE_CODE("updateLeftPanel")}`],
        [".active", "Boolean", `${INLINE_CODE("Read-Only")} Whether it is disabled or not. Use ${INLINE_CODE("setTrackState")} to modify it.`],
        [".locked", "Boolean", `Whether its elements can be modified or not.`],
        [".isSelected", "Boolean", `${INLINE_CODE("Read-Only")} Whether to paint the track background blue, flagging it as selected.`],
        [".trackIdx", "Number", `${INLINE_CODE("Read-Only")} Position of the track in the animationClip's tracks array.`],

        [".dim", "Number", `Number of values per keyframe. It can be modified, as long as it makes sense with ${INLINE_CODE("times")} and ${INLINE_CODE("values")} attributes`],
        [".groupId", "String", `${INLINE_CODE("Read-Only")} Group to which it is attached. Use ${INLINE_CODE("setTracksGroup")} instead of directly modifying it`],
        [".groupTrackIdx", "Number", `${INLINE_CODE("Read-Only")} Index of the track inside the group array`],
        
        [".curves", "Boolean", `Whether to render this track as centered keyframes or curves`],
        [".curvesRange", "[Number, Number]", `range of values [min, max] that the track will hold.`],

        [".values", "Array Number", `Flat array of size = number-of-keyframes * dim, containing the values of each keyframe. Values inside the array can be safely modified. Directly modifying its length might lead to undefined behaviour.`],
        [".times", "Array Number", `Flat array of size = number-of-keyframes, containing the timestamp of each keyframe sorted ascendently. Values inside the array can be safely modified as long as the array is kept sorted ascendently. Directly modifying its length might lead to undefined behaviour.`],
        [".edited", "Array Boolean", `Array of size = number-of-keyframes, containing a flag to indicate whether the keyframe has been modified. Its values can be safely modified.`],
        [".selected", "Array Boolean", `${INLINE_CODE("Read-Only")} Array of size number-of-keyframes, containing a flag to indicate whether the keyframe is currently selected. Modifying it might not update the underlying selection system.`],
        [".hovered", "Array Boolean", `${INLINE_CODE("Read-Only")} Array of size number-of-keyframes, containing a flag to indicate whether the keyframe is currently hovered by the mouse. Modifying it might not update the underlying hovering system.`],

        [".data", "", "user defined data"]
    ] );

    MAKE_HEADER( "Constructor", "h2", "" );
    MAKE_CLASS_CONSTRUCTOR( "class LX.KeyFramesTimeline", [
        ["id", "String", "Unique string that identifies this element"],
        ["options", "Object"]
    ] );

    MAKE_HEADER( "Properties", "h2", "" );
    MAKE_PARAGRAPH( `Check ${INLINE_CODE("Timeline")} properties`);
    MAKE_CODE_BULLET_LIST( [
        [".lastKeyFramesSelected", "Array of [trackIdx, keyframeIdx, keyframe time]", `${INLINE_CODE("Read-Only")} the currently selected keyframes across all tracks, sorted ascendently`],
        [".keyValuePerPixel", "Number", `Applicable to tracks with dim = 1, amount of normalized value ( [ 0, 1 ] ) to add per pixel moved while holding ${INLINE_CODE("alt")}. Default to 1/${INLINE_CODE("trackHeight")}`],
        [".defaultCurves", "Boolean", `Applicable to tracks with dim = 1, the default way of rendering tracks with dim = 1. If true, it renders them with curves.`],  
        [".defaultCurvesRange", "[Number, Number]", `Applicable to tracks with dim = 1, the default range of values [min, max] that a track holds.`],  
    ] );

    MAKE_HEADER( "Callbacks", "h2", "" );
    MAKE_PARAGRAPH(`Callbacks can be set directly to the instance of ${INLINE_CODE("KeyFramesTimeline")}`);
    MAKE_PARAGRAPH(`Check ${INLINE_CODE("Timeline")} for the list of inherited callbacks. If a callback appears on both lists, the  ${INLINE_CODE("KeyFramesTimeline")} takes precedence.`);
    MAKE_CLASS_METHOD( "onAddNewTrack", `Triggered after creating a track through the ${INLINE_CODE("addNewTrack")} function. This callback can be used to change the default id of the track, modify the dimension of the values or to insert some initial values. To include this track into a group, use the ${INLINE_CODE("setTracksGroup")} function`, [
        ["track", "Object"],
    ] );
    
    MAKE_CLASS_METHOD( "onItemSelected", `Triggered after calling ${INLINE_CODE("selectItems")}.`, [
        ["currentSelectedItems", "Array of Numbers for tracks or Strings for groups"],
        ["itemsAdded", "Array of Numbers for tracks or Strings for groups"],
        ["itemsRemoved", "Array of Numbers for tracks or Strings for groups"],
    ] );

    MAKE_CLASS_METHOD( "onSelectKeyFrame", `Triggered after selecting a keyframe.`, [
        ["currentSelection", "[trackIdx, keyframeIdx, time of keyframe]"],
    ] );
    
    MAKE_CLASS_METHOD( "onDeselectKeyFrames", `Triggered before deselecting all keyframes.`, [
        ["selectedKeyframes", "Array of [trackIdx, keyframeIdx, timestamp of keyframe]"],
    ] );

    MAKE_CLASS_METHOD( "onContentMoved", `Triggered after moving keyframes horizontally. Calls it for each frame .`, [
        ["trackIndex", "Number"],
        ["newKeyframeIndex", "Number"],
    ] );

    MAKE_CLASS_METHOD( "onUpdateTrack", `Triggered after changing keyframe values through ${INLINE_CODE("Alt")} in a curves track, pasting values, undoing-redoing and adding keyframes.`, [
        ["tracks", "Array of Number"],
    ] );
    
    MAKE_CLASS_METHOD( "onOptimizeTracks", `Triggered after optimizing tracks. It receives either a valid track index or a -1 indicating that all tracks have been optimized at once`, [
        ["trackIndex", "Number"],
    ] );

    MAKE_CLASS_METHOD( "onDeleteKeyFrames", `Triggered after deleting keyframes.`, [
        ["trackIndex", "Number"],
        ["keyframeIndices", "Array of Number"],
    ] );


    MAKE_HEADER( "Methods", "h2", "" );
    MAKE_PARAGRAPH(`Check ${INLINE_CODE("Timeline")} for the list of inherited methods. If a method appears on both lists, the ${INLINE_CODE("KeyFramesTimeline")} takes precedence.`);

    MAKE_CLASS_METHOD( ".setTracksGroup", "Group tracks. A track can only be in one group.", [
        ["groupId", "String"],
        ["trackIndices", "Array Number"],
    ], "" );
    MAKE_CLASS_METHOD( ".getTracksGroup", "Returns an array of object, each being a track of the group.", [
        ["groupId", "String"],
    ], "Array Tracks" );

    MAKE_CLASS_METHOD( ".optimizeTrack", `Removes similar keyframes of a track, given the ${INLINE_CODE("optimizeThreshold")} attribute. If ${INLINE_CODE("onlyEqualTime")} is set, only keyframes with the same time will be removed, keepin the first occurrence`, [
        ["trackIdx", "Number"],
        ["onlyEqualTime", "Boolean"],
        ["skipCallback", "Boolean"],
    ], "" );
    MAKE_CLASS_METHOD( ".optimizeTracks", `Removes similar keyframes of all track, given the ${INLINE_CODE("optimizeThreshold")} attribute. If ${INLINE_CODE("onlyEqualTime")} is set, only keyframes with the same time will be removed, keepin the first occurrence`, [
        ["onlyEqualTime", "Boolean"],
    ], "" );
    
    MAKE_CLASS_METHOD( ".copySelectedContent", `Copies the lastKeyFramesSelected elements into clipboard.`, [
    ], "" );
    MAKE_CLASS_METHOD( ".pasteContent", `Paste copied keyframes into the tracks, positioned at ${INLINE_CODE("time")}.`, [
        ["time", "Number"]
    ], "" );
    MAKE_CLASS_METHOD( ".deleteSelectedContent", `Delete selected keyframes from the tracks.`, [
        ["skipCallback", "Boolean"]
    ], "" );
    MAKE_CLASS_METHOD( ".clearTrack", `Delete all keyframes from a track.`, [
        ["trackIdx", "Number"]
    ], "" );

    MAKE_CLASS_METHOD( ".deleteKeyframes", `Delete keyframes of a track.`, [
        ["trackIdx", "Number"],
        ["frameIndices", "Array of Number"],
        ["skipCallback", "Boolean"]

    ], "" );

    MAKE_CLASS_METHOD( ".addKeyFrames", `Add keyframes to a track. ${INLINE_CODE("newTimes")} must be sorted ascendently. If ${INLINE_CODE("flags")} is set to ${INLINE_CODE("Timeline.ADDKEY_VALUESINARRAYS")} (0x01), values must be an array of arrays, each containing the values of a single frame. Otherwise, it must be a flat array.`, [
        ["trackIdx", "Number"],
        ["newValues", "Array of Number"],
        ["newTimes", "Array of Number"],
        ["timeOffset", "Number"],
        ["flags", "Number"],
    ], "" );

    MAKE_CLASS_METHOD( ".getNearestKeyFrame", `Returns the index of the frame or -1. Modes { -1: nearest frame with t[f] <= time, 0: nearest frame, 1: nearest frame with t[f] >= time }.`, [
        ["track", "obj"],
        ["time", "Number"],
        ["mode", "Number"],
    ], "Number" );
        
    MAKE_CLASS_METHOD( ".processSelectionKeyFrame", `Helper function to select a keyframe and set the timeline time to that keyframe (only if ${INLINE_CODE("multipleSelection")} is ${INLINE_CODE("false")} ). If ${INLINE_CODE("multipleSelection")} is ${INLINE_CODE("true")}, previous selected keyframes are kept selected.`, [
        ["trackIdx", "Number"],
        ["frameIdx", "Number"],
        ["multipleSelection", "Boolean"],
    ], "[trackIdx, frameIdx, frameTime]" );

    MAKE_CLASS_METHOD( ".selectKeyFrame", `Selects a keyframe, adding it to the currently selected keyframes.`, [
        ["trackIdx", "Number"],
        ["frameIdx", "Number"],
        ["skipCallback", "Boolean"],
    ], "[trackIdx, frameIdx, frameTime]" );
           
    MAKE_CLASS_METHOD( ".deselectKeyFrame", `Deselects a keyframe.`, [
        ["trackIdx", "Number"],
        ["frameIdx", "Number"],
    ], "Boolean" );
    MAKE_CLASS_METHOD( ".deselectAllKeyFrames", `Deselects all keyframes.`, [
    ], "" );

    MAKE_CLASS_METHOD( ".unHoverAll", `Unhover current keyframes.`, [
    ], "" );

    MAKE_CLASS_METHOD( ".getCurrentKeyFrame", "Get the nearest keyframe to _time_ given a maximum threshold.", [
        ["track", "Object"],
        ["time", "Number"],
        ["threshold", "Number"]
    ], "Number" );

    MAKE_HEADER("Controls", "h2", "" );
    MAKE_PARAGRAPH(`Default keyboard controls can be changed by reimplementing ${INLINE_CODE("processKeys")}`);

    const baseControls = [
        ["Mouse left click", ""],
        [
            ["Drag over time markers", "change current time "],
            ["Drag over tracks", "move timeline view"],
        ],
        ["Mouse right click", "Opens contextual menu"],
        ["Shift + Wheel", "Zoom in/out"],
        ["Ctrl + C", "Copy selected elements"],
        ["Ctrl + V", "Paste selected elements"],
        ["Space", "Changes timeline state"],
        ["Delete", "Delete selected elements"],
        ["Backspace", "Delete selected elements"],
    ];

    let keyControls = baseControls.slice();
    keyControls[1].push(
        ["ctrlKey + horizontal drag", "move selected keyframes (if any)"],
        ["altKey + vertical drag", `change value of selected keyframes. Only applicable to tracks with dim = 1 and their ${INLINE_CODE("curves")} attribute set to ${INLINE_CODE("true")}`]
    );
    MAKE_CODE_BULLET_LIST( keyControls );

    MAKE_LINE_BREAK();
    MAKE_LINE_BREAK();

</script>