<script type="module">
    import {LX} from "lexgui"
    import {KeyFramesTimeline, ClipsTimeline} from "lexgui/components/timeline.js"

    MAKE_HEADER( "Timeline", "h1", "timeline" );
    MAKE_PARAGRAPH( `Timeline is an abstract class and it has the following derived clases:` );
    MAKE_CODE_BULLET_LIST( [
        `<a href="#keyframes-timeline">KeyframesTimeline</a>`,
        `<a href="#clips-timeline">ClipsTimeline</a>`,
    ] );
    MAKE_HEADER( "Constructor", "h2", "" );
    MAKE_CLASS_CONSTRUCTOR( "Timeline", [
        ["id", "String", "Unique string that identifies this element"],
        ["options", "Object"]
    ] );
    
    MAKE_PARAGRAPH(`Each timeline has to be appended to an existing panel, where the possible ${INLINE_CODE(`options`)} are the following:` );
    MAKE_CODE_BULLET_LIST( [
        ["title", "String", `Set a title for the timeline.`],
        ["loop", "Boolean", "Set looping mode animation by default."],
        ["skipVisibility", "Boolean", "When it's true, the un/active track button is disabled."],
        ["skipLock", "Boolean", "When it's true, the un/lock track button is disabled."],
        ["disableNewTracks", "Boolean", "When it's true, add new tracks option is disabled."],                
        ["onCreateBeforeTopBar", "Function", `Callback to add widgets on the top bar before the 'current time' widget.`],
        ["onCreateAfterTopBar", "Function", `Callback to add widgets on the top bar after the 'duration' widget.`],
        ["onCreateControlsButtons", "Function", `Callback to add widgets on the top bar after the default ones (play, stop, loop).`],
        ["onCreateSettingsButtons", "Function", `Callback to add widgets on the top bar before the default ones (optimize, configuration).`],
        ["onShowOptimizeMenu", "Function", `Callback to add an optimize menu on the right side, before the configuration menu. If undefined, the menu will appear and use the default implementation. Set it to null, to deactivate it.`],
        ["onShowConfiguration", "Function", `Callback to add widgets to the configuration menu.`]
    ] );
        
    MAKE_HEADER( "Callbacks", "h2", "" );
    MAKE_HEADER( "Constructor Callbacks", "h3", "" );
    MAKE_PARAGRAPH( `These are used to build the interface of the timeline. Setting them outside the constructor will require a call to ${INLINE_CODE("updateHeader")} for them to take effect:`);
    MAKE_CLASS_METHOD( "onCreateBeforeTopBar", `Callback to add widgets on the top bar before the 'current time' widget.`, [
        ["panel", "LX panel"]
    ] );
    
    MAKE_CLASS_METHOD( "onCreateAfterTopBar", `Callback to add widgets on the top bar after the 'duration' widget.`, [
        ["panel", "LX panel"]
    ] );
    
    MAKE_CLASS_METHOD( "onCreateControlsButtons", `Callback to add widgets on the top bar after the default ones (play, stop, loop).`, [
        ["panel", "LX panel"]
    ] );

    MAKE_CLASS_METHOD( "onCreateSettingsButtons", `Callback to add widgets on the top bar before the default ones (optimize, configuration).`, [
        ["panel", "LX panel"]
    ] );

    MAKE_CLASS_METHOD( "onShowOptimizeMenu", `Callback to add an optimize menu on the right side, before the configuration menu. If undefined, the menu will appear and use the default implementation. Set it to null, to deactivate it.`, [
        ["panel", "LX panel"]
    ] );

    MAKE_CLASS_METHOD( "onShowConfiguration", `Callback to add widgets to the configuration menu.`, [
        ["panel", "LX panel"]
    ] );

    MAKE_HEADER( "Callbacks", "h3", "" );
    MAKE_PARAGRAPH( `These are used to react to some event and can be set at any time. Constructor's ${INLINE_CODE("options")} will not recognize this functions. `);
    
    MAKE_CLASS_METHOD( "onBeforeDrawContent", `Called before rendering the track elements.`, [
        ["ctx", "canvas context"]
    ] );

    MAKE_CLASS_METHOD( "onStateStop", `After clicking the stop button. The ${INLINE_CODE("playing")} attribute is false.`, [] );

    MAKE_CLASS_METHOD( "onStateChange", `Triggered after clicking the play/pause button. Receives the current state of the ${INLINE_CODE("playing")} attribute`, [
        ["currentState", "Boolean"]
    ] );

    MAKE_CLASS_METHOD( "onSetTime", `Triggered after changing the current time using the ${INLINE_CODE("setTime")} function or the interface`, [
        ["currentTime", "Number"]
    ] );
    
    MAKE_CLASS_METHOD( "onSetDuration", `Triggered after calling ${INLINE_CODE("setDuration")}`, [
        ["currentDuration", "Number"]
    ] );

    MAKE_CLASS_METHOD( "onChangeLoopMode", `Triggered after calling ${INLINE_CODE("setLoopMode")} or clicking on the loop button`, [
        ["currentLoopMode", "Boolean"]
    ] );
    
    MAKE_CLASS_METHOD( "onMouse", `Triggered after processing the mouse event over the canvas. The box selection of elements does not trigger this event. Receives the mouse event and the current time of the mouse location`, [
        ["event", "MouseEvent"],
        ["time", "Number"],
    ] );

    MAKE_CLASS_METHOD( "onDblClick", `Triggered after processing the mouse event over the canvas. The box selection of elements does not trigger this event. Receives the mouse event and the current time of the mouse location`, [
        ["event", "MouseEvent"],
    ] );

    MAKE_CLASS_METHOD( "onAddNewTrackButton", `Triggered after clicking on the "add track" button (if enabled). The default implementation adds a track to the clip and makes it visible. This callback also to overwrite this behaviour`, [ ] );
    
    MAKE_CLASS_METHOD( "onAddNewTrack", `Triggered after creating a track through the ${INLINE_CODE("addNewTrack")} function. This callback can be used to change the default id of the track, modify the dimension of the values or to insert some initial values`, [
        ["track", "Object"],
    ] );

    MAKE_CLASS_METHOD( "onItemSelected", `Triggered after calling ${INLINE_CODE("selectItems")}.`, [
        ["currentSelectedItems", "Array of Numbers"],
        ["itemsAdded", "Array of Numbers"],
        ["itemsRemoved", "Array of Numbers"],
    ] );

    MAKE_CLASS_METHOD( "onSelectTrack", `Triggered after calling ${INLINE_CODE("selectTrack")}.`, [
        ["track", "Object"]
    ] );

    MAKE_CLASS_METHOD( "onSetTrackState", `Triggered after calling ${INLINE_CODE("setTrackState")} or clicking in the eye icon (active) of the track.`, [
        ["track", "Object"],
        ["previousState", "Boolean"],
    ] );

    MAKE_CLASS_METHOD( "onLockTrack", `Triggered after clicking in the lock icon of the track.`, [
        ["track", "Object"],
        ["previousState", "Boolean"],
    ] );
          
    MAKE_HEADER( "Properties", "h2", "" );
    const baseAnimationClipOptions = [
            [".id", "String", "Id of the animation"],
            [".data", "", "User defined data"],
            [".duration", "Number", "0 by default"],
            [".tracks", "Array", "Tracks of the animation clip"],
        ];
    MAKE_CODE_BULLET_LIST( [
        [".root", "LX.Area", `${INLINE_CODE("Read-Only")} Container where the whole timeline is created`],
        [".uniqueID", "String", `${INLINE_CODE("Read-Only")}.`],  
        [".timelineTitle", "String", `Use ${INLINE_CODE("updateHeader")} after modifying it to update the interface`],
        [".animationClip", "Object", `${INLINE_CODE("Read-Only")} Contains all the information of an animation. Setting an animationClip must be done through ${INLINE_CODE("setAnimationClip")}. Check each class for full details`],
        baseAnimationClipOptions,
        [".playing", "Boolean", `${INLINE_CODE("Read-Only")}. Use ${INLINE_CODE("setState")} to modify its value`],  
        [".loop", "Boolean", `${INLINE_CODE("Read-Only")}. Whether the loop button is set or not.`],
        [".duration", "Number", `${INLINE_CODE("Read-Only")}. Use ${INLINE_CODE("setDuration")} to modify its value`],  
        [".currentTime", "Number", `${INLINE_CODE("Read-Only")}. Use ${INLINE_CODE("setTime")} to modify its value`],  
        [".historyMaxSteps", "Int", `Sets the maximum number of states for the history (undo & redo).`],  
        [".trackHeight", "Number", `${INLINE_CODE("Read-Only")}. Size of the tracks drawn.`],
        [".optimizeThreshold", "Number", `Used to optimize tracks, if it has an optimization function`]
    ] );

    MAKE_HEADER( "Methods", "h2", "" );

    MAKE_CLASS_METHOD( ".updateHeader", "Updates part of the interface. If timelinTitle or constructor callbacks are modified, this function needs to be called.", [], "" );
    MAKE_CLASS_METHOD( ".updateLeftPanel", "Update part of the interface. If track ids are changed, this function needs to be called.", [], "" );
    MAKE_CLASS_METHOD( ".draw", "Renders the canvas.", [], "" );

    MAKE_CLASS_METHOD( ".setAnimationClip", `Process and format the animation (and its tracks) and set it as the animationClip. If null, a new empty animation is generated. If already a proper animationClip, set ${INLINE_CODE("needsToProcess")} attribute to ${INLINE_CODE("false")}`, [
        ["animationClip", "Object"],
        ["needsToProcess", "Boolean"]
    ], "AnimationClip" );
    MAKE_CLASS_METHOD( ".addNewTrack", `Add a new track in the timeline using the options received. An empty track is generated if no options are sent. Options are the same attributes as the track. Check class specific tracks. ${INLINE_CODE("skipCallback")} skips ${INLINE_CODE("addNewTrack")}`, [
        ["options", "Object"],
        ["skipCallback", "Boolean"]
    ], "Number" );
    MAKE_CLASS_METHOD( ".getTracksInRange", "Get the tracks inside the specified vertical range (pixels).", [
        ["minY", "Number"],
        ["maxY", "Number"],
    ], "Array" );
    MAKE_CLASS_METHOD( ".setDuration", "Set the duration of the animation.", [
        ["duration", "Number"],
        ["skipCallback", "Boolean"]
    ] );
    MAKE_CLASS_METHOD( ".setTime", "Set the current time of the animation.", [
        ["time", "Number"],
        ["skipCallback", "Boolean"]
    ] );
    MAKE_CLASS_METHOD( ".setScale", "Set the scale (pixelsPerSecond) of the timeline. Usually called when the user zooms in/out.", [
        ["scale", "Number"]
    ] );
    MAKE_CLASS_METHOD( ".setState", "Set whether the animation is playing (true) or paused (false).", [
        ["state", "Number"],
        ["skipCallback", "Boolean"]
    ] );
    MAKE_CLASS_METHOD( ".setLoopMode", "Set the loop mode of the animation.", [
        ["loopState", "Number"],
        ["skipCallback", "Boolean"]
    ] );

    MAKE_CLASS_METHOD( ".getVisibleItems", `Returns a reference to the track tree elements. Each element has a ${INLINE_CODE(".treeData.trackData")}.`, [ ], "HTMLCollection" );

    MAKE_CLASS_METHOD( ".setSelectedItems", `Change which tracks are visible.`, [
        ["items", "Array of Numbers"]
    ] );
    MAKE_CLASS_METHOD( ".changeSelectedItems", `Add or remove visible tracks.`, [
        ["itemsToAdd", "Array of Numbers"],
        ["itemsToRemove", "Array of Numbers"]
    ] );
    MAKE_CLASS_METHOD( ".setTrackState", `Set whether the track should be active or not.`, [
        ["trackIdx", "Numbers"],
        ["isEnabled", "Boolean"],
        ["skipCallback", "Boolean"],
    ] );
    
    MAKE_CLASS_METHOD( ".saveState", `Saves the current state of the track into the history.`, [
        ["trackIdx", "Number"],
        ["combineWithPrevious", "Boolean"],
    ], "" );

    MAKE_CLASS_METHOD( ".undo", `Pops the stack of the undo history and sets it as current. Stores the previous state into the redo history.`, [
    ], "" );
    MAKE_CLASS_METHOD( ".redo", `Pops the stack of the redo history and sets it as current. Stores the previous state into the undo history.`, [
    ], "" );

    MAKE_CLASS_METHOD( ".resize", `Resize timeline. If no parameters are sent, it uses its container to determine the size.`, [
        ["size", "[width, height] (optional)"]
    ] );

    MAKE_CLASS_METHOD( ".show", `Make html visible`, [] );
    MAKE_CLASS_METHOD( ".hide", `Make html hidden`, [] );

    MAKE_CLASS_METHOD( ".processKeys", `Processes keyboard ${INLINE_CODE("keydown")} events such as copy and paste functionalities. This function can be reimplemented if desired`, [
        ["keydownEvent", "KeyboardEvent"]
    ] );

    MAKE_HEADER( "Controls", "h2", "" );
    const baseControls = [
        ["Mouse left click", ""],
        [
            ["Drag over time markers", "change current time "],
            ["Drag over tracks", "move timeline view"],
        ],
        ["Mouse right click", "Opens contextual menu"],
        ["Shift + Wheel", "Zoom in/out"],
        ["Ctrl + C", "Copy selected elements"],
        ["Ctrl + V", "Paste selected elements"],
        ["Space", "Changes timeline state"],
        ["Delete", "Delete selected elements"],
        ["Backspace", "Delete selected elements"],
    ];
    MAKE_PARAGRAPH(`Default keyboard controls can be changed by reimplementing ${INLINE_CODE("processKeys")}`);
    MAKE_CODE_BULLET_LIST( baseControls );

    MAKE_HEADER( "Keyframes Timeline", "h1", "keyframes-timeline" );

    {
        const keyframestimeline = new KeyFramesTimeline( "KeyframesId", { title: "Keyframes Timeline" } );
        const content = document.getElementById( 'content' );
        const area = new LX.Area( { skipAppend: true, height: "350px" } );
        area.attach(keyframestimeline);
        content.appendChild( area.root );
        keyframestimeline.resize();

        if ( window.keyframeTimeline ){ window.keyframeTimeline.__terminate = true; }
        window.keyframeTimeline = keyframestimeline;
        
        const animation = {
            duration: 10,
            tracks: [
                { id: "track1" },
                { id: "group.track2", times: [0,1,2,3] },
                { id: "group.track3", times: [0,1,2,3], values:[0,11,22,33], curvesRange:[0,33] },
                { id: "group.track333", times: [0,1,2,3], values:[0,11,22,33], curves: false, curvesRange:[0,33] },
                { id: "group.track4", times: [1,2,3,4], values:[0,0,0,1,11,111,2,22,222,3,33,333], dim:3 },
                { id: "track5", times: [0,1,2,3] },
                { times: [0,1,2,3], values: [0,1,2,3], curvesRange:[0,3]  },
            ]
        }
        keyframestimeline.setAnimationClip(animation, true);
        keyframestimeline.setSelectedItems( ["group", 0, 6] );

        keyframestimeline.onAddNewTrack = (trackInfo, options) => {
            trackInfo.dim = 1 + Math.floor( Math.random() * 3.1 ); //doing this before any keyframe is added
            trackInfo.id = "Track " + keyframestimeline.animationClip.tracks.length + " " + trackInfo.dim + "D";
        }

        keyframestimeline.processKeys = function(e){
            if( e.type != 'keydown' ){
                return;
            }
            switch(e.key) {
                case 'Delete': case 'Backspace':
                    this.deleteSelectedContent();
                    break;
                case 'c': case 'C':
                    if(e.ctrlKey)
                        this.copySelectedContent();
                    break;
                case 'v': case 'V':
                    if(e.ctrlKey)
                        this.pasteContent();
                    break;
                case 'z': case 'Z':
                    if(e.ctrlKey)
                        this.undo();
                    break;
                case 'y': case 'Y':
                    if(e.ctrlKey)
                        this.redo();
                    break;
                case ' ':
                    this.changeState();
                    break; 

                case "Shift":
                    this.canvas.style.cursor = "crosshair";
                    break;
            }
        }

        let lastTimestamp = performance.now();
        keyframestimeline.onStateStop = () => {
            keyframestimeline.setTime(0);
        }
        keyframestimeline.onStateChange = () => {
            lastTimestamp = performance.now();
        }
        function render(timestamp){

            // avoids multiple instances of keyframestimeline to render. Just render the last one
            // clicking on other documentation entries WILL NOT terminate render. 
            // TODO it should terminate as soon as documentation page is changed
            if ( keyframestimeline.__terminate ){
                return;
            }

            requestAnimationFrame( render );
            
            if ( keyframestimeline.playing ){
                const dt = ( timestamp - lastTimestamp ) * 0.001;
                keyframestimeline.setTime( (keyframestimeline.currentTime + dt) % keyframestimeline.animationClip.duration)
            }

            lastTimestamp = timestamp;
            keyframestimeline.draw();
        }

        render();
    }
    MAKE_CODE( `@let@ kfTimeline = @new@ LX.@[typ]KeyframesTimeline@(@"KeyTimelineUniqueID"@, @{title:@ @"Keyframes Timeline"@@}@);
panel.attach(kfTimeline.root);` );

   
    MAKE_HEADER( "Keyframes AnimationClip", "h2", "" );
    MAKE_PARAGRAPH( `New animations should be created and set to the timeline through the ${INLINE_CODE("setAnimationClip")} function, that (optionaly) expects an object with the same attributes as an animationClip (see below). )`);
    MAKE_PARAGRAPH( `Tracks will also be processed. Missing attributes will be set to default values.`);
    MAKE_CODE_BULLET_LIST( baseAnimationClipOptions.concat([
        [".tracksPerGroup", "Object", "maps groupIds (Strings) to an array of tracks"],
    ]) );

    MAKE_HEADER( "Keyframes Tracks", "h2", "" );
    MAKE_PARAGRAPH( `New Tracks should be added to the animationClip clip through the ${INLINE_CODE("addNewTrack")} function, that (optionaly) expects an object of the same attributes as a track (see below).`);
    MAKE_PARAGRAPH(`All attributes except ${INLINE_CODE("isTrack")} and ${INLINE_CODE("trackIdx")} will be retrieved from the track information sent to the function, if available.`);
    MAKE_PARAGRAPH(`${INLINE_CODE("id")} and ${INLINE_CODE("name")} attributes will me mapped to the ${INLINE_CODE("id")} of the track (in this order of precedence).`);
    MAKE_CODE_BULLET_LIST( [
        [".isTrack", "Boolean", `${INLINE_CODE("Read-Only")} Identifies it as a track`],
        [".id", "String", `Name of the track. If the track is currently visible, changing its id will require a call to ${INLINE_CODE("updateLeftPanel")}`],
        [".active", "Boolean", `${INLINE_CODE("Read-Only")} Whether it is disabled or not. Use ${INLINE_CODE("setTrackState")} to modify it.`],
        [".locked", "Boolean", `Whether its elements can be modified or not.`],
        [".isSelected", "Boolean", `${INLINE_CODE("Read-Only")} Whether to paint the track background blue, flagging it as selected.`],
        [".trackIdx", "Number", `${INLINE_CODE("Read-Only")} Position of the track in the animationClip's tracks array.`],

        [".dim", "Number", `Number of values per keyframe. It can be modified, as long as it makes sense with ${INLINE_CODE("times")} and ${INLINE_CODE("values")} attributes`],
        [".groupId", "String", `${INLINE_CODE("Read-Only")} Group to which it is attached. Use ${INLINE_CODE("setTracksGroup")} instead of directly modifying it`],
        [".groupTrackIdx", "Number", `${INLINE_CODE("Read-Only")} Index of the track inside the group array`],
        
        [".curves", "Boolean", `Whether to render this track as centered keyframes or curves`],
        [".curvesRange", "[Number, Number]", `range of values [min, max] that the track will hold.`],

        [".values", "Array Number", `Flat array of size = number-of-keyframes * dim, containing the values of each keyframe. Values inside the array can be safely modified. Directly modifying its length might lead to undefined behaviour.`],
        [".times", "Array Number", `Flat array of size = number-of-keyframes, containing the timestamp of each keyframe sorted ascendently. Values inside the array can be safely modified as long as the array is kept sorted ascendently. Directly modifying its length might lead to undefined behaviour.`],
        [".edited", "Array Boolean", `Array of size = number-of-keyframes, containing a flag to indicate whether the keyframe has been modified. Its values can be safely modified.`],
        [".selected", "Array Boolean", `${INLINE_CODE("Read-Only")} Array of size number-of-keyframes, containing a flag to indicate whether the keyframe is currently selected. Modifying it might not update the underlying selection system.`],
        [".hovered", "Array Boolean", `${INLINE_CODE("Read-Only")} Array of size number-of-keyframes, containing a flag to indicate whether the keyframe is currently hovered by the mouse. Modifying it might not update the underlying hovering system.`],

        [".data", "", "user defined data"]
    ] );

    MAKE_HEADER( "Constructor", "h2", "" );
    MAKE_CLASS_CONSTRUCTOR( "KeyFramesTimeline", [
        ["id", "String", "Unique string that identifies this element"],
        ["options", "Object"]
    ] );

    MAKE_HEADER( "Properties", "h2", "" );
    MAKE_PARAGRAPH( `Check ${INLINE_CODE("Timeline")} properties`);
    MAKE_CODE_BULLET_LIST( [
        [".lastKeyFramesSelected", "Array of [trackIdx, keyframeIdx, keyframe time]", `${INLINE_CODE("Read-Only")} the currently selected keyframes across all tracks, sorted ascendently`],
        [".keyValuePerPixel", "Number", `Applicable to tracks with dim = 1, amount of normalized value ( [ 0, 1 ] ) to add per pixel moved while holding ${INLINE_CODE("alt")}. Default to 1/${INLINE_CODE("trackHeight")}`],
        [".defaultCurves", "Boolean", `Applicable to tracks with dim = 1, the default way of rendering tracks with dim = 1. If true, it renders them with curves.`],  
        [".defaultCurvesRange", "[Number, Number]", `Applicable to tracks with dim = 1, the default range of values [min, max] that a track holds.`],  
    ] );

    MAKE_HEADER( "Callbacks", "h2", "" );
    MAKE_PARAGRAPH(`Callbacks can be set directly to the instance of ${INLINE_CODE("KeyFramesTimeline")}`);
    MAKE_PARAGRAPH(`Check ${INLINE_CODE("Timeline")} for the list of inherited callbacks. If a callback appears on both lists, the  ${INLINE_CODE("KeyFramesTimeline")} takes precedence.`);
    MAKE_CLASS_METHOD( "onAddNewTrack", `Triggered after creating a track through the ${INLINE_CODE("addNewTrack")} function. This callback can be used to change the default id of the track, modify the dimension of the values or to insert some initial values. To include this track into a group, use the ${INLINE_CODE("setTracksGroup")} function`, [
        ["track", "Object"],
    ] );
    
    MAKE_CLASS_METHOD( "onItemSelected", `Triggered after calling ${INLINE_CODE("selectItems")}.`, [
        ["currentSelectedItems", "Array of Numbers for tracks or Strings for groups"],
        ["itemsAdded", "Array of Numbers for tracks or Strings for groups"],
        ["itemsRemoved", "Array of Numbers for tracks or Strings for groups"],
    ] );

    MAKE_CLASS_METHOD( "onSelectKeyFrame", `Triggered after selecting a keyframe.`, [
        ["currentSelection", "[trackIdx, keyframeIdx, time of keyframe]"],
    ] );
    
    MAKE_CLASS_METHOD( "onUnselectKeyFrames", `Triggered before unselecting all keyframes.`, [
        ["selectedKeyframes", "Array of [trackIdx, keyframeIdx, timestamp of keyframe]"],
    ] );

    MAKE_CLASS_METHOD( "onContentMoved", `Triggered after moving keyframes horizontally. Calls it for each frame .`, [
        ["trackIndex", "Number"],
        ["newKeyframeIndex", "Number"],
    ] );

    MAKE_CLASS_METHOD( "onUpdateTrack", `Triggered after changing keyframe values through ${INLINE_CODE("Alt")} in a curves track, pasting values, undoing-redoing and adding keyframes.`, [
        ["tracks", "Array of Number"],
    ] );
    
    MAKE_CLASS_METHOD( "onOptimizeTracks", `Triggered after optimizing tracks. It receives either a valid track index or a -1 indicating that all tracks have been optimized at once`, [
        ["trackIndex", "Number"],
    ] );

    MAKE_CLASS_METHOD( "onDeleteKeyFrames", `Triggered after deleting keyframes.`, [
        ["trackIndex", "Number"],
        ["keyframeIndices", "Array of Number"],
    ] );


    MAKE_HEADER( "Methods", "h2", "" );
    MAKE_PARAGRAPH(`Check ${INLINE_CODE("Timeline")} for the list of inherited methods. If a method appears on both lists, the ${INLINE_CODE("KeyFramesTimeline")} takes precedence.`);

    MAKE_CLASS_METHOD( ".setTracksGroup", "Group tracks. A track can only be in one group.", [
        ["groupId", "String"],
        ["trackIndices", "Array Number"],
    ], "" );
    MAKE_CLASS_METHOD( ".getTracksGroup", "Returns an array of object, each being a track of the group.", [
        ["groupId", "String"],
    ], "Array Tracks" );

    MAKE_CLASS_METHOD( ".optimizeTrack", `Removes similar keyframes of a track, given the ${INLINE_CODE("optimizeThreshold")} attribute. If ${INLINE_CODE("onlyEqualTime")} is set, only keyframes with the same time will be removed, keepin the first occurrence`, [
        ["trackIdx", "Number"],
        ["onlyEqualTime", "Boolean"],
        ["skipCallback", "Boolean"],
    ], "" );
    MAKE_CLASS_METHOD( ".optimizeTracks", `Removes similar keyframes of all track, given the ${INLINE_CODE("optimizeThreshold")} attribute. If ${INLINE_CODE("onlyEqualTime")} is set, only keyframes with the same time will be removed, keepin the first occurrence`, [
        ["onlyEqualTime", "Boolean"],
    ], "" );
    
    MAKE_CLASS_METHOD( ".copySelectedContent", `Copies the lastKeyFramesSelected elements into clipboard.`, [
    ], "" );
    MAKE_CLASS_METHOD( ".pasteContent", `Paste copied keyframes into the tracks, positioned at ${INLINE_CODE("time")}.`, [
        ["time", "Number"]
    ], "" );
    MAKE_CLASS_METHOD( ".deleteSelectedContent", `Delete selected keyframes from the tracks.`, [
        ["skipCallback", "Boolean"]
    ], "" );
    MAKE_CLASS_METHOD( ".clearTrack", `Delete all keyframes from a track.`, [
        ["trackIdx", "Number"]
    ], "" );

    MAKE_CLASS_METHOD( ".deleteKeyframes", `Delete keyframes of a track.`, [
        ["trackIdx", "Number"],
        ["frameIndices", "Array of Number"],
        ["skipCallback", "Boolean"]

    ], "" );

    MAKE_CLASS_METHOD( ".addKeyFrames", `Add keyframes to a track. ${INLINE_CODE("newTimes")} must be sorted ascendently. If ${INLINE_CODE("flags")} is set to ${INLINE_CODE("Timeline.ADDKEY_VALUESINARRAYS")} (0x01), values must be an array of arrays, each containing the values of a single frame. Otherwise, it must be a flat array.`, [
        ["trackIdx", "Number"],
        ["newValues", "Array of Number"],
        ["newTimes", "Array of Number"],
        ["timeOffset", "Number"],
        ["flags", "Number"],
    ], "" );

    MAKE_CLASS_METHOD( ".getNearestKeyFrame", `Returns the index of the frame or -1. Modes { -1: nearest frame with t[f] <= time, 0: nearest frame, 1: nearest frame with t[f] >= time }.`, [
        ["track", "obj"],
        ["time", "Number"],
        ["mode", "Number"],
    ], "Number" );
        
    MAKE_CLASS_METHOD( ".processSelectionKeyFrame", `Helper function to select a keyframe and set the timeline time to that keyframe (only if ${INLINE_CODE("multipleSelection")} is ${INLINE_CODE("false")} ). If ${INLINE_CODE("multipleSelection")} is ${INLINE_CODE("true")}, previous selected keyframes are kept selected.`, [
        ["trackIdx", "Number"],
        ["frameIdx", "Number"],
        ["multipleSelection", "Boolean"],
    ], "[trackIdx, frameIdx, frameTime]" );

    MAKE_CLASS_METHOD( ".selectKeyFrame", `Selects a keyframe, adding it to the currently selected keyframes.`, [
        ["trackIdx", "Number"],
        ["frameIdx", "Number"],
        ["skipCallback", "Boolean"],
    ], "[trackIdx, frameIdx, frameTime]" );
           
    MAKE_CLASS_METHOD( ".unSelectKeyFrame", `Unselects a keyframe.`, [
        ["trackIdx", "Number"],
        ["frameIdx", "Number"],
    ], "Boolean" );
    MAKE_CLASS_METHOD( ".unSelectAllKeyFrames", `Unselects all keyframes.`, [
    ], "" );

    MAKE_CLASS_METHOD( ".unHoverAll", `Unhover current keyframes.`, [
    ], "" );

    MAKE_CLASS_METHOD( ".getCurrentKeyFrame", "Get the nearest keyframe to _time_ given a maximum threshold.", [
        ["track", "Object"],
        ["time", "Number"],
        ["threshold", "Number"]
    ], "Number" );

    MAKE_HEADER("Controls", "h2", "" );
    MAKE_PARAGRAPH(`Default keyboard controls can be changed by reimplementing ${INLINE_CODE("processKeys")}`);

    let keyControls = baseControls.slice();
    keyControls[1].push(
        ["ctrlKey + horizontal drag", "move selected keyframes (if any)"],
        ["altKey + vertical drag", `change value of selected keyframes. Only applicable to tracks with dim = 1 and their ${INLINE_CODE("curves")} attribute set to ${INLINE_CODE("true")}`]
    );
    MAKE_CODE_BULLET_LIST( keyControls );

        
    MAKE_HEADER( "Clips timeline", "h1", "clips-timeline" );
    {
        const clipstimeline = new ClipsTimeline( "ClipsId", { title: "Clips Timeline" } );
        const content = document.getElementById( 'content' );
        const area = new LX.Area( { skipAppend: true, height: "350px" } );
        area.attach(clipstimeline);
        content.appendChild( area.root );
        clipstimeline.resize();
        if ( window.clipsTimeline ){ window.clipsTimeline.__terminate = true; }
        window.clipsTimeline = clipstimeline;
        
        const animation = {
            duration: 10,
            tracks: [
                { id: "track0" },
                { id: "track1", clips: [{id:"clip1", start: 0, duration:1, clipColor:"#800"}] },
                { id: "track2", clips: [{id:"clip1", start: 1, fadein: 1.2, fadeout: 1.7, duration:1, clipColor:"#080"}] },
                { id: "My Track", clips: [{id:"clip1", start: 1, fadein: 1.2, fadeout: 1.7, duration:1, clipColor:"#008", fadeColor: "#003"}] },
            ]
        }
        clipstimeline.setAnimationClip(animation, true);

        clipstimeline.onAddNewTrack = function( trackInfo ){
            trackInfo.id = "Track " + (this.animationClip.tracks.length-1);
        }

        clipstimeline.processKeys = function(e){
            if( e.type != 'keydown' ){
                return;
            }
            switch(e.key) {
                case 'Delete': case 'Backspace':
                    this.deleteSelectedContent();
                    break;
                case 'c': case 'C':
                    if(e.ctrlKey)
                        this.copySelectedContent();
                    break;
                case 'v': case 'V':
                    if(e.ctrlKey)
                        this.pasteContent();
                    break;
                case 'z': case 'Z':
                    if(e.ctrlKey)
                        this.undo();
                    break;
                case 'y': case 'Y':
                    if(e.ctrlKey)
                        this.redo();
                    break;
                case ' ':
                    this.changeState();
                    break; 

                case "Shift":
                    this.canvas.style.cursor = "crosshair";
                    break;
            }
        }

        let lastTimestamp = performance.now();
        clipstimeline.onStateStop = () => {
            clipstimeline.setTime(0);
        }
        clipstimeline.onStateChange = () => {
            lastTimestamp = performance.now();
        }
        function render(timestamp){

            // avoids multiple instances of clipstimeline to render. Just render the last one
            // clicking on other documentation entries WILL NOT terminate render. 
            // TODO it should terminate as soon as documentation page is changed
            if ( clipstimeline.__terminate ){
                return;
            }

            requestAnimationFrame( render );
            
            if ( clipstimeline.playing ){
                const dt = ( timestamp - lastTimestamp ) * 0.001;
                clipstimeline.setTime( (clipstimeline.currentTime + dt) % clipstimeline.animationClip.duration)
            }

            lastTimestamp = timestamp;
            clipstimeline.draw();
        }

        render();
    }
    MAKE_CODE( `@let@ clipTimeline = @new@ LX.@[typ]ClipsTimeline@(@"ClipsTimelineUniqueID"@, @{title:@ @"Clips Timeline"@@}@);
panel.attach(clipTimeline.root);` );

    MAKE_HEADER( "ClipStimeline AnimationClip", "h2", "" );
    MAKE_PARAGRAPH( `New animations should be created and set to the timeline through the ${INLINE_CODE("setAnimationClip")} function, that (optionaly) expects an object with the same attributes as an animationClip (see below). )`);
    MAKE_PARAGRAPH( `Tracks will also be processed. Missing attributes will be set to default values.`);
    MAKE_CODE_BULLET_LIST( baseAnimationClipOptions );

    MAKE_HEADER( "Clip Tracks", "h2", "" );
    MAKE_PARAGRAPH( `New Tracks should be added to the animationClip clip through the ${INLINE_CODE("addNewTrack")} function, that (optionaly) expects an object with the same attributes as a track (see below).`);
    MAKE_PARAGRAPH(`All attributes except ${INLINE_CODE("isTrack")} and ${INLINE_CODE("trackIdx")} will be retrieved from the track information sent to the function. Missing attributes will be set to default values.`);
    MAKE_PARAGRAPH(`${INLINE_CODE("id")} and ${INLINE_CODE("name")} attributes will me mapped to the ${INLINE_CODE("id")} of the track (in this order of precedence).`);
    MAKE_CODE_BULLET_LIST( [
        [".isTrack", "Boolean", `${INLINE_CODE("Read-Only")} Identifies it as a track`],
        [".id", "String", `Name of the track. If the track is currently visible, changing its id will require a call to ${INLINE_CODE("updateLeftPanel")}`],
        [".active", "Boolean", `${INLINE_CODE("Read-Only")} Whether it is disabled or not. Use ${INLINE_CODE("setTrackState")} to modify it.`],
        [".locked", "Boolean", `Whether its elements can be modified or not.`],
        [".isSelected", "Boolean", `${INLINE_CODE("Read-Only")} Whether to paint the track background blue, flagging it as selected.`],
        [".trackIdx", "Number", `${INLINE_CODE("Read-Only")} Position of the track in the animationClip's tracks array.`],

        [".clips", "Array Number", `Array with clips that will be attached to the track. Clip attributes can be modified. Clips must be sortes ascendently by its timing properties ${INLINE_CODE("start")} and ${INLINE_CODE("duration")} and must not overlap.`],
        [".edited", "Array Boolean", `Array of size = number-of-clips, containing a flag to indicate whether the clip has been modified. Its values can be safely modified.`],
        [".selected", "Array Boolean", `${INLINE_CODE("Read-Only")} Array of size number-of-clips, containing a flag to indicate whether the clip is currently selected. Modifying it might not update the underlying selection system.`],
        [".hovered", "Array Boolean", `${INLINE_CODE("Read-Only")} Array of size number-of-clips, containing a flag to indicate whether the clip is currently hovered by the mouse. Modifying it might not update the underlying hovering system.`],

        [".data", "", "user defined data"]
    ] );

    MAKE_HEADER( "Clip Structure", "h2", "" );
    MAKE_PARAGRAPH( `Clips (not to be confused with AnimationClip) are the objects that will appear in the tracks, which might contain, the following properties:`);
    MAKE_CODE_BULLET_LIST( [
        [".id", "String", `Will be used to display a name over the clip. Can be empty`],
        [".start", "Number", `${INLINE_CODE("Mandatory")} Time on which the clip starts.`],
        [".duration", "Number", `${INLINE_CODE("Mandatory")} Duration of the clip. The end time will be computed as start + duration.`],
        [".fadein", "Number", `If defined, sets the time at which the fadein ends. Must be in global, not relative to start`],
        [".fadeout", "Number", `If defined, sets the time at which the fadeout starts. Must be in global, not relative to start`],
        [".clipColor", "Color", `Defines the color of the clip. Must be a value accepted by ${INLINE_CODE("CanvasRenderingContext2D.fillStyle")}.`],
        [".fadeColor", "Color", `Color of the areas defined by the fade attributes. Must be a value accepted by ${INLINE_CODE("CanvasRenderingContext2D.fillStyle")}.`],
    ] );

    MAKE_PARAGRAPH( `Clips can contain any other attributes and will be accessible at all times.`);
    MAKE_PARAGRAPH( `The ${INLINE_CODE("cloneClips")} should be implemented by the user so the system knows how to properly duplicate clips.`);
    
    MAKE_HEADER( "Constructor", "h2", "" );
    MAKE_CLASS_CONSTRUCTOR( "ClipsTimeline", [
        ["id", "String", "Unique string that identifies this element"],
        ["options", "Object"]
    ] );

    MAKE_HEADER( "Properties", "h2", "" );
    MAKE_PARAGRAPH( `Check ${INLINE_CODE("Timeline")} properties`);
    MAKE_CODE_BULLET_LIST( [
        [".lastClipsSelected", "Array of [trackIdx, clipIdx]", `${INLINE_CODE("Read-Only")} The currently selected clips across all tracks, sorted ascendently`],
    ] );

    MAKE_HEADER( "Callbacks", "h2", "" );
    MAKE_PARAGRAPH(`Callbacks can be set directly to the instance of ${INLINE_CODE("ClipsTimeline")}`);
    MAKE_PARAGRAPH(`Check ${INLINE_CODE("Timeline")} for the list of inherited callbacks. If a callback appears on both lists, the  ${INLINE_CODE("ClipsTimeline")} takes precedence.`);

    MAKE_CLASS_METHOD( "onUpdateTrack", `Triggered after adding clips, pasting clips and undoing-redoing.`, [
        ["tracks", "Array of Number"],
    ] );
    
    MAKE_CLASS_METHOD( "onContentMoved", `Triggered after moving clips horizontally or moving the fadein, fadeout and duration sliders. Calls it for each clip .`, [
        ["clip", "Object"],
        ["deltaTime", "Number"],
    ] );

    MAKE_CLASS_METHOD( "onSelectClip", `Triggered after selecting a clip. If all clips are selected, it returns null.`, [
        ["clip", "Object"],
    ] );
    MAKE_CLASS_METHOD( "onDeleteClip", `Triggered after deleting a clip.`, [
        ["trackIdx", "Number"],
        ["clipIdx", "Number"],
        ["clip", "Object"],
    ] );

    MAKE_CLASS_METHOD( "onDeleteSelectedClips", `Triggered after deleting the selected content.`, [
        ["selectedContent", "Array of [trackIdx, clipIdx, clip Object]"],
    ] );


    MAKE_HEADER( "Methods", "h2", "" );
    MAKE_PARAGRAPH(`Check ${INLINE_CODE("Timeline")} for the list of inherited methods. If a method appears on both lists, the ${INLINE_CODE("ClipsTimeline")} takes precedence.`);

    MAKE_CLASS_METHOD( ".cloneClips", `Deep clone of a clip. Used to copy and paste clips. The default implementation uses ${INLINE_CODE("JSON.parse(JSON.stringify( ))")}.  ${INLINE_CODE("timeOffset")} adds/subtracts a delta time to all duplicated clips`, [
        ["clipsToClone", "Array of Objects"],
        ["timeOffset", "Number"],
    ], "Array of Objects" );

    MAKE_CLASS_METHOD( ".addClip", `Add a clip in a track. An ${INLINE_CODE("offsetTime")} is added to the time attributes of the clip. If ${INLINE_CODE("trackIdx")} is -1, the clip will be added in the first suitable track it finds, starting from ${INLINE_CODE("searchStartTrackIdx")} (defaults to 0). Returns the clip's index in the track.`, [
        ["trackIdx", "Int"],
        ["offsetTime", "Number"],
        ["searchStartTrackIdx", "Int"],
    ], "Number" );

    MAKE_CLASS_METHOD( ".addClips", `Add several clips in the timeline, starting from ${INLINE_CODE("searchStartTrackIdx")} (defaults to 0). An ${INLINE_CODE("offsetTime")} is added to the time attributes of the clip.`, [
        ["clips", "Array of Objects"],
        ["offsetTime", "Number"],
        ["searchStartTrackIdx", "Int"],
    ], "Number" );

    MAKE_CLASS_METHOD( ".getClipOnTime", `Search clip in track that is on the specified time. Returns -1 if no clip overlaps with the timestamp`, [
        ["track", "Object"],
        ["time", "Number"],
        ["threshold", "Number"],
    ], "Number" );

    MAKE_CLASS_METHOD( ".copySelectedContent", `Copies (clones) the lastSelectedClip elements into clipboard.`, [
    ], "" );
    MAKE_CLASS_METHOD( ".pasteContent", `Paste copied clips into the tracks, positioned at ${INLINE_CODE("time")}.`, [
        ["time", "Number"]
    ], "" );
    MAKE_CLASS_METHOD( ".deleteSelectedContent", `Delete selected clips from the tracks.`, [
        ["skipCallback", "Boolean"]
    ], "" );
    MAKE_CLASS_METHOD( ".clearTrack", `Delete all clips from a track.`, [
        ["trackIdx", "Number"]
    ], "" );

    MAKE_CLASS_METHOD( ".deleteClip", `Delete selected clips from the tracks.`, [
        ["trackIdx", "Number"],
        ["clipIdx", "Number"],
        ["skipCallback", "Boolean"]
    ], "" );

    MAKE_CLASS_METHOD( ".selectClip", `Selected a clip of the track. If ${INLINE_CODE("unselect")} is true, it unselects all selected clips, and makes this the only one selected`, [
        ["trackIdx", "Number"],
        ["clipIdx", "Number"],
        ["unselect", "Boolean"],
        ["skipCallback", "Boolean"]
    ], "Number" );

    MAKE_CLASS_METHOD( ".selectAll", `Unselect all selected clips.`, [
        ["skipCallback", "Boolean"]
    ], "" );

    MAKE_CLASS_METHOD( ".unSelectClip", `Unselect a clip of the track.`, [
        ["trackIdx", "Number"],
        ["clipIdx", "Number"],
    ], "Number" );

    MAKE_CLASS_METHOD( ".unSelectAllClips", `Unselect all selected clips.`, [
    ], "" );

    MAKE_CLASS_METHOD( ".unHoverAll", `Unhover current clips.`, [
    ], "" );


    MAKE_HEADER("Controls", "h2", "" );
    MAKE_PARAGRAPH(`Default keyboard controls can be changed by reimplementing ${INLINE_CODE("processKeys")}`);
    let clipControls = baseControls.slice();
    clipControls[1].push(
        ["ctrlKey + horizontal drag", `move selected clips (if any) horizontally. Holding ${INLINE_CODE("ctrlKey")} pressed is not necessary once the mouse is clicked down.` ],
        ["ctrlKey + altKey + vertical drag", `move selected clips (if any) vertically. It automatically creates new tracks when reaching the bottom. Holding ${INLINE_CODE("ctrlKey")} pressed is not necessary once the mouse is clicked down.`]
    );
    MAKE_CODE_BULLET_LIST( clipControls );


    MAKE_LINE_BREAK();
    MAKE_LINE_BREAK();

</script>