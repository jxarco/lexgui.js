<script type="module">
    import { LX } from 'lexgui';

    const content = document.getElementById('content');
    const componentName = "Data Tree";

    // Data Tree
    docMaker.header(componentName + ".", "h1", componentName.toLowerCase());
    docMaker.paragraph(`Represents a data hierarchy visualization Tree. Especially useful when presenting data with parent-child
      relationships, such as file directories, organizational structures, family trees, and more.`, false, "text-muted-foreground");

    {
        window.__addInteractiveCodeExample( content, componentName, panel => {
            const sceneData = {
                id: "root",
                children: [ {
                    id: "node_1", children: [{
                        id: "node_1_1", icon: "Box", children: [],
                        actions: [ {
                            name: "Open script", icon: "Scroll",
                            callback: function (node) { console.log(node.id + ": Script opened!") }
                        }]
                    }]
                }, {
                    id: "node_2", icon: "CirclePlay", children: []
                }]
            };

            const dataTreeIcons = [
                { name: "Add node", icon: "Plus", callback: () => { console.log("Node added!") } },
                { name: "Instantiate scene", icon: "Link", callback: () => { console.log("Scene instantiated!") } }
            ];

            panel.addTree("Scene Tree", sceneData, {
                icons: dataTreeIcons,
                rename: true
            });
        });
    }

    docMaker.header("Usage", "h2");
    docMaker.paragraph( `Call ${docMaker.iCode("Panel.addTree(name, data, options)")} to add a ${ componentName } Component to your panel or
    create it anywhere using ${docMaker.iCode(`new LX.${ componentName.replace( /\s/g, '' ) }`)} to append its root to any container.` );
    docMaker.lineBreak();
    docMaker.paragraph( `Subscribe to events using ${ docMaker.iCode( "LX.Tree,on( eventName: string, callback: NodeTreeEventCallback )" ) } to add an NodeTreeEventCallback for the following UI action events, where NodeTreeEventCallback has the following
        parameters: ${ docMaker.iCode("event") } (NodeTreeEvent) and ${ docMaker.iCode("resolve") } (Function). Users must call resolve to perform the action for cancellable events. ` );

    docMaker.note( `The ${ docMaker.iCode("event") } in the NodeTreeEventCallback function contains common parameters as ${ docMaker.iCode("type") } and ${ docMaker.iCode("userInitiated") } and can contains more information
    depending on the event.` );

    docMaker.classMethod( "select", `Asset has been selected.`, [
        [ "event", "{ type, userInitiated, items }" ]
    ] );

    docMaker.classMethod( "delete", `Asset has been deleted.`, [
        [ "event", "{ type, userInitiated, items }" ]
    ] );

    docMaker.classMethod( "rename", `Asset has been renamed.`, [
        [ "event", "{ type, userInitiated, items, oldName, newName }" ]
    ] );

    docMaker.classMethod( "dblClick", `Asset has been double clicked.`, [
        [ "event", "{ type, userInitiated, items }" ]
    ] );

    docMaker.classMethod( "move", `Asset has been moved.`, [
        [ "event", "{ type, userInitiated, items, from, to }" ]
    ] );

    docMaker.classMethod( "visibleChanged", `Asset visibility has changed.`, [
        [ "event", "{ type, userInitiated, items }" ]
    ] );

    docMaker.classMethod( "caretChanged", `Asset has been opened or closed.`, [
        [ "event", "{ type, userInitiated, items }" ]
    ] );

    docMaker.classMethod( "contextMenu", `Asset context menu has been opened (return Array with options).`, [
        [ "event", "{ type, userInitiated, items, from }" ]
    ] );

    docMaker.classMethod( "beforeDelete", `Called before deleting assets.`, [
        [ "event", "{ type, userInitiated, items }" ],
        [ "resolve", "Function" ]
    ] );

    docMaker.classMethod( "beforeRename", `Called before renaming assets.`, [
        [ "event", "{ type, userInitiated, items, oldName, newName }" ],
        [ "resolve", "Function" ]
    ] );

    docMaker.classMethod( "beforeMove", `Called before moving assets.`, [
        [ "event", "{ type, userInitiated, items, from, to }" ],
        [ "resolve", "Function" ]
    ] );

    docMaker.header("API Reference", "h2");

    {
        const area = new LX.Area( { skipAppend: true, height: "auto", className: "mb-6" } );
        const panel = area.addPanel();
        content.appendChild( area.root );

        panel.addTable( null, {
            head: [ "Parameter", "Type", "Description", "Default" ],
            body: [
                ["name", "String", "Component name", "—"],
                ["data", "Object", "Hierarchical data", "—"],
                ["options", "Object", "Basic options for a component", "—"]
            ].map( v => {
                return [ docMaker.iCode( v[ 0 ], "table" ), docMaker.iCode( v[ 1 ], "table desc" ), v[ 2 ], v[ 3 ] != "—" ? docMaker.iCode( v[ 3 ], "table desc" ) : v[ 3 ] ];
            } )
        }, {});
        docMaker.lineBreak( panel.root );
        panel.addTable( null, {
            head: [ "Option", "Type", "Description", "Default" ],
            body: [
                ["icons", "Array", "Array of objects with button information {name, icon, callback}", "—"],
                ["filter", "Boolean", "Adds a filter bar", "true"],
                ["rename", "Boolean", "Allow item rename", "true"],
                ["onlyFolders", "Boolean", "Only show items with 'folder' type", "false"]
            ].map( v => {
                return [ docMaker.iCode( v[ 0 ], "table" ), docMaker.iCode( v[ 1 ], "table desc" ), v[ 2 ], v[ 3 ] != "—" ? docMaker.iCode( v[ 3 ], "table desc" ) : v[ 3 ] ];
            } )
        }, {});
    }
</script>